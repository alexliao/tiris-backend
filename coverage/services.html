
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>services: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">tiris-backend/internal/services/auth_service.go (76.6%)</option>
				
				<option value="file1">tiris-backend/internal/services/exchange_service.go (77.6%)</option>
				
				<option value="file2">tiris-backend/internal/services/subaccount_service.go (76.0%)</option>
				
				<option value="file3">tiris-backend/internal/services/trading_log_service.go (75.4%)</option>
				
				<option value="file4">tiris-backend/internal/services/transaction_service.go (77.3%)</option>
				
				<option value="file5">tiris-backend/internal/services/user_service.go (79.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "tiris-backend/internal/models"
        "tiris-backend/internal/repositories"
        "tiris-backend/pkg/auth"

        "github.com/google/uuid"
        "golang.org/x/oauth2"
        "gorm.io/datatypes"
)

// AuthService handles authentication business logic
type AuthService struct {
        repos        *repositories.Repositories
        jwtManager   auth.JWTManagerInterface
        oauthManager auth.OAuthManagerInterface
}

// NewAuthService creates a new authentication service
func NewAuthService(repos *repositories.Repositories, jwtManager auth.JWTManagerInterface, oauthManager auth.OAuthManagerInterface) *AuthService <span class="cov10" title="10">{
        return &amp;AuthService{
                repos:        repos,
                jwtManager:   jwtManager,
                oauthManager: oauthManager,
        }
}</span>

// LoginRequest represents a login request
type LoginRequest struct {
        Provider    string `json:"provider" binding:"required,oneof=google wechat"`
        RedirectURL string `json:"redirect_uri" binding:"required,url"`
}

// LoginResponse represents a login response with auth URL
type LoginResponse struct {
        AuthURL string `json:"auth_url"`
        State   string `json:"state"`
}

// CallbackRequest represents an OAuth callback request
type CallbackRequest struct {
        Provider string `json:"provider" binding:"required,oneof=google wechat"`
        Code     string `json:"code" binding:"required"`
        State    string `json:"state" binding:"required"`
}

// AuthResponse represents an authentication response with tokens
type AuthResponse struct {
        AccessToken  string    `json:"access_token"`
        RefreshToken string    `json:"refresh_token"`
        TokenType    string    `json:"token_type"`
        ExpiresIn    int64     `json:"expires_in"`
        User         *UserInfo `json:"user"`
}

// UserInfo represents user information in auth response
type UserInfo struct {
        ID       uuid.UUID              `json:"id"`
        Username string                 `json:"username"`
        Email    string                 `json:"email"`
        Avatar   *string                `json:"avatar,omitempty"`
        Info     map[string]interface{} `json:"info"`
}

// RefreshRequest represents a token refresh request
type RefreshRequest struct {
        RefreshToken string `json:"refresh_token" binding:"required"`
}

// InitiateLogin initiates OAuth login flow
func (s *AuthService) InitiateLogin(ctx context.Context, req *LoginRequest) (*LoginResponse, error) <span class="cov3" title="2">{
        // Generate state for CSRF protection
        state := auth.GenerateState()

        // Get OAuth authorization URL
        authURL, err := s.oauthManager.GetAuthURL(auth.OAuthProvider(req.Provider), state)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to generate auth URL: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;LoginResponse{
                AuthURL: authURL,
                State:   state,
        }, nil</span>
}

// HandleCallback handles OAuth callback and creates/updates user
func (s *AuthService) HandleCallback(ctx context.Context, req *CallbackRequest, expectedState string) (*AuthResponse, error) <span class="cov6" title="4">{
        // Validate state to prevent CSRF attacks
        if err := auth.ValidateState(expectedState, req.State); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid state parameter: %w", err)
        }</span>

        // Exchange code for token
        <span class="cov5" title="3">token, err := s.oauthManager.ExchangeCodeForToken(auth.OAuthProvider(req.Provider), req.Code)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to exchange code for token: %w", err)
        }</span>

        // Get user info from OAuth provider
        <span class="cov3" title="2">oauthUser, err := s.oauthManager.GetUserInfo(auth.OAuthProvider(req.Provider), token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user info: %w", err)
        }</span>

        // Find or create user
        <span class="cov3" title="2">user, err := s.findOrCreateUser(ctx, oauthUser, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find or create user: %w", err)
        }</span>

        // Generate JWT tokens
        <span class="cov3" title="2">tokenPair, err := s.jwtManager.GenerateTokenPair(user.ID, user.Username, user.Email, "user")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate tokens: %w", err)
        }</span>

        // Convert user info
        <span class="cov3" title="2">var avatar *string
        if user.Avatar != nil &amp;&amp; *user.Avatar != "" </span><span class="cov3" title="2">{
                avatar = user.Avatar
        }</span>

        <span class="cov3" title="2">var userInfoMap map[string]interface{}
        if err := json.Unmarshal(user.Info, &amp;userInfoMap); err != nil </span><span class="cov0" title="0">{
                userInfoMap = make(map[string]interface{})
        }</span>

        <span class="cov3" title="2">userInfo := &amp;UserInfo{
                ID:       user.ID,
                Username: user.Username,
                Email:    user.Email,
                Avatar:   avatar,
                Info:     userInfoMap,
        }

        return &amp;AuthResponse{
                AccessToken:  tokenPair.AccessToken,
                RefreshToken: tokenPair.RefreshToken,
                TokenType:    tokenPair.TokenType,
                ExpiresIn:    tokenPair.ExpiresIn,
                User:         userInfo,
        }, nil</span>
}

// RefreshToken refreshes an access token using refresh token
func (s *AuthService) RefreshToken(ctx context.Context, req *RefreshRequest) (*AuthResponse, error) <span class="cov5" title="3">{
        // Validate refresh token and get user ID
        userID, err := s.jwtManager.ValidateRefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid refresh token: %w", err)
        }</span>

        // Get user from database
        <span class="cov3" title="2">user, err := s.repos.User.GetByID(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found")
        }</span>

        // Generate new access token
        <span class="cov1" title="1">accessToken, err := s.jwtManager.RefreshToken(req.RefreshToken, user.Username, user.Email, "user")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to refresh token: %w", err)
        }</span>

        // Convert user info
        <span class="cov1" title="1">var avatar *string
        if user.Avatar != nil &amp;&amp; *user.Avatar != "" </span><span class="cov1" title="1">{
                avatar = user.Avatar
        }</span>

        <span class="cov1" title="1">var userInfoMap map[string]interface{}
        if err := json.Unmarshal(user.Info, &amp;userInfoMap); err != nil </span><span class="cov0" title="0">{
                userInfoMap = make(map[string]interface{})
        }</span>

        <span class="cov1" title="1">userInfo := &amp;UserInfo{
                ID:       user.ID,
                Username: user.Username,
                Email:    user.Email,
                Avatar:   avatar,
                Info:     userInfoMap,
        }

        return &amp;AuthResponse{
                AccessToken:  accessToken,
                RefreshToken: req.RefreshToken, // Keep the same refresh token
                TokenType:    "Bearer",
                ExpiresIn:    3600, // 1 hour
                User:         userInfo,
        }, nil</span>
}

// Logout invalidates user session
func (s *AuthService) Logout(ctx context.Context, userID uuid.UUID) error <span class="cov1" title="1">{
        // In a more sophisticated implementation, we might maintain a blacklist of tokens
        // For now, we just return success since JWT tokens are stateless
        // The client should discard the tokens
        return nil
}</span>

// findOrCreateUser finds existing user or creates new one from OAuth info
func (s *AuthService) findOrCreateUser(ctx context.Context, oauthUser *auth.OAuthUser, token *oauth2.Token) (*models.User, error) <span class="cov3" title="2">{
        // Check if OAuth token already exists
        existingToken, err := s.repos.OAuthToken.GetByProviderUserID(ctx, oauthUser.Provider, oauthUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing OAuth token: %w", err)
        }</span>

        <span class="cov3" title="2">if existingToken != nil </span><span class="cov1" title="1">{
                // User exists, update OAuth token and return user
                existingToken.AccessToken = token.AccessToken
                if token.RefreshToken != "" </span><span class="cov1" title="1">{
                        existingToken.RefreshToken = &amp;token.RefreshToken
                }</span>
                <span class="cov1" title="1">if !token.Expiry.IsZero() </span><span class="cov1" title="1">{
                        existingToken.ExpiresAt = &amp;token.Expiry
                }</span>
                <span class="cov1" title="1">existingToken.UpdatedAt = time.Now()

                // Update OAuth token info
                infoMap := map[string]interface{}{
                        "last_login": time.Now(),
                        "provider_data": map[string]interface{}{
                                "name":   oauthUser.Name,
                                "avatar": oauthUser.Avatar,
                        },
                }
                infoJSON, _ := json.Marshal(infoMap)
                existingToken.Info = datatypes.JSON(infoJSON)

                if err := s.repos.OAuthToken.Update(ctx, existingToken); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to update OAuth token: %w", err)
                }</span>

                // Get and return the user
                <span class="cov1" title="1">user, err := s.repos.User.GetByID(ctx, existingToken.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get existing user: %w", err)
                }</span>

                // Update user avatar if provided
                <span class="cov1" title="1">if oauthUser.Avatar != "" &amp;&amp; (user.Avatar == nil || *user.Avatar != oauthUser.Avatar) </span><span class="cov0" title="0">{
                        user.Avatar = &amp;oauthUser.Avatar
                        if err := s.repos.User.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to update user avatar: %w", err)
                        }</span>
                }

                <span class="cov1" title="1">return user, nil</span>
        }

        // Check if user exists by email
        <span class="cov1" title="1">existingUser, err := s.repos.User.GetByEmail(ctx, oauthUser.Email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing user: %w", err)
        }</span>

        <span class="cov1" title="1">var user *models.User
        if existingUser != nil </span><span class="cov0" title="0">{
                // User exists with this email, link OAuth account
                user = existingUser
        }</span> else<span class="cov1" title="1"> {
                // Create new user
                user = &amp;models.User{
                        Username: s.generateUsername(oauthUser.Name, oauthUser.Email),
                        Email:    oauthUser.Email,
                        Avatar:   &amp;oauthUser.Avatar,
                        Settings: datatypes.JSON{},
                        Info: func() datatypes.JSON </span><span class="cov1" title="1">{
                                infoMap := map[string]interface{}{
                                        "oauth_provider": oauthUser.Provider,
                                        "created_via":    "oauth",
                                        "first_login":    time.Now(),
                                }
                                infoJSON, _ := json.Marshal(infoMap)
                                return datatypes.JSON(infoJSON)
                        }</span>(),
                }

                <span class="cov1" title="1">if err := s.repos.User.Create(ctx, user); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create user: %w", err)
                }</span>
        }

        // Create OAuth token record
        <span class="cov1" title="1">oauthToken := &amp;models.OAuthToken{
                UserID:         user.ID,
                Provider:       oauthUser.Provider,
                ProviderUserID: oauthUser.ID,
                AccessToken:    token.AccessToken,
                RefreshToken:   &amp;token.RefreshToken,
                ExpiresAt:      &amp;token.Expiry,
                Info: func() datatypes.JSON </span><span class="cov1" title="1">{
                        infoMap := map[string]interface{}{
                                "provider_data": map[string]interface{}{
                                        "name":   oauthUser.Name,
                                        "avatar": oauthUser.Avatar,
                                },
                                "first_auth": time.Now(),
                        }
                        infoJSON, _ := json.Marshal(infoMap)
                        return datatypes.JSON(infoJSON)
                }</span>(),
        }

        <span class="cov1" title="1">if err := s.repos.OAuthToken.Create(ctx, oauthToken); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create OAuth token: %w", err)
        }</span>

        <span class="cov1" title="1">return user, nil</span>
}

// generateUsername generates a unique username from name and email
func (s *AuthService) generateUsername(name, email string) string <span class="cov1" title="1">{
        // Start with name if available
        if name != "" </span><span class="cov1" title="1">{
                // Clean name: remove spaces, convert to lowercase
                username := ""
                for _, char := range name </span><span class="cov9" title="8">{
                        if (char &gt;= 'a' &amp;&amp; char &lt;= 'z') || (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') || (char &gt;= '0' &amp;&amp; char &lt;= '9') </span><span class="cov8" title="7">{
                                username += string(char)
                        }</span>
                }
                <span class="cov1" title="1">if len(username) &gt;= 3 </span><span class="cov1" title="1">{
                        return username[:min(len(username), 20)]
                }</span>
        }

        // Fall back to email prefix
        <span class="cov0" title="0">if email != "" </span><span class="cov0" title="0">{
                atIndex := strings.Index(email, "@")
                if atIndex &gt; 0 </span><span class="cov0" title="0">{
                        parts := email[:atIndex]
                        if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                                return parts[:min(len(parts), 20)]
                        }</span>
                }
        }

        // Last resort: generate random username
        <span class="cov0" title="0">return fmt.Sprintf("user%d", time.Now().Unix())</span>
}

// min returns the minimum of two integers
func min(a, b int) int <span class="cov1" title="1">{
        if a &lt; b </span><span class="cov1" title="1">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"

        "tiris-backend/internal/models"
        "tiris-backend/internal/repositories"

        "github.com/google/uuid"
        "gorm.io/datatypes"
)

// ExchangeService handles exchange business logic
type ExchangeService struct {
        repos *repositories.Repositories
}

// NewExchangeService creates a new exchange service
func NewExchangeService(repos *repositories.Repositories) *ExchangeService <span class="cov10" title="13">{
        return &amp;ExchangeService{
                repos: repos,
        }
}</span>

// ExchangeResponse represents exchange information in responses
type ExchangeResponse struct {
        ID        uuid.UUID              `json:"id"`
        UserID    uuid.UUID              `json:"user_id"`
        Name      string                 `json:"name"`
        Type      string                 `json:"type"`
        APIKey    string                 `json:"api_key,omitempty"` // Masked in production
        Status    string                 `json:"status"`
        Info      map[string]interface{} `json:"info"`
        CreatedAt string                 `json:"created_at"`
        UpdatedAt string                 `json:"updated_at"`
}

// CreateExchangeRequest represents exchange creation request
type CreateExchangeRequest struct {
        Name      string `json:"name" binding:"required,min=1,max=100"`
        Type      string `json:"type" binding:"required,oneof=binance okx bybit"`
        APIKey    string `json:"api_key" binding:"required,min=1"`
        APISecret string `json:"api_secret" binding:"required,min=1"`
}

// UpdateExchangeRequest represents exchange update request
type UpdateExchangeRequest struct {
        Name      *string `json:"name,omitempty" binding:"omitempty,min=1,max=100"`
        APIKey    *string `json:"api_key,omitempty" binding:"omitempty,min=1"`
        APISecret *string `json:"api_secret,omitempty" binding:"omitempty,min=1"`
        Status    *string `json:"status,omitempty" binding:"omitempty,oneof=active inactive"`
}

// CreateExchange creates a new exchange configuration
func (s *ExchangeService) CreateExchange(ctx context.Context, userID uuid.UUID, req *CreateExchangeRequest) (*ExchangeResponse, error) <span class="cov4" title="3">{
        // Check if user has reached the maximum number of exchanges
        existingExchanges, err := s.repos.Exchange.GetByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing exchanges: %w", err)
        }</span>

        // Limit to 10 exchanges per user for now
        <span class="cov4" title="3">if len(existingExchanges) &gt;= 10 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("maximum number of exchanges reached (10)")
        }</span>

        // Check if exchange name is unique for this user
        <span class="cov3" title="2">for _, exchange := range existingExchanges </span><span class="cov1" title="1">{
                if exchange.Name == req.Name </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("exchange name already exists")
                }</span>
        }

        // Create info JSON with metadata
        <span class="cov1" title="1">infoData := map[string]interface{}{
                "created_by":  "api",
                "api_version": "v1",
        }

        infoJSON, err := json.Marshal(infoData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encode info: %w", err)
        }</span>

        // Create exchange model
        <span class="cov1" title="1">exchange := &amp;models.Exchange{
                ID:        uuid.New(),
                UserID:    userID,
                Name:      req.Name,
                Type:      req.Type,
                APIKey:    req.APIKey,
                APISecret: req.APISecret,
                Status:    "active", // Default to active
                Info:      datatypes.JSON(infoJSON),
        }

        // Save to database
        if err := s.repos.Exchange.Create(ctx, exchange); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create exchange: %w", err)
        }</span>

        <span class="cov1" title="1">return s.convertToExchangeResponse(exchange), nil</span>
}

// GetUserExchanges retrieves all exchanges for a user
func (s *ExchangeService) GetUserExchanges(ctx context.Context, userID uuid.UUID) ([]*ExchangeResponse, error) <span class="cov1" title="1">{
        exchanges, err := s.repos.Exchange.GetByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user exchanges: %w", err)
        }</span>

        <span class="cov1" title="1">var responses []*ExchangeResponse
        for _, exchange := range exchanges </span><span class="cov3" title="2">{
                responses = append(responses, s.convertToExchangeResponse(exchange))
        }</span>

        <span class="cov1" title="1">return responses, nil</span>
}

// GetExchange retrieves a specific exchange by ID (must belong to user)
func (s *ExchangeService) GetExchange(ctx context.Context, userID, exchangeID uuid.UUID) (*ExchangeResponse, error) <span class="cov4" title="3">{
        exchange, err := s.repos.Exchange.GetByID(ctx, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get exchange: %w", err)
        }</span>
        <span class="cov4" title="3">if exchange == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        // Check if exchange belongs to the user
        <span class="cov3" title="2">if exchange.UserID != userID </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        <span class="cov1" title="1">return s.convertToExchangeResponse(exchange), nil</span>
}

// UpdateExchange updates an existing exchange
func (s *ExchangeService) UpdateExchange(ctx context.Context, userID, exchangeID uuid.UUID, req *UpdateExchangeRequest) (*ExchangeResponse, error) <span class="cov3" title="2">{
        // Get existing exchange
        exchange, err := s.repos.Exchange.GetByID(ctx, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get exchange: %w", err)
        }</span>
        <span class="cov3" title="2">if exchange == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        // Check if exchange belongs to the user
        <span class="cov3" title="2">if exchange.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        // Update fields if provided
        <span class="cov3" title="2">if req.Name != nil </span><span class="cov3" title="2">{
                // Check if new name is unique for this user
                userExchanges, err := s.repos.Exchange.GetByUserID(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to check exchange names: %w", err)
                }</span>

                <span class="cov3" title="2">for _, userExchange := range userExchanges </span><span class="cov4" title="3">{
                        if userExchange.ID != exchangeID &amp;&amp; userExchange.Name == *req.Name </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("exchange name already exists")
                        }</span>
                }

                <span class="cov1" title="1">exchange.Name = *req.Name</span>
        }

        <span class="cov1" title="1">if req.APIKey != nil </span><span class="cov1" title="1">{
                exchange.APIKey = *req.APIKey
        }</span>

        <span class="cov1" title="1">if req.APISecret != nil </span><span class="cov0" title="0">{
                exchange.APISecret = *req.APISecret
        }</span>

        <span class="cov1" title="1">if req.Status != nil </span><span class="cov1" title="1">{
                exchange.Status = *req.Status
        }</span>

        // Save updated exchange
        <span class="cov1" title="1">if err := s.repos.Exchange.Update(ctx, exchange); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update exchange: %w", err)
        }</span>

        <span class="cov1" title="1">return s.convertToExchangeResponse(exchange), nil</span>
}

// DeleteExchange deletes an exchange (soft delete)
func (s *ExchangeService) DeleteExchange(ctx context.Context, userID, exchangeID uuid.UUID) error <span class="cov3" title="2">{
        // Get existing exchange to verify ownership
        exchange, err := s.repos.Exchange.GetByID(ctx, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get exchange: %w", err)
        }</span>
        <span class="cov3" title="2">if exchange == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("exchange not found")
        }</span>

        // Check if exchange belongs to the user
        <span class="cov3" title="2">if exchange.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("exchange not found")
        }</span>

        // Check if exchange has sub-accounts
        <span class="cov3" title="2">subAccounts, err := s.repos.SubAccount.GetByExchangeID(ctx, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check sub-accounts: %w", err)
        }</span>

        <span class="cov3" title="2">if len(subAccounts) &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("cannot delete exchange with existing sub-accounts")
        }</span>

        // Soft delete the exchange
        <span class="cov1" title="1">if err := s.repos.Exchange.Delete(ctx, exchangeID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete exchange: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ListExchanges lists all exchanges with pagination (admin only)
// For now, returns all exchanges without pagination since we don't have List method
func (s *ExchangeService) ListExchanges(ctx context.Context, limit, offset int) ([]*ExchangeResponse, int64, error) <span class="cov0" title="0">{
        // This would need a List method in the repository
        // For now, we'll return an error indicating this is not implemented
        return nil, 0, fmt.Errorf("list exchanges not implemented yet")
}</span>

// GetExchangeByID retrieves exchange by ID (admin only)
func (s *ExchangeService) GetExchangeByID(ctx context.Context, exchangeID uuid.UUID) (*ExchangeResponse, error) <span class="cov1" title="1">{
        exchange, err := s.repos.Exchange.GetByID(ctx, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get exchange: %w", err)
        }</span>
        <span class="cov1" title="1">if exchange == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        <span class="cov1" title="1">return s.convertToExchangeResponse(exchange), nil</span>
}

// convertToExchangeResponse converts an exchange model to response format
func (s *ExchangeService) convertToExchangeResponse(exchange *models.Exchange) *ExchangeResponse <span class="cov8" title="8">{
        var info map[string]interface{}
        if err := json.Unmarshal(exchange.Info, &amp;info); err != nil </span><span class="cov1" title="1">{
                info = make(map[string]interface{})
        }</span>

        // Mask API key for security (show only first 4 and last 4 characters)
        <span class="cov8" title="8">maskedAPIKey := exchange.APIKey
        if len(maskedAPIKey) &gt; 8 </span><span class="cov7" title="7">{
                maskedAPIKey = maskedAPIKey[:4] + "****" + maskedAPIKey[len(maskedAPIKey)-4:]
        }</span>

        <span class="cov8" title="8">return &amp;ExchangeResponse{
                ID:        exchange.ID,
                UserID:    exchange.UserID,
                Name:      exchange.Name,
                Type:      exchange.Type,
                APIKey:    maskedAPIKey,
                Status:    exchange.Status,
                Info:      info,
                CreatedAt: exchange.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt: exchange.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"

        "tiris-backend/internal/models"
        "tiris-backend/internal/repositories"

        "github.com/google/uuid"
        "gorm.io/datatypes"
)

// SubAccountService handles sub-account business logic
type SubAccountService struct {
        repos *repositories.Repositories
}

// NewSubAccountService creates a new sub-account service
func NewSubAccountService(repos *repositories.Repositories) *SubAccountService <span class="cov10" title="14">{
        return &amp;SubAccountService{
                repos: repos,
        }
}</span>

// SubAccountResponse represents sub-account information in responses
type SubAccountResponse struct {
        ID         uuid.UUID              `json:"id"`
        UserID     uuid.UUID              `json:"user_id"`
        ExchangeID uuid.UUID              `json:"exchange_id"`
        Name       string                 `json:"name"`
        Symbol     string                 `json:"symbol"`
        Balance    float64                `json:"balance"`
        Info       map[string]interface{} `json:"info"`
        CreatedAt  string                 `json:"created_at"`
        UpdatedAt  string                 `json:"updated_at"`
}

// CreateSubAccountRequest represents sub-account creation request
type CreateSubAccountRequest struct {
        ExchangeID uuid.UUID `json:"exchange_id" binding:"required"`
        Name       string    `json:"name" binding:"required,min=1,max=100"`
        Symbol     string    `json:"symbol" binding:"required,min=1,max=20"`
}

// UpdateSubAccountRequest represents sub-account update request
type UpdateSubAccountRequest struct {
        Name    *string  `json:"name,omitempty" binding:"omitempty,min=1,max=100"`
        Symbol  *string  `json:"symbol,omitempty" binding:"omitempty,min=1,max=20"`
        Balance *float64 `json:"balance,omitempty" binding:"omitempty,min=0"`
}

// UpdateBalanceRequest represents balance update request
type UpdateBalanceRequest struct {
        Amount    float64                `json:"amount" binding:"required"`
        Direction string                 `json:"direction" binding:"required,oneof=credit debit"`
        Reason    string                 `json:"reason" binding:"required,min=1,max=255"`
        Info      map[string]interface{} `json:"info,omitempty"`
}

// CreateSubAccount creates a new sub-account
func (s *SubAccountService) CreateSubAccount(ctx context.Context, userID uuid.UUID, req *CreateSubAccountRequest) (*SubAccountResponse, error) <span class="cov5" title="4">{
        // Verify user owns the exchange
        exchange, err := s.repos.Exchange.GetByID(ctx, req.ExchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to verify exchange: %w", err)
        }</span>
        <span class="cov5" title="4">if exchange == nil || exchange.UserID != userID </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        // Check if sub-account name is unique for this user+exchange combination
        <span class="cov3" title="2">existingSubAccounts, err := s.repos.SubAccount.GetByUserID(ctx, userID, &amp;req.ExchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing sub-accounts: %w", err)
        }</span>

        <span class="cov3" title="2">for _, subAccount := range existingSubAccounts </span><span class="cov1" title="1">{
                if subAccount.Name == req.Name </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("sub-account name already exists for this exchange")
                }</span>
        }

        // Create info JSON with metadata
        <span class="cov1" title="1">infoData := map[string]interface{}{
                "created_by":    "api",
                "api_version":   "v1",
                "exchange_type": exchange.Type,
        }

        infoJSON, err := json.Marshal(infoData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encode info: %w", err)
        }</span>

        // Create sub-account model
        <span class="cov1" title="1">subAccount := &amp;models.SubAccount{
                ID:         uuid.New(),
                UserID:     userID,
                ExchangeID: req.ExchangeID,
                Name:       req.Name,
                Symbol:     req.Symbol,
                Balance:    0.0, // Start with zero balance
                Info:       datatypes.JSON(infoJSON),
        }

        // Save to database
        if err := s.repos.SubAccount.Create(ctx, subAccount); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sub-account: %w", err)
        }</span>

        <span class="cov1" title="1">return s.convertToSubAccountResponse(subAccount), nil</span>
}

// GetUserSubAccounts retrieves all sub-accounts for a user
func (s *SubAccountService) GetUserSubAccounts(ctx context.Context, userID uuid.UUID, exchangeID *uuid.UUID) ([]*SubAccountResponse, error) <span class="cov3" title="2">{
        // If exchangeID is provided, verify user owns it
        if exchangeID != nil </span><span class="cov1" title="1">{
                exchange, err := s.repos.Exchange.GetByID(ctx, *exchangeID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to verify exchange: %w", err)
                }</span>
                <span class="cov1" title="1">if exchange == nil || exchange.UserID != userID </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("exchange not found")
                }</span>
        }

        <span class="cov3" title="2">subAccounts, err := s.repos.SubAccount.GetByUserID(ctx, userID, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user sub-accounts: %w", err)
        }</span>

        <span class="cov3" title="2">var responses []*SubAccountResponse
        for _, subAccount := range subAccounts </span><span class="cov4" title="3">{
                responses = append(responses, s.convertToSubAccountResponse(subAccount))
        }</span>

        <span class="cov3" title="2">return responses, nil</span>
}

// GetSubAccount retrieves a specific sub-account by ID (must belong to user)
func (s *SubAccountService) GetSubAccount(ctx context.Context, userID, subAccountID uuid.UUID) (*SubAccountResponse, error) <span class="cov4" title="3">{
        subAccount, err := s.repos.SubAccount.GetByID(ctx, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sub-account: %w", err)
        }</span>
        <span class="cov4" title="3">if subAccount == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        // Check if sub-account belongs to the user
        <span class="cov3" title="2">if subAccount.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        <span class="cov3" title="2">return s.convertToSubAccountResponse(subAccount), nil</span>
}

// UpdateSubAccount updates an existing sub-account
func (s *SubAccountService) UpdateSubAccount(ctx context.Context, userID, subAccountID uuid.UUID, req *UpdateSubAccountRequest) (*SubAccountResponse, error) <span class="cov1" title="1">{
        // Get existing sub-account
        subAccount, err := s.repos.SubAccount.GetByID(ctx, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sub-account: %w", err)
        }</span>
        <span class="cov1" title="1">if subAccount == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        // Check if sub-account belongs to the user
        <span class="cov1" title="1">if subAccount.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        // Update fields if provided
        <span class="cov1" title="1">if req.Name != nil </span><span class="cov1" title="1">{
                // Check if new name is unique for this user+exchange
                userSubAccounts, err := s.repos.SubAccount.GetByUserID(ctx, userID, &amp;subAccount.ExchangeID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to check sub-account names: %w", err)
                }</span>

                <span class="cov1" title="1">for _, userSubAccount := range userSubAccounts </span><span class="cov1" title="1">{
                        if userSubAccount.ID != subAccountID &amp;&amp; userSubAccount.Name == *req.Name </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("sub-account name already exists for this exchange")
                        }</span>
                }

                <span class="cov1" title="1">subAccount.Name = *req.Name</span>
        }

        <span class="cov1" title="1">if req.Symbol != nil </span><span class="cov1" title="1">{
                subAccount.Symbol = *req.Symbol
        }</span>

        // Note: Direct balance updates should use UpdateBalance method for proper logging
        <span class="cov1" title="1">if req.Balance != nil </span><span class="cov1" title="1">{
                subAccount.Balance = *req.Balance
        }</span>

        // Save updated sub-account
        <span class="cov1" title="1">if err := s.repos.SubAccount.Update(ctx, subAccount); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update sub-account: %w", err)
        }</span>

        <span class="cov1" title="1">return s.convertToSubAccountResponse(subAccount), nil</span>
}

// UpdateBalance updates sub-account balance with proper logging
func (s *SubAccountService) UpdateBalance(ctx context.Context, userID, subAccountID uuid.UUID, req *UpdateBalanceRequest) (*SubAccountResponse, error) <span class="cov3" title="2">{
        // Verify sub-account belongs to user
        subAccount, err := s.repos.SubAccount.GetByID(ctx, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sub-account: %w", err)
        }</span>
        <span class="cov3" title="2">if subAccount == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        <span class="cov3" title="2">if subAccount.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        // Calculate new balance
        <span class="cov3" title="2">var newBalance float64
        switch req.Direction </span>{
        case "credit":<span class="cov1" title="1">
                newBalance = subAccount.Balance + req.Amount</span>
        case "debit":<span class="cov1" title="1">
                newBalance = subAccount.Balance - req.Amount
                if newBalance &lt; 0 </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("insufficient balance")
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid direction")</span>
        }

        // Use repository method for atomic balance update with logging
        <span class="cov1" title="1">_, err = s.repos.SubAccount.UpdateBalance(ctx, subAccountID, newBalance, req.Amount, req.Direction, req.Reason, req.Info)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update balance: %w", err)
        }</span>

        // Return updated sub-account
        <span class="cov1" title="1">return s.GetSubAccount(ctx, userID, subAccountID)</span>
}

// DeleteSubAccount deletes a sub-account (soft delete)
func (s *SubAccountService) DeleteSubAccount(ctx context.Context, userID, subAccountID uuid.UUID) error <span class="cov3" title="2">{
        // Get existing sub-account to verify ownership
        subAccount, err := s.repos.SubAccount.GetByID(ctx, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get sub-account: %w", err)
        }</span>
        <span class="cov3" title="2">if subAccount == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("sub-account not found")
        }</span>

        // Check if sub-account belongs to the user
        <span class="cov3" title="2">if subAccount.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("sub-account not found")
        }</span>

        // Check if sub-account has balance
        <span class="cov3" title="2">if subAccount.Balance &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("cannot delete sub-account with positive balance")
        }</span>

        // Soft delete the sub-account
        <span class="cov1" title="1">if err := s.repos.SubAccount.Delete(ctx, subAccountID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete sub-account: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// GetSubAccountsBySymbol retrieves sub-accounts by symbol
func (s *SubAccountService) GetSubAccountsBySymbol(ctx context.Context, userID uuid.UUID, symbol string) ([]*SubAccountResponse, error) <span class="cov1" title="1">{
        subAccounts, err := s.repos.SubAccount.GetBySymbol(ctx, userID, symbol)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sub-accounts by symbol: %w", err)
        }</span>

        <span class="cov1" title="1">var responses []*SubAccountResponse
        for _, subAccount := range subAccounts </span><span class="cov3" title="2">{
                responses = append(responses, s.convertToSubAccountResponse(subAccount))
        }</span>

        <span class="cov1" title="1">return responses, nil</span>
}

// convertToSubAccountResponse converts a sub-account model to response format
func (s *SubAccountService) convertToSubAccountResponse(subAccount *models.SubAccount) *SubAccountResponse <span class="cov8" title="9">{
        var info map[string]interface{}
        if err := json.Unmarshal(subAccount.Info, &amp;info); err != nil </span><span class="cov3" title="2">{
                info = make(map[string]interface{})
        }</span>

        <span class="cov8" title="9">return &amp;SubAccountResponse{
                ID:         subAccount.ID,
                UserID:     subAccount.UserID,
                ExchangeID: subAccount.ExchangeID,
                Name:       subAccount.Name,
                Symbol:     subAccount.Symbol,
                Balance:    subAccount.Balance,
                Info:       info,
                CreatedAt:  subAccount.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt:  subAccount.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "tiris-backend/internal/models"
        "tiris-backend/internal/repositories"

        "github.com/google/uuid"
        "gorm.io/datatypes"
)

// TradingLogService handles trading log business logic
type TradingLogService struct {
        repos *repositories.Repositories
}

// NewTradingLogService creates a new trading log service
func NewTradingLogService(repos *repositories.Repositories) *TradingLogService <span class="cov10" title="17">{
        return &amp;TradingLogService{
                repos: repos,
        }
}</span>

// TradingLogResponse represents trading log information in responses
type TradingLogResponse struct {
        ID            uuid.UUID              `json:"id"`
        UserID        uuid.UUID              `json:"user_id"`
        ExchangeID    uuid.UUID              `json:"exchange_id"`
        SubAccountID  *uuid.UUID             `json:"sub_account_id,omitempty"`
        TransactionID *uuid.UUID             `json:"transaction_id,omitempty"`
        Timestamp     string                 `json:"timestamp"`
        Type          string                 `json:"type"`
        Source        string                 `json:"source"`
        Message       string                 `json:"message"`
        Info          map[string]interface{} `json:"info"`
}

// CreateTradingLogRequest represents trading log creation request
type CreateTradingLogRequest struct {
        ExchangeID    uuid.UUID              `json:"exchange_id" binding:"required"`
        SubAccountID  *uuid.UUID             `json:"sub_account_id,omitempty"`
        TransactionID *uuid.UUID             `json:"transaction_id,omitempty"`
        Type          string                 `json:"type" binding:"required,min=1,max=50"`
        Source        string                 `json:"source" binding:"required,oneof=manual bot"`
        Message       string                 `json:"message" binding:"required,min=1"`
        Info          map[string]interface{} `json:"info,omitempty"`
}

// TradingLogQueryRequest represents trading log query parameters
type TradingLogQueryRequest struct {
        Type      *string    `form:"type"`
        Source    *string    `form:"source" binding:"omitempty,oneof=manual bot"`
        StartDate *time.Time `form:"start_date" time_format:"2006-01-02T15:04:05Z07:00"`
        EndDate   *time.Time `form:"end_date" time_format:"2006-01-02T15:04:05Z07:00"`
        Limit     int        `form:"limit" binding:"omitempty,min=1,max=1000"`
        Offset    int        `form:"offset" binding:"omitempty,min=0"`
}

// TradingLogQueryResponse represents paginated trading log results
type TradingLogQueryResponse struct {
        TradingLogs []*TradingLogResponse `json:"trading_logs"`
        Total       int64                 `json:"total"`
        Limit       int                   `json:"limit"`
        Offset      int                   `json:"offset"`
        HasMore     bool                  `json:"has_more"`
}

// CreateTradingLog creates a new trading log entry
func (s *TradingLogService) CreateTradingLog(ctx context.Context, userID uuid.UUID, req *CreateTradingLogRequest) (*TradingLogResponse, error) <span class="cov5" title="4">{
        // Verify user owns the exchange
        exchange, err := s.repos.Exchange.GetByID(ctx, req.ExchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to verify exchange: %w", err)
        }</span>
        <span class="cov5" title="4">if exchange == nil || exchange.UserID != userID </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        // Verify sub-account ownership if provided
        <span class="cov3" title="2">if req.SubAccountID != nil </span><span class="cov1" title="1">{
                subAccount, err := s.repos.SubAccount.GetByID(ctx, *req.SubAccountID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to verify sub-account: %w", err)
                }</span>
                <span class="cov1" title="1">if subAccount == nil || subAccount.UserID != userID </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("sub-account not found")
                }</span>
        }

        // Verify transaction ownership if provided
        <span class="cov3" title="2">if req.TransactionID != nil </span><span class="cov1" title="1">{
                transaction, err := s.repos.Transaction.GetByID(ctx, *req.TransactionID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to verify transaction: %w", err)
                }</span>
                <span class="cov1" title="1">if transaction == nil || transaction.UserID != userID </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("transaction not found")
                }</span>
        }

        // Create info JSON with metadata
        <span class="cov3" title="2">infoData := req.Info
        if infoData == nil </span><span class="cov1" title="1">{
                infoData = make(map[string]interface{})
        }</span>
        // Add metadata
        <span class="cov3" title="2">infoData["created_by"] = "api"
        infoData["api_version"] = "v1"
        infoData["exchange_type"] = exchange.Type

        infoJSON, err := json.Marshal(infoData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encode info: %w", err)
        }</span>

        // Create trading log model
        <span class="cov3" title="2">tradingLog := &amp;models.TradingLog{
                ID:            uuid.New(),
                UserID:        userID,
                ExchangeID:    req.ExchangeID,
                SubAccountID:  req.SubAccountID,
                TransactionID: req.TransactionID,
                Timestamp:     time.Now().UTC(),
                Type:          req.Type,
                Source:        req.Source,
                Message:       req.Message,
                Info:          datatypes.JSON(infoJSON),
        }

        // Save to database
        if err := s.repos.TradingLog.Create(ctx, tradingLog); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create trading log: %w", err)
        }</span>

        <span class="cov3" title="2">return s.convertToTradingLogResponse(tradingLog), nil</span>
}

// GetUserTradingLogs retrieves trading logs for a user with filtering
func (s *TradingLogService) GetUserTradingLogs(ctx context.Context, userID uuid.UUID, req *TradingLogQueryRequest) (*TradingLogQueryResponse, error) <span class="cov5" title="4">{
        // Set default pagination
        if req.Limit == 0 </span><span class="cov3" title="2">{
                req.Limit = 100
        }</span>

        // Validate date range
        <span class="cov5" title="4">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>

        // Create filters
        <span class="cov4" title="3">filters := repositories.TradingLogFilters{
                Type:      req.Type,
                Source:    req.Source,
                StartDate: req.StartDate,
                EndDate:   req.EndDate,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query trading logs
        tradingLogs, total, err := s.repos.TradingLog.GetByUserID(ctx, userID, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user trading logs: %w", err)
        }</span>

        // Convert to response format
        <span class="cov4" title="3">var responses []*TradingLogResponse
        for _, tradingLog := range tradingLogs </span><span class="cov4" title="3">{
                responses = append(responses, s.convertToTradingLogResponse(tradingLog))
        }</span>

        <span class="cov4" title="3">return &amp;TradingLogQueryResponse{
                TradingLogs: responses,
                Total:       total,
                Limit:       req.Limit,
                Offset:      req.Offset,
                HasMore:     int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetSubAccountTradingLogs retrieves trading logs for a specific sub-account
func (s *TradingLogService) GetSubAccountTradingLogs(ctx context.Context, userID, subAccountID uuid.UUID, req *TradingLogQueryRequest) (*TradingLogQueryResponse, error) <span class="cov1" title="1">{
        // Verify user owns the sub-account
        subAccount, err := s.repos.SubAccount.GetByID(ctx, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to verify sub-account: %w", err)
        }</span>
        <span class="cov1" title="1">if subAccount == nil || subAccount.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        // Set default pagination
        <span class="cov1" title="1">if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate date range
        <span class="cov1" title="1">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>

        // Create filters
        <span class="cov1" title="1">filters := repositories.TradingLogFilters{
                Type:      req.Type,
                Source:    req.Source,
                StartDate: req.StartDate,
                EndDate:   req.EndDate,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query trading logs
        tradingLogs, total, err := s.repos.TradingLog.GetBySubAccountID(ctx, subAccountID, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sub-account trading logs: %w", err)
        }</span>

        // Convert to response format
        <span class="cov1" title="1">var responses []*TradingLogResponse
        for _, tradingLog := range tradingLogs </span><span class="cov1" title="1">{
                responses = append(responses, s.convertToTradingLogResponse(tradingLog))
        }</span>

        <span class="cov1" title="1">return &amp;TradingLogQueryResponse{
                TradingLogs: responses,
                Total:       total,
                Limit:       req.Limit,
                Offset:      req.Offset,
                HasMore:     int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetExchangeTradingLogs retrieves trading logs for a specific exchange
func (s *TradingLogService) GetExchangeTradingLogs(ctx context.Context, userID, exchangeID uuid.UUID, req *TradingLogQueryRequest) (*TradingLogQueryResponse, error) <span class="cov1" title="1">{
        // Verify user owns the exchange
        exchange, err := s.repos.Exchange.GetByID(ctx, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to verify exchange: %w", err)
        }</span>
        <span class="cov1" title="1">if exchange == nil || exchange.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        // Set default pagination
        <span class="cov1" title="1">if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate date range
        <span class="cov1" title="1">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>

        // Create filters
        <span class="cov1" title="1">filters := repositories.TradingLogFilters{
                Type:      req.Type,
                Source:    req.Source,
                StartDate: req.StartDate,
                EndDate:   req.EndDate,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query trading logs
        tradingLogs, total, err := s.repos.TradingLog.GetByExchangeID(ctx, exchangeID, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get exchange trading logs: %w", err)
        }</span>

        // Convert to response format
        <span class="cov1" title="1">var responses []*TradingLogResponse
        for _, tradingLog := range tradingLogs </span><span class="cov1" title="1">{
                responses = append(responses, s.convertToTradingLogResponse(tradingLog))
        }</span>

        <span class="cov1" title="1">return &amp;TradingLogQueryResponse{
                TradingLogs: responses,
                Total:       total,
                Limit:       req.Limit,
                Offset:      req.Offset,
                HasMore:     int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetTradingLog retrieves a specific trading log by ID
func (s *TradingLogService) GetTradingLog(ctx context.Context, userID, tradingLogID uuid.UUID) (*TradingLogResponse, error) <span class="cov3" title="2">{
        tradingLog, err := s.repos.TradingLog.GetByID(ctx, tradingLogID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trading log: %w", err)
        }</span>
        <span class="cov3" title="2">if tradingLog == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("trading log not found")
        }</span>

        // Check if trading log belongs to the user
        <span class="cov1" title="1">if tradingLog.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("trading log not found")
        }</span>

        <span class="cov1" title="1">return s.convertToTradingLogResponse(tradingLog), nil</span>
}

// GetTradingLogsByTimeRange retrieves trading logs within a specific time range
func (s *TradingLogService) GetTradingLogsByTimeRange(ctx context.Context, userID uuid.UUID, startTime, endTime time.Time, req *TradingLogQueryRequest) (*TradingLogQueryResponse, error) <span class="cov1" title="1">{
        // Validate time range
        if startTime.After(endTime) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("start time cannot be after end time")
        }</span>

        // Set default pagination
        <span class="cov1" title="1">if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Create filters (override date filters with provided time range)
        <span class="cov1" title="1">filters := repositories.TradingLogFilters{
                Type:      req.Type,
                Source:    req.Source,
                StartDate: &amp;startTime,
                EndDate:   &amp;endTime,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query trading logs by time range
        tradingLogs, _, err := s.repos.TradingLog.GetByTimeRange(ctx, startTime, endTime, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trading logs by time range: %w", err)
        }</span>

        // Filter to only include user's trading logs
        <span class="cov1" title="1">var userTradingLogs []*models.TradingLog
        for _, tradingLog := range tradingLogs </span><span class="cov3" title="2">{
                if tradingLog.UserID == userID </span><span class="cov1" title="1">{
                        userTradingLogs = append(userTradingLogs, tradingLog)
                }</span>
        }

        // Convert to response format
        <span class="cov1" title="1">var responses []*TradingLogResponse
        for _, tradingLog := range userTradingLogs </span><span class="cov1" title="1">{
                responses = append(responses, s.convertToTradingLogResponse(tradingLog))
        }</span>

        // Recalculate total for user's trading logs only
        <span class="cov1" title="1">userTotal := int64(len(userTradingLogs))

        return &amp;TradingLogQueryResponse{
                TradingLogs: responses,
                Total:       userTotal,
                Limit:       req.Limit,
                Offset:      req.Offset,
                HasMore:     int64(req.Offset+req.Limit) &lt; userTotal,
        }, nil</span>
}

// DeleteTradingLog deletes a trading log (soft delete)
func (s *TradingLogService) DeleteTradingLog(ctx context.Context, userID, tradingLogID uuid.UUID) error <span class="cov3" title="2">{
        // Get existing trading log to verify ownership
        tradingLog, err := s.repos.TradingLog.GetByID(ctx, tradingLogID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get trading log: %w", err)
        }</span>
        <span class="cov3" title="2">if tradingLog == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("trading log not found")
        }</span>

        // Check if trading log belongs to the user
        <span class="cov3" title="2">if tradingLog.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("trading log not found")
        }</span>

        // Only allow deletion of manual logs
        <span class="cov3" title="2">if tradingLog.Source != "manual" </span><span class="cov1" title="1">{
                return fmt.Errorf("cannot delete bot-generated trading logs")
        }</span>

        // Delete the trading log
        <span class="cov1" title="1">if err := s.repos.TradingLog.Delete(ctx, tradingLogID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete trading log: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ListAllTradingLogs lists all trading logs with pagination (admin only)
func (s *TradingLogService) ListAllTradingLogs(ctx context.Context, req *TradingLogQueryRequest) (*TradingLogQueryResponse, error) <span class="cov1" title="1">{
        // Set default pagination
        if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate date range
        <span class="cov1" title="1">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>

        // For admin queries, we'll use a time range approach to get all trading logs
        // Use a very broad time range if no specific dates provided
        <span class="cov1" title="1">startTime := time.Date(2020, 1, 1, 0, 0, 0, 0, time.UTC)
        endTime := time.Now().UTC()

        if req.StartDate != nil </span><span class="cov0" title="0">{
                startTime = *req.StartDate
        }</span>
        <span class="cov1" title="1">if req.EndDate != nil </span><span class="cov0" title="0">{
                endTime = *req.EndDate
        }</span>

        // Create filters
        <span class="cov1" title="1">filters := repositories.TradingLogFilters{
                Type:      req.Type,
                Source:    req.Source,
                StartDate: &amp;startTime,
                EndDate:   &amp;endTime,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query all trading logs in time range
        tradingLogs, total, err := s.repos.TradingLog.GetByTimeRange(ctx, startTime, endTime, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list all trading logs: %w", err)
        }</span>

        // Convert to response format
        <span class="cov1" title="1">var responses []*TradingLogResponse
        for _, tradingLog := range tradingLogs </span><span class="cov3" title="2">{
                responses = append(responses, s.convertToTradingLogResponse(tradingLog))
        }</span>

        <span class="cov1" title="1">return &amp;TradingLogQueryResponse{
                TradingLogs: responses,
                Total:       total,
                Limit:       req.Limit,
                Offset:      req.Offset,
                HasMore:     int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetTradingLogByID retrieves trading log by ID (admin only)
func (s *TradingLogService) GetTradingLogByID(ctx context.Context, tradingLogID uuid.UUID) (*TradingLogResponse, error) <span class="cov1" title="1">{
        tradingLog, err := s.repos.TradingLog.GetByID(ctx, tradingLogID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trading log: %w", err)
        }</span>
        <span class="cov1" title="1">if tradingLog == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("trading log not found")
        }</span>

        <span class="cov1" title="1">return s.convertToTradingLogResponse(tradingLog), nil</span>
}

// convertToTradingLogResponse converts a trading log model to response format
func (s *TradingLogService) convertToTradingLogResponse(tradingLog *models.TradingLog) *TradingLogResponse <span class="cov8" title="12">{
        var info map[string]interface{}
        if err := json.Unmarshal(tradingLog.Info, &amp;info); err != nil </span><span class="cov0" title="0">{
                info = make(map[string]interface{})
        }</span>

        <span class="cov8" title="12">return &amp;TradingLogResponse{
                ID:            tradingLog.ID,
                UserID:        tradingLog.UserID,
                ExchangeID:    tradingLog.ExchangeID,
                SubAccountID:  tradingLog.SubAccountID,
                TransactionID: tradingLog.TransactionID,
                Timestamp:     tradingLog.Timestamp.Format("2006-01-02T15:04:05Z07:00"),
                Type:          tradingLog.Type,
                Source:        tradingLog.Source,
                Message:       tradingLog.Message,
                Info:          info,
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "tiris-backend/internal/models"
        "tiris-backend/internal/repositories"

        "github.com/google/uuid"
)

// TransactionService handles transaction query business logic
type TransactionService struct {
        repos *repositories.Repositories
}

// NewTransactionService creates a new transaction service
func NewTransactionService(repos *repositories.Repositories) *TransactionService <span class="cov10" title="15">{
        return &amp;TransactionService{
                repos: repos,
        }
}</span>

// TransactionResponse represents transaction information in responses
type TransactionResponse struct {
        ID             uuid.UUID              `json:"id"`
        UserID         uuid.UUID              `json:"user_id"`
        ExchangeID     uuid.UUID              `json:"exchange_id"`
        SubAccountID   uuid.UUID              `json:"sub_account_id"`
        Timestamp      string                 `json:"timestamp"`
        Direction      string                 `json:"direction"`
        Reason         string                 `json:"reason"`
        Amount         float64                `json:"amount"`
        ClosingBalance float64                `json:"closing_balance"`
        Price          *float64               `json:"price,omitempty"`
        QuoteSymbol    *string                `json:"quote_symbol,omitempty"`
        Info           map[string]interface{} `json:"info"`
}

// TransactionQueryRequest represents transaction query parameters
type TransactionQueryRequest struct {
        Direction *string    `form:"direction" binding:"omitempty,oneof=debit credit"`
        Reason    *string    `form:"reason"`
        StartDate *time.Time `form:"start_date" time_format:"2006-01-02T15:04:05Z07:00"`
        EndDate   *time.Time `form:"end_date" time_format:"2006-01-02T15:04:05Z07:00"`
        MinAmount *float64   `form:"min_amount" binding:"omitempty,min=0"`
        MaxAmount *float64   `form:"max_amount" binding:"omitempty,min=0"`
        Limit     int        `form:"limit" binding:"omitempty,min=1,max=1000"`
        Offset    int        `form:"offset" binding:"omitempty,min=0"`
}

// TransactionQueryResponse represents paginated transaction results
type TransactionQueryResponse struct {
        Transactions []*TransactionResponse `json:"transactions"`
        Total        int64                  `json:"total"`
        Limit        int                    `json:"limit"`
        Offset       int                    `json:"offset"`
        HasMore      bool                   `json:"has_more"`
}

// GetUserTransactions retrieves transactions for a user with filtering
func (s *TransactionService) GetUserTransactions(ctx context.Context, userID uuid.UUID, req *TransactionQueryRequest) (*TransactionQueryResponse, error) <span class="cov6" title="5">{
        // Set default pagination
        if req.Limit == 0 </span><span class="cov4" title="3">{
                req.Limit = 100
        }</span>

        // Validate date range
        <span class="cov6" title="5">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>

        // Validate amount range
        <span class="cov5" title="4">if req.MinAmount != nil &amp;&amp; req.MaxAmount != nil &amp;&amp; *req.MinAmount &gt; *req.MaxAmount </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("min amount cannot be greater than max amount")
        }</span>

        // Create filters
        <span class="cov4" title="3">filters := repositories.TransactionFilters{
                Direction: req.Direction,
                Reason:    req.Reason,
                StartDate: req.StartDate,
                EndDate:   req.EndDate,
                MinAmount: req.MinAmount,
                MaxAmount: req.MaxAmount,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query transactions
        transactions, total, err := s.repos.Transaction.GetByUserID(ctx, userID, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user transactions: %w", err)
        }</span>

        // Convert to response format
        <span class="cov4" title="3">var responses []*TransactionResponse
        for _, transaction := range transactions </span><span class="cov4" title="3">{
                responses = append(responses, s.convertToTransactionResponse(transaction))
        }</span>

        <span class="cov4" title="3">return &amp;TransactionQueryResponse{
                Transactions: responses,
                Total:        total,
                Limit:        req.Limit,
                Offset:       req.Offset,
                HasMore:      int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetSubAccountTransactions retrieves transactions for a specific sub-account
func (s *TransactionService) GetSubAccountTransactions(ctx context.Context, userID, subAccountID uuid.UUID, req *TransactionQueryRequest) (*TransactionQueryResponse, error) <span class="cov3" title="2">{
        // Verify user owns the sub-account
        subAccount, err := s.repos.SubAccount.GetByID(ctx, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to verify sub-account: %w", err)
        }</span>
        <span class="cov3" title="2">if subAccount == nil || subAccount.UserID != userID </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        // Set default pagination
        <span class="cov1" title="1">if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate filters (same as GetUserTransactions)
        <span class="cov1" title="1">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>
        <span class="cov1" title="1">if req.MinAmount != nil &amp;&amp; req.MaxAmount != nil &amp;&amp; *req.MinAmount &gt; *req.MaxAmount </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("min amount cannot be greater than max amount")
        }</span>

        // Create filters
        <span class="cov1" title="1">filters := repositories.TransactionFilters{
                Direction: req.Direction,
                Reason:    req.Reason,
                StartDate: req.StartDate,
                EndDate:   req.EndDate,
                MinAmount: req.MinAmount,
                MaxAmount: req.MaxAmount,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query transactions
        transactions, total, err := s.repos.Transaction.GetBySubAccountID(ctx, subAccountID, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sub-account transactions: %w", err)
        }</span>

        // Convert to response format
        <span class="cov1" title="1">var responses []*TransactionResponse
        for _, transaction := range transactions </span><span class="cov1" title="1">{
                responses = append(responses, s.convertToTransactionResponse(transaction))
        }</span>

        <span class="cov1" title="1">return &amp;TransactionQueryResponse{
                Transactions: responses,
                Total:        total,
                Limit:        req.Limit,
                Offset:       req.Offset,
                HasMore:      int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetExchangeTransactions retrieves transactions for a specific exchange
func (s *TransactionService) GetExchangeTransactions(ctx context.Context, userID, exchangeID uuid.UUID, req *TransactionQueryRequest) (*TransactionQueryResponse, error) <span class="cov1" title="1">{
        // Verify user owns the exchange
        exchange, err := s.repos.Exchange.GetByID(ctx, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to verify exchange: %w", err)
        }</span>
        <span class="cov1" title="1">if exchange == nil || exchange.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        // Set default pagination
        <span class="cov1" title="1">if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate filters (same as GetUserTransactions)
        <span class="cov1" title="1">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>
        <span class="cov1" title="1">if req.MinAmount != nil &amp;&amp; req.MaxAmount != nil &amp;&amp; *req.MinAmount &gt; *req.MaxAmount </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("min amount cannot be greater than max amount")
        }</span>

        // Create filters
        <span class="cov1" title="1">filters := repositories.TransactionFilters{
                Direction: req.Direction,
                Reason:    req.Reason,
                StartDate: req.StartDate,
                EndDate:   req.EndDate,
                MinAmount: req.MinAmount,
                MaxAmount: req.MaxAmount,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query transactions
        transactions, total, err := s.repos.Transaction.GetByExchangeID(ctx, exchangeID, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get exchange transactions: %w", err)
        }</span>

        // Convert to response format
        <span class="cov1" title="1">var responses []*TransactionResponse
        for _, transaction := range transactions </span><span class="cov1" title="1">{
                responses = append(responses, s.convertToTransactionResponse(transaction))
        }</span>

        <span class="cov1" title="1">return &amp;TransactionQueryResponse{
                Transactions: responses,
                Total:        total,
                Limit:        req.Limit,
                Offset:       req.Offset,
                HasMore:      int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetTransaction retrieves a specific transaction by ID
func (s *TransactionService) GetTransaction(ctx context.Context, userID, transactionID uuid.UUID) (*TransactionResponse, error) <span class="cov4" title="3">{
        transaction, err := s.repos.Transaction.GetByID(ctx, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get transaction: %w", err)
        }</span>
        <span class="cov4" title="3">if transaction == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("transaction not found")
        }</span>

        // Check if transaction belongs to the user
        <span class="cov3" title="2">if transaction.UserID != userID </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("transaction not found")
        }</span>

        <span class="cov1" title="1">return s.convertToTransactionResponse(transaction), nil</span>
}

// GetTransactionsByTimeRange retrieves transactions within a specific time range
func (s *TransactionService) GetTransactionsByTimeRange(ctx context.Context, userID uuid.UUID, startTime, endTime time.Time, req *TransactionQueryRequest) (*TransactionQueryResponse, error) <span class="cov3" title="2">{
        // Validate time range
        if startTime.After(endTime) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("start time cannot be after end time")
        }</span>

        // Set default pagination
        <span class="cov1" title="1">if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate amount range
        <span class="cov1" title="1">if req.MinAmount != nil &amp;&amp; req.MaxAmount != nil &amp;&amp; *req.MinAmount &gt; *req.MaxAmount </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("min amount cannot be greater than max amount")
        }</span>

        // Create filters (override date filters with provided time range)
        <span class="cov1" title="1">filters := repositories.TransactionFilters{
                Direction: req.Direction,
                Reason:    req.Reason,
                StartDate: &amp;startTime,
                EndDate:   &amp;endTime,
                MinAmount: req.MinAmount,
                MaxAmount: req.MaxAmount,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query transactions by time range
        transactions, _, err := s.repos.Transaction.GetByTimeRange(ctx, startTime, endTime, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get transactions by time range: %w", err)
        }</span>

        // Filter to only include user's transactions
        <span class="cov1" title="1">var userTransactions []*models.Transaction
        for _, transaction := range transactions </span><span class="cov3" title="2">{
                if transaction.UserID == userID </span><span class="cov1" title="1">{
                        userTransactions = append(userTransactions, transaction)
                }</span>
        }

        // Convert to response format
        <span class="cov1" title="1">var responses []*TransactionResponse
        for _, transaction := range userTransactions </span><span class="cov1" title="1">{
                responses = append(responses, s.convertToTransactionResponse(transaction))
        }</span>

        // Recalculate total for user's transactions only
        <span class="cov1" title="1">userTotal := int64(len(userTransactions))

        return &amp;TransactionQueryResponse{
                Transactions: responses,
                Total:        userTotal,
                Limit:        req.Limit,
                Offset:       req.Offset,
                HasMore:      int64(req.Offset+req.Limit) &lt; userTotal,
        }, nil</span>
}

// ListAllTransactions lists all transactions with pagination (admin only)
func (s *TransactionService) ListAllTransactions(ctx context.Context, req *TransactionQueryRequest) (*TransactionQueryResponse, error) <span class="cov1" title="1">{
        // Set default pagination
        if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate filters
        <span class="cov1" title="1">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>
        <span class="cov1" title="1">if req.MinAmount != nil &amp;&amp; req.MaxAmount != nil &amp;&amp; *req.MinAmount &gt; *req.MaxAmount </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("min amount cannot be greater than max amount")
        }</span>

        // For admin queries, we'll use a time range approach to get all transactions
        // Use a very broad time range if no specific dates provided
        <span class="cov1" title="1">startTime := time.Date(2020, 1, 1, 0, 0, 0, 0, time.UTC)
        endTime := time.Now().UTC()

        if req.StartDate != nil </span><span class="cov0" title="0">{
                startTime = *req.StartDate
        }</span>
        <span class="cov1" title="1">if req.EndDate != nil </span><span class="cov0" title="0">{
                endTime = *req.EndDate
        }</span>

        // Create filters
        <span class="cov1" title="1">filters := repositories.TransactionFilters{
                Direction: req.Direction,
                Reason:    req.Reason,
                StartDate: &amp;startTime,
                EndDate:   &amp;endTime,
                MinAmount: req.MinAmount,
                MaxAmount: req.MaxAmount,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query all transactions in time range
        transactions, total, err := s.repos.Transaction.GetByTimeRange(ctx, startTime, endTime, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list all transactions: %w", err)
        }</span>

        // Convert to response format
        <span class="cov1" title="1">var responses []*TransactionResponse
        for _, transaction := range transactions </span><span class="cov3" title="2">{
                responses = append(responses, s.convertToTransactionResponse(transaction))
        }</span>

        <span class="cov1" title="1">return &amp;TransactionQueryResponse{
                Transactions: responses,
                Total:        total,
                Limit:        req.Limit,
                Offset:       req.Offset,
                HasMore:      int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetTransactionByID retrieves transaction by ID (admin only)
func (s *TransactionService) GetTransactionByID(ctx context.Context, transactionID uuid.UUID) (*TransactionResponse, error) <span class="cov1" title="1">{
        transaction, err := s.repos.Transaction.GetByID(ctx, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get transaction: %w", err)
        }</span>
        <span class="cov1" title="1">if transaction == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("transaction not found")
        }</span>

        <span class="cov1" title="1">return s.convertToTransactionResponse(transaction), nil</span>
}

// convertToTransactionResponse converts a transaction model to response format
func (s *TransactionService) convertToTransactionResponse(transaction *models.Transaction) *TransactionResponse <span class="cov8" title="10">{
        var info map[string]interface{}
        if err := json.Unmarshal(transaction.Info, &amp;info); err != nil </span><span class="cov0" title="0">{
                info = make(map[string]interface{})
        }</span>

        <span class="cov8" title="10">return &amp;TransactionResponse{
                ID:             transaction.ID,
                UserID:         transaction.UserID,
                ExchangeID:     transaction.ExchangeID,
                SubAccountID:   transaction.SubAccountID,
                Timestamp:      transaction.Timestamp.Format("2006-01-02T15:04:05Z07:00"),
                Direction:      transaction.Direction,
                Reason:         transaction.Reason,
                Amount:         transaction.Amount,
                ClosingBalance: transaction.ClosingBalance,
                Price:          transaction.Price,
                QuoteSymbol:    transaction.QuoteSymbol,
                Info:           info,
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"

        "tiris-backend/internal/models"
        "tiris-backend/internal/repositories"

        "github.com/google/uuid"
        "gorm.io/datatypes"
)

// UserService handles user business logic
type UserService struct {
        repos *repositories.Repositories
}

// NewUserService creates a new user service
func NewUserService(repos *repositories.Repositories) *UserService <span class="cov10" title="10">{
        return &amp;UserService{
                repos: repos,
        }
}</span>

// UserResponse represents user information in responses
type UserResponse struct {
        ID        uuid.UUID              `json:"id"`
        Username  string                 `json:"username"`
        Email     string                 `json:"email"`
        Avatar    *string                `json:"avatar,omitempty"`
        Settings  map[string]interface{} `json:"settings"`
        Info      map[string]interface{} `json:"info"`
        CreatedAt string                 `json:"created_at"`
        UpdatedAt string                 `json:"updated_at"`
}

// UpdateUserRequest represents user update request
type UpdateUserRequest struct {
        Username *string                `json:"username,omitempty" binding:"omitempty,min=3,max=50"`
        Avatar   *string                `json:"avatar,omitempty" binding:"omitempty,url"`
        Settings map[string]interface{} `json:"settings,omitempty"`
}

// GetCurrentUser retrieves current user profile
func (s *UserService) GetCurrentUser(ctx context.Context, userID uuid.UUID) (*UserResponse, error) <span class="cov3" title="2">{
        user, err := s.repos.User.GetByID(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found")
        }</span>

        <span class="cov1" title="1">return s.convertToUserResponse(user), nil</span>
}

// UpdateCurrentUser updates current user profile
func (s *UserService) UpdateCurrentUser(ctx context.Context, userID uuid.UUID, req *UpdateUserRequest) (*UserResponse, error) <span class="cov5" title="3">{
        // Get existing user
        user, err := s.repos.User.GetByID(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>
        <span class="cov3" title="2">if user == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found")
        }</span>

        // Update fields if provided
        <span class="cov3" title="2">if req.Username != nil </span><span class="cov3" title="2">{
                // Check if username is already taken
                existingUser, err := s.repos.User.GetByUsername(ctx, *req.Username)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to check username availability: %w", err)
                }</span>
                <span class="cov3" title="2">if existingUser != nil &amp;&amp; existingUser.ID != userID </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("username already taken")
                }</span>
                <span class="cov1" title="1">user.Username = *req.Username</span>
        }

        <span class="cov1" title="1">if req.Avatar != nil </span><span class="cov1" title="1">{
                user.Avatar = req.Avatar
        }</span>

        <span class="cov1" title="1">if req.Settings != nil </span><span class="cov1" title="1">{
                // Merge with existing settings
                var existingSettings map[string]interface{}
                if err := json.Unmarshal(user.Settings, &amp;existingSettings); err != nil </span><span class="cov0" title="0">{
                        existingSettings = make(map[string]interface{})
                }</span>

                // Merge new settings
                <span class="cov1" title="1">for key, value := range req.Settings </span><span class="cov3" title="2">{
                        existingSettings[key] = value
                }</span>

                <span class="cov1" title="1">settingsJSON, err := json.Marshal(existingSettings)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to encode settings: %w", err)
                }</span>
                <span class="cov1" title="1">user.Settings = datatypes.JSON(settingsJSON)</span>
        }

        // Save updated user
        <span class="cov1" title="1">if err := s.repos.User.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov1" title="1">return s.convertToUserResponse(user), nil</span>
}

// DisableUser disables a user account (admin only)
func (s *UserService) DisableUser(ctx context.Context, userID uuid.UUID) error <span class="cov3" title="2">{
        user, err := s.repos.User.GetByID(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get user: %w", err)
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user not found")
        }</span>

        // Use soft delete to disable the user
        <span class="cov1" title="1">if err := s.repos.User.Delete(ctx, userID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to disable user: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ListUsers lists all users (admin only) with pagination
func (s *UserService) ListUsers(ctx context.Context, limit, offset int) ([]*UserResponse, int64, error) <span class="cov1" title="1">{
        users, total, err := s.repos.User.List(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to list users: %w", err)
        }</span>

        <span class="cov1" title="1">var responses []*UserResponse
        for _, user := range users </span><span class="cov3" title="2">{
                responses = append(responses, s.convertToUserResponse(user))
        }</span>

        <span class="cov1" title="1">return responses, total, nil</span>
}

// GetUserByID retrieves user by ID (admin only)
func (s *UserService) GetUserByID(ctx context.Context, userID uuid.UUID) (*UserResponse, error) <span class="cov1" title="1">{
        user, err := s.repos.User.GetByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found")
        }</span>

        <span class="cov1" title="1">return s.convertToUserResponse(user), nil</span>
}

// GetUserStats retrieves user statistics
func (s *UserService) GetUserStats(ctx context.Context, userID uuid.UUID) (map[string]interface{}, error) <span class="cov1" title="1">{
        // Get user's exchanges count
        exchanges, err := s.repos.Exchange.GetByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user exchanges: %w", err)
        }</span>

        // Get user's sub-accounts count
        <span class="cov1" title="1">subAccounts, err := s.repos.SubAccount.GetByUserID(ctx, userID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user sub-accounts: %w", err)
        }</span>

        // Calculate total balance across all sub-accounts
        <span class="cov1" title="1">var totalBalance float64
        for _, subAccount := range subAccounts </span><span class="cov5" title="3">{
                totalBalance += subAccount.Balance
        }</span>

        // Get recent transaction count (last 30 days)
        // For simplicity, we'll skip complex date filtering here
        // In a real implementation, you'd add a method to get transaction count by date range

        <span class="cov1" title="1">stats := map[string]interface{}{
                "exchanges_count":    len(exchanges),
                "sub_accounts_count": len(subAccounts),
                "total_balance":      totalBalance,
                "active_exchanges":   len(exchanges), // Assuming all are active for now
        }

        return stats, nil</span>
}

// convertToUserResponse converts a user model to response format
func (s *UserService) convertToUserResponse(user *models.User) *UserResponse <span class="cov7" title="5">{
        var settings map[string]interface{}
        if err := json.Unmarshal(user.Settings, &amp;settings); err != nil </span><span class="cov0" title="0">{
                settings = make(map[string]interface{})
        }</span>

        <span class="cov7" title="5">var info map[string]interface{}
        if err := json.Unmarshal(user.Info, &amp;info); err != nil </span><span class="cov0" title="0">{
                info = make(map[string]interface{})
        }</span>

        <span class="cov7" title="5">return &amp;UserResponse{
                ID:        user.ID,
                Username:  user.Username,
                Email:     user.Email,
                Avatar:    user.Avatar,
                Settings:  settings,
                Info:      info,
                CreatedAt: user.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt: user.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
