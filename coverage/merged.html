
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">tiris-backend/internal/api/auth_handler.go (4.3%)</option>
				
				<option value="file1">tiris-backend/internal/api/exchange_handler.go (0.0%)</option>
				
				<option value="file2">tiris-backend/internal/api/health_handler.go (68.8%)</option>
				
				<option value="file3">tiris-backend/internal/api/router.go (0.0%)</option>
				
				<option value="file4">tiris-backend/internal/api/subaccount_handler.go (0.0%)</option>
				
				<option value="file5">tiris-backend/internal/api/trading_log_handler.go (0.0%)</option>
				
				<option value="file6">tiris-backend/internal/api/transaction_handler.go (0.0%)</option>
				
				<option value="file7">tiris-backend/internal/api/types.go (0.0%)</option>
				
				<option value="file8">tiris-backend/internal/api/user_handler.go (0.0%)</option>
				
				<option value="file9">tiris-backend/internal/database/database.go (0.0%)</option>
				
				<option value="file10">tiris-backend/internal/database/migrate.go (0.0%)</option>
				
				<option value="file11">tiris-backend/internal/middleware/auth.go (0.0%)</option>
				
				<option value="file12">tiris-backend/internal/middleware/logging.go (0.0%)</option>
				
				<option value="file13">tiris-backend/internal/middleware/rate_limit.go (0.0%)</option>
				
				<option value="file14">tiris-backend/internal/nats/client.go (0.0%)</option>
				
				<option value="file15">tiris-backend/internal/nats/consumer_helpers.go (0.0%)</option>
				
				<option value="file16">tiris-backend/internal/nats/consumers.go (0.0%)</option>
				
				<option value="file17">tiris-backend/internal/nats/events.go (0.0%)</option>
				
				<option value="file18">tiris-backend/internal/nats/manager.go (0.0%)</option>
				
				<option value="file19">tiris-backend/internal/repositories/event_processing_repository.go (0.0%)</option>
				
				<option value="file20">tiris-backend/internal/repositories/exchange_repository.go (0.0%)</option>
				
				<option value="file21">tiris-backend/internal/repositories/oauth_token_repository.go (0.0%)</option>
				
				<option value="file22">tiris-backend/internal/repositories/repository.go (0.0%)</option>
				
				<option value="file23">tiris-backend/internal/repositories/sub_account_repository.go (0.0%)</option>
				
				<option value="file24">tiris-backend/internal/repositories/trading_log_repository.go (0.0%)</option>
				
				<option value="file25">tiris-backend/internal/repositories/transaction_repository.go (0.0%)</option>
				
				<option value="file26">tiris-backend/internal/repositories/user_repository.go (0.0%)</option>
				
				<option value="file27">tiris-backend/internal/services/auth_service.go (76.6%)</option>
				
				<option value="file28">tiris-backend/internal/services/exchange_service.go (77.6%)</option>
				
				<option value="file29">tiris-backend/internal/services/subaccount_service.go (76.0%)</option>
				
				<option value="file30">tiris-backend/internal/services/trading_log_service.go (75.4%)</option>
				
				<option value="file31">tiris-backend/internal/services/transaction_service.go (77.3%)</option>
				
				<option value="file32">tiris-backend/internal/services/user_service.go (79.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "net/http"
        "time"

        "tiris-backend/internal/middleware"
        "tiris-backend/internal/services"

        "github.com/gin-gonic/gin"
)

// AuthHandler handles authentication endpoints
type AuthHandler struct {
        authService *services.AuthService
}

// NewAuthHandler creates a new authentication handler
func NewAuthHandler(authService *services.AuthService) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                authService: authService,
        }
}</span>

// Login initiates OAuth login flow
// @Summary Initiate OAuth login
// @Description Initiates OAuth login flow and returns authorization URL
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body services.LoginRequest true "Login request"
// @Success 200 {object} services.LoginResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/login [post]
func (h *AuthHandler) Login(c *gin.Context) <span class="cov0" title="0">{
        var req services.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "INVALID_REQUEST",
                                Message: "Invalid request format",
                                Details: err.Error(),
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">response, err := h.authService.InitiateLogin(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "LOGIN_FAILED",
                                Message: "Failed to initiate login",
                                Details: err.Error(),
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        // Store state in session/cookie for validation (in production, use secure session storage)
        <span class="cov0" title="0">c.SetCookie("oauth_state", response.State, 600, "/", "", false, true) // 10 minutes

        c.JSON(http.StatusOK, SuccessResponse{
                Success: true,
                Data:    response,
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   getTraceID(c),
                },
        })</span>
}

// Callback handles OAuth callback
// @Summary Handle OAuth callback
// @Description Handles OAuth callback and returns JWT tokens
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body services.CallbackRequest true "Callback request"
// @Success 200 {object} services.AuthResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/callback [post]
func (h *AuthHandler) Callback(c *gin.Context) <span class="cov0" title="0">{
        var req services.CallbackRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "INVALID_REQUEST",
                                Message: "Invalid request format",
                                Details: err.Error(),
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        // Get expected state from cookie
        <span class="cov0" title="0">expectedState, err := c.Cookie("oauth_state")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "INVALID_STATE",
                                Message: "Missing or invalid state parameter",
                                Details: "OAuth state not found in session",
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        // Clear the state cookie
        <span class="cov0" title="0">c.SetCookie("oauth_state", "", -1, "/", "", false, true)

        response, err := h.authService.HandleCallback(c.Request.Context(), &amp;req, expectedState)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "OAUTH_CALLBACK_FAILED",
                                Message: "OAuth callback failed",
                                Details: err.Error(),
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, SuccessResponse{
                Success: true,
                Data:    response,
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   getTraceID(c),
                },
        })</span>
}

// Refresh refreshes access token using refresh token
// @Summary Refresh access token
// @Description Refreshes access token using refresh token
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body services.RefreshRequest true "Refresh request"
// @Success 200 {object} services.AuthResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/refresh [post]
func (h *AuthHandler) Refresh(c *gin.Context) <span class="cov0" title="0">{
        var req services.RefreshRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "INVALID_REQUEST",
                                Message: "Invalid request format",
                                Details: err.Error(),
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">response, err := h.authService.RefreshToken(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "TOKEN_REFRESH_FAILED",
                                Message: "Failed to refresh token",
                                Details: err.Error(),
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, SuccessResponse{
                Success: true,
                Data:    response,
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   getTraceID(c),
                },
        })</span>
}

// Logout logs out the current user
// @Summary Logout user
// @Description Logs out the current user and invalidates session
// @Tags Authentication
// @Produce json
// @Security BearerAuth
// @Success 200 {object} SuccessResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/logout [post]
func (h *AuthHandler) Logout(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "AUTH_REQUIRED",
                                Message: "Authentication required",
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">err := h.authService.Logout(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "LOGOUT_FAILED",
                                Message: "Failed to logout",
                                Details: err.Error(),
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, SuccessResponse{
                Success: true,
                Data: gin.H{
                        "message": "Logged out successfully",
                },
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   getTraceID(c),
                },
        })</span>
}

// getTraceID extracts trace ID from context
func getTraceID(c *gin.Context) string <span class="cov10" title="4">{
        if traceID, exists := c.Get("request_id"); exists </span><span class="cov0" title="0">{
                if id, ok := traceID.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
        }
        <span class="cov10" title="4">return ""</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "net/http"
        "strconv"

        "tiris-backend/internal/middleware"
        "tiris-backend/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// ExchangeHandler handles exchange management endpoints
type ExchangeHandler struct {
        exchangeService *services.ExchangeService
}

// NewExchangeHandler creates a new exchange handler
func NewExchangeHandler(exchangeService *services.ExchangeService) *ExchangeHandler <span class="cov0" title="0">{
        return &amp;ExchangeHandler{
                exchangeService: exchangeService,
        }
}</span>

// CreateExchange creates a new exchange configuration
// @Summary Create new exchange
// @Description Creates a new exchange configuration for the authenticated user
// @Tags Exchanges
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body services.CreateExchangeRequest true "Create exchange request"
// @Success 201 {object} services.ExchangeResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /exchanges [post]
func (h *ExchangeHandler) CreateExchange(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.CreateExchangeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_REQUEST",
                        "Invalid request format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchange, err := h.exchangeService.CreateExchange(c.Request.Context(), userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange name already exists" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "EXCHANGE_NAME_EXISTS",
                                "Exchange name already exists",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "maximum number of exchanges reached (10)" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "EXCHANGE_LIMIT_REACHED",
                                "Maximum number of exchanges reached",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "EXCHANGE_CREATE_FAILED",
                        "Failed to create exchange",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, CreateSuccessResponse(exchange, getTraceID(c)))</span>
}

// GetUserExchanges retrieves all exchanges for the current user
// @Summary Get user exchanges
// @Description Retrieves all exchange configurations for the authenticated user
// @Tags Exchanges
// @Produce json
// @Security BearerAuth
// @Success 200 {array} services.ExchangeResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /exchanges [get]
func (h *ExchangeHandler) GetUserExchanges(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchanges, err := h.exchangeService.GetUserExchanges(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "EXCHANGES_GET_FAILED",
                        "Failed to get exchanges",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "exchanges": exchanges,
        }

        c.JSON(http.StatusOK, CreateSuccessResponse(response, getTraceID(c)))</span>
}

// GetExchange retrieves a specific exchange by ID
// @Summary Get exchange by ID
// @Description Retrieves a specific exchange configuration by ID (must belong to authenticated user)
// @Tags Exchanges
// @Produce json
// @Security BearerAuth
// @Param id path string true "Exchange ID"
// @Success 200 {object} services.ExchangeResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /exchanges/{id} [get]
func (h *ExchangeHandler) GetExchange(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchangeIDStr := c.Param("id")
        exchangeID, err := uuid.Parse(exchangeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_EXCHANGE_ID",
                        "Invalid exchange ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchange, err := h.exchangeService.GetExchange(c.Request.Context(), userID, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "EXCHANGE_GET_FAILED",
                        "Failed to get exchange",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(exchange, getTraceID(c)))</span>
}

// UpdateExchange updates an existing exchange
// @Summary Update exchange
// @Description Updates an existing exchange configuration (must belong to authenticated user)
// @Tags Exchanges
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Exchange ID"
// @Param request body services.UpdateExchangeRequest true "Update exchange request"
// @Success 200 {object} services.ExchangeResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /exchanges/{id} [put]
func (h *ExchangeHandler) UpdateExchange(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchangeIDStr := c.Param("id")
        exchangeID, err := uuid.Parse(exchangeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_EXCHANGE_ID",
                        "Invalid exchange ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.UpdateExchangeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_REQUEST",
                        "Invalid request format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchange, err := h.exchangeService.UpdateExchange(c.Request.Context(), userID, exchangeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "exchange name already exists" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "EXCHANGE_NAME_EXISTS",
                                "Exchange name already exists",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "EXCHANGE_UPDATE_FAILED",
                        "Failed to update exchange",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(exchange, getTraceID(c)))</span>
}

// DeleteExchange deletes an exchange
// @Summary Delete exchange
// @Description Deletes an exchange configuration (must belong to authenticated user)
// @Tags Exchanges
// @Produce json
// @Security BearerAuth
// @Param id path string true "Exchange ID"
// @Success 200 {object} SuccessResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /exchanges/{id} [delete]
func (h *ExchangeHandler) DeleteExchange(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchangeIDStr := c.Param("id")
        exchangeID, err := uuid.Parse(exchangeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_EXCHANGE_ID",
                        "Invalid exchange ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">err = h.exchangeService.DeleteExchange(c.Request.Context(), userID, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "cannot delete exchange with existing sub-accounts" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "EXCHANGE_HAS_SUBACCOUNTS",
                                "Cannot delete exchange with existing sub-accounts",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "EXCHANGE_DELETE_FAILED",
                        "Failed to delete exchange",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "message": "Exchange deleted successfully",
        }

        c.JSON(http.StatusOK, CreateSuccessResponse(response, getTraceID(c)))</span>
}

// ListExchanges lists all exchanges (admin only)
// @Summary List all exchanges
// @Description Lists all exchange configurations with pagination (admin only)
// @Tags Exchanges
// @Produce json
// @Security BearerAuth
// @Param limit query int false "Number of exchanges to return" default(100)
// @Param offset query int false "Number of exchanges to skip" default(0)
// @Success 200 {object} PaginatedResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /admin/exchanges [get]
func (h *ExchangeHandler) ListExchanges(c *gin.Context) <span class="cov0" title="0">{
        // Parse pagination parameters
        limit := 100
        if l := c.Query("limit"); l != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(l); err == nil &amp;&amp; parsed &gt; 0 &amp;&amp; parsed &lt;= 1000 </span><span class="cov0" title="0">{
                        limit = parsed
                }</span>
        }

        <span class="cov0" title="0">offset := 0
        if o := c.Query("offset"); o != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(o); err == nil &amp;&amp; parsed &gt;= 0 </span><span class="cov0" title="0">{
                        offset = parsed
                }</span>
        }

        <span class="cov0" title="0">exchanges, total, err := h.exchangeService.ListExchanges(c.Request.Context(), limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "EXCHANGES_LIST_FAILED",
                        "Failed to list exchanges",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        // Create pagination metadata
        <span class="cov0" title="0">hasMore := int64(offset+limit) &lt; total
        var nextOffset *int
        if hasMore </span><span class="cov0" title="0">{
                next := offset + limit
                nextOffset = &amp;next
        }</span>

        <span class="cov0" title="0">pagination := &amp;PaginationMetadata{
                Total:      total,
                Limit:      limit,
                Offset:     offset,
                HasMore:    hasMore,
                NextOffset: nextOffset,
        }

        response := map[string]interface{}{
                "exchanges": exchanges,
        }

        c.JSON(http.StatusOK, CreatePaginatedResponse(response, pagination, getTraceID(c)))</span>
}

// GetExchangeByID retrieves exchange by ID (admin only)
// @Summary Get exchange by ID
// @Description Retrieves an exchange by ID (admin only)
// @Tags Exchanges
// @Produce json
// @Security BearerAuth
// @Param id path string true "Exchange ID"
// @Success 200 {object} services.ExchangeResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /admin/exchanges/{id} [get]
func (h *ExchangeHandler) GetExchangeByID(c *gin.Context) <span class="cov0" title="0">{
        exchangeIDStr := c.Param("id")
        exchangeID, err := uuid.Parse(exchangeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_EXCHANGE_ID",
                        "Invalid exchange ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchange, err := h.exchangeService.GetExchangeByID(c.Request.Context(), exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "EXCHANGE_GET_FAILED",
                        "Failed to get exchange",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(exchange, getTraceID(c)))</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "context"
        "net/http"
        "time"

        "tiris-backend/internal/database"
        "tiris-backend/internal/nats"

        "github.com/gin-gonic/gin"
)

// HealthHandler handles health check endpoints
type HealthHandler struct {
        db          *database.DB
        natsManager *nats.Manager
}

// NewHealthHandler creates a new health handler
func NewHealthHandler(db *database.DB, natsManager *nats.Manager) *HealthHandler <span class="cov10" title="6">{
        return &amp;HealthHandler{
                db:          db,
                natsManager: natsManager,
        }
}</span>

// HealthStatus represents the health status of a component
type HealthStatus struct {
        Status  string                 `json:"status"`
        Message string                 `json:"message,omitempty"`
        Details map[string]interface{} `json:"details,omitempty"`
}

// HealthResponse represents the overall health response
type HealthResponse struct {
        Status       string                  `json:"status"`
        Timestamp    string                  `json:"timestamp"`
        Version      string                  `json:"version"`
        Dependencies map[string]HealthStatus `json:"dependencies"`
}

// LivenessProbe handles Kubernetes liveness probe
// @Summary Liveness probe
// @Description Kubernetes liveness probe - checks if the application is running
// @Tags Health
// @Produce json
// @Success 200 {object} SuccessResponse
// @Router /health/live [get]
func (h *HealthHandler) LivenessProbe(c *gin.Context) <span class="cov1" title="1">{
        response := SuccessResponse{
                Success: true,
                Data: gin.H{
                        "status":    "healthy",
                        "timestamp": time.Now().UTC().Format(time.RFC3339),
                        "message":   "Service is alive",
                },
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   getTraceID(c),
                },
        }

        c.JSON(http.StatusOK, response)
}</span>

// ReadinessProbe handles Kubernetes readiness probe
// @Summary Readiness probe
// @Description Kubernetes readiness probe - checks if the application is ready to serve traffic
// @Tags Health
// @Produce json
// @Success 200 {object} HealthResponse
// @Failure 503 {object} ErrorResponse
// @Router /health/ready [get]
func (h *HealthHandler) ReadinessProbe(c *gin.Context) <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(c.Request.Context(), 5*time.Second)
        defer cancel()

        dependencies := make(map[string]HealthStatus)
        overallHealthy := true

        // Check database connectivity
        dbStatus := h.checkDatabase(ctx)
        dependencies["database"] = dbStatus
        if dbStatus.Status != "healthy" </span><span class="cov1" title="1">{
                overallHealthy = false
        }</span>

        // Check NATS connectivity
        <span class="cov1" title="1">natsStatus := h.checkNATS(ctx)
        dependencies["nats"] = natsStatus
        if natsStatus.Status != "healthy" </span><span class="cov1" title="1">{
                overallHealthy = false
        }</span>

        // Determine overall status
        <span class="cov1" title="1">status := "healthy"
        httpStatus := http.StatusOK
        if !overallHealthy </span><span class="cov1" title="1">{
                status = "unhealthy"
                httpStatus = http.StatusServiceUnavailable
        }</span>

        <span class="cov1" title="1">healthResponse := HealthResponse{
                Status:       status,
                Timestamp:    time.Now().UTC().Format(time.RFC3339),
                Version:      "1.0.0", // This could be injected from build info
                Dependencies: dependencies,
        }

        if overallHealthy </span><span class="cov0" title="0">{
                c.JSON(httpStatus, SuccessResponse{
                        Success: true,
                        Data:    healthResponse,
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
        }</span> else<span class="cov1" title="1"> {
                c.JSON(httpStatus, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "SERVICE_UNAVAILABLE",
                                Message: "One or more dependencies are unhealthy",
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
        }</span>
}

// HealthCheck provides detailed health information
// @Summary Detailed health check
// @Description Provides detailed health information about the service and its dependencies
// @Tags Health
// @Produce json
// @Success 200 {object} HealthResponse
// @Failure 503 {object} ErrorResponse
// @Router /health [get]
func (h *HealthHandler) HealthCheck(c *gin.Context) <span class="cov4" title="2">{
        ctx, cancel := context.WithTimeout(c.Request.Context(), 10*time.Second)
        defer cancel()

        dependencies := make(map[string]HealthStatus)
        overallHealthy := true

        // Check database with detailed info
        dbStatus := h.checkDatabaseDetailed(ctx)
        dependencies["database"] = dbStatus
        if dbStatus.Status != "healthy" </span><span class="cov4" title="2">{
                overallHealthy = false
        }</span>

        // Check NATS with detailed info
        <span class="cov4" title="2">natsStatus := h.checkNATSDetailed(ctx)
        dependencies["nats"] = natsStatus
        if natsStatus.Status != "healthy" </span><span class="cov4" title="2">{
                overallHealthy = false
        }</span>

        // Add system info
        <span class="cov4" title="2">systemStatus := h.getSystemInfo()
        dependencies["system"] = systemStatus

        // Determine overall status
        status := "healthy"
        httpStatus := http.StatusOK
        if !overallHealthy </span><span class="cov4" title="2">{
                status = "degraded"
                httpStatus = http.StatusServiceUnavailable
        }</span>

        <span class="cov4" title="2">healthResponse := HealthResponse{
                Status:       status,
                Timestamp:    time.Now().UTC().Format(time.RFC3339),
                Version:      "1.0.0",
                Dependencies: dependencies,
        }

        if overallHealthy </span><span class="cov0" title="0">{
                c.JSON(httpStatus, SuccessResponse{
                        Success: true,
                        Data:    healthResponse,
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
        }</span> else<span class="cov4" title="2"> {
                c.JSON(httpStatus, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "SERVICE_DEGRADED",
                                Message: "Service is running but some dependencies are unhealthy",
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
        }</span>
}

// checkDatabase performs a basic database connectivity check
func (h *HealthHandler) checkDatabase(ctx context.Context) HealthStatus <span class="cov1" title="1">{
        if h.db == nil </span><span class="cov1" title="1">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "Database not initialized",
                }
        }</span>

        // Simple ping to check connectivity
        <span class="cov0" title="0">sqlDB, err := h.db.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "Failed to get database connection",
                }
        }</span>

        <span class="cov0" title="0">if err := sqlDB.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "Database ping failed: " + err.Error(),
                }
        }</span>

        <span class="cov0" title="0">return HealthStatus{
                Status:  "healthy",
                Message: "Database is accessible",
        }</span>
}

// checkDatabaseDetailed performs a detailed database health check
func (h *HealthHandler) checkDatabaseDetailed(ctx context.Context) HealthStatus <span class="cov4" title="2">{
        if h.db == nil </span><span class="cov4" title="2">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "Database not initialized",
                }
        }</span>

        <span class="cov0" title="0">sqlDB, err := h.db.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "Failed to get database connection",
                }
        }</span>

        // Check connectivity
        <span class="cov0" title="0">if err := sqlDB.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "Database ping failed: " + err.Error(),
                }
        }</span>

        // Get connection pool stats
        <span class="cov0" title="0">stats := sqlDB.Stats()
        details := map[string]interface{}{
                "open_connections":     stats.OpenConnections,
                "in_use":              stats.InUse,
                "idle":                stats.Idle,
                "max_open_connections": stats.MaxOpenConnections,
                "max_idle_closed":     stats.MaxIdleClosed,
                "max_lifetime_closed":  stats.MaxLifetimeClosed,
                "wait_count":          stats.WaitCount,
                "wait_duration":       stats.WaitDuration.String(),
        }

        return HealthStatus{
                Status:  "healthy",
                Message: "Database is accessible with connection pool statistics",
                Details: details,
        }</span>
}

// checkNATS performs a basic NATS connectivity check
func (h *HealthHandler) checkNATS(ctx context.Context) HealthStatus <span class="cov1" title="1">{
        if h.natsManager == nil </span><span class="cov1" title="1">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "NATS manager not initialized",
                }
        }</span>

        <span class="cov0" title="0">if !h.natsManager.IsConnected() </span><span class="cov0" title="0">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "NATS connection is not established",
                }
        }</span>

        <span class="cov0" title="0">return HealthStatus{
                Status:  "healthy",
                Message: "NATS is connected",
        }</span>
}

// checkNATSDetailed performs a detailed NATS health check
func (h *HealthHandler) checkNATSDetailed(ctx context.Context) HealthStatus <span class="cov4" title="2">{
        if h.natsManager == nil </span><span class="cov4" title="2">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "NATS manager not initialized",
                }
        }</span>

        <span class="cov0" title="0">if !h.natsManager.IsConnected() </span><span class="cov0" title="0">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "NATS connection is not established",
                }
        }</span>

        // Get detailed connection info
        <span class="cov0" title="0">details := h.natsManager.GetConnectionStats()
        if details == nil </span><span class="cov0" title="0">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "Unable to retrieve connection statistics",
                }
        }</span>

        <span class="cov0" title="0">return HealthStatus{
                Status:  "healthy",
                Message: "NATS is connected with detailed statistics",
                Details: details,
        }</span>
}

// getSystemInfo provides basic system information
func (h *HealthHandler) getSystemInfo() HealthStatus <span class="cov4" title="2">{
        details := map[string]interface{}{
                "uptime":      time.Since(startTime).String(),
                "start_time":  startTime.Format(time.RFC3339),
                "go_version":  "1.23",  // This could be injected from build info
                "environment": "development", // This should come from config
        }

        return HealthStatus{
                Status:  "healthy",
                Message: "System information",
                Details: details,
        }
}</span>

// startTime tracks when the service started
var startTime = time.Now()</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "time"

        "tiris-backend/internal/config"
        "tiris-backend/internal/database"
        "tiris-backend/internal/metrics"
        "tiris-backend/internal/middleware"
        "tiris-backend/internal/nats"
        "tiris-backend/internal/repositories"
        "tiris-backend/internal/services"
        "tiris-backend/pkg/auth"

        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Server represents the API server
type Server struct {
        router             *gin.Engine
        config             *config.Config
        db                 *database.DB
        natsManager        *nats.Manager
        repos              *repositories.Repositories
        jwtManager         *auth.JWTManager
        authService        *services.AuthService
        userService        *services.UserService
        exchangeService    *services.ExchangeService
        subAccountService  *services.SubAccountService
        transactionService *services.TransactionService
        tradingLogService  *services.TradingLogService
        metrics            *metrics.Metrics
}

// NewServer creates a new API server
func NewServer(cfg *config.Config, repos *repositories.Repositories) *Server <span class="cov0" title="0">{
        // Initialize JWT manager
        jwtManager := auth.NewJWTManager(
                cfg.Auth.JWTSecret,
                cfg.Auth.RefreshSecret,
                time.Duration(cfg.Auth.JWTExpiration)*time.Second,
                time.Duration(cfg.Auth.RefreshExpiration)*time.Second,
        )

        // Initialize OAuth manager
        oauthConfig := auth.OAuthConfig{
                Google: auth.GoogleOAuthConfig{
                        ClientID:     cfg.OAuth.Google.ClientID,
                        ClientSecret: cfg.OAuth.Google.ClientSecret,
                        RedirectURL:  cfg.OAuth.Google.RedirectURL,
                },
                WeChat: auth.WeChatOAuthConfig{
                        AppID:       cfg.OAuth.WeChat.AppID,
                        AppSecret:   cfg.OAuth.WeChat.AppSecret,
                        RedirectURL: cfg.OAuth.WeChat.RedirectURL,
                },
        }
        oauthManager := auth.NewOAuthManager(oauthConfig)

        // Initialize metrics
        metricsInstance := metrics.NewMetrics()

        // Initialize services
        authService := services.NewAuthService(repos, jwtManager, oauthManager)
        userService := services.NewUserService(repos)
        exchangeService := services.NewExchangeService(repos)
        subAccountService := services.NewSubAccountService(repos)
        transactionService := services.NewTransactionService(repos)
        tradingLogService := services.NewTradingLogService(repos)

        return &amp;Server{
                config:             cfg,
                repos:              repos,
                jwtManager:         jwtManager,
                authService:        authService,
                userService:        userService,
                exchangeService:    exchangeService,
                subAccountService:  subAccountService,
                transactionService: transactionService,
                tradingLogService:  tradingLogService,
                metrics:            metricsInstance,
        }
}</span>

// SetupRoutes sets up all API routes
func (s *Server) SetupRoutes() *gin.Engine <span class="cov0" title="0">{
        router := gin.New()

        // Determine CORS origins based on environment
        var allowedOrigins []string
        if s.config.Environment == "production" </span><span class="cov0" title="0">{
                allowedOrigins = []string{"https://tiris.ai"}
        }</span> else<span class="cov0" title="0"> {
                allowedOrigins = []string{"https://dev.tiris.ai", "http://localhost:3000"}
        }</span>

        // Global middleware
        <span class="cov0" title="0">router.Use(middleware.ErrorLoggingMiddleware())
        router.Use(middleware.SecurityHeadersMiddleware())
        router.Use(middleware.CORSMiddleware(allowedOrigins))
        router.Use(middleware.RequestIDMiddleware())
        router.Use(middleware.HealthCheckLoggingMiddleware())
        router.Use(s.metrics.HTTPMetricsMiddleware())

        // Health check endpoints (no authentication required)
        s.setupHealthRoutes(router)

        // Metrics endpoint (no authentication required)
        s.setupMetricsRoutes(router)

        // API routes with rate limiting
        api := router.Group("/v1")
        api.Use(middleware.APIRateLimitMiddleware())

        // Authentication routes
        s.setupAuthRoutes(api)

        // Protected routes (require authentication)
        protected := api.Group("")
        protected.Use(middleware.AuthMiddleware(s.jwtManager))

        // User management routes
        s.setupUserRoutes(protected)

        // Exchange management routes
        s.setupExchangeRoutes(protected)

        // Sub-account management routes
        s.setupSubAccountRoutes(protected)

        // Transaction query routes
        s.setupTransactionRoutes(protected)

        // Trading log management routes
        s.setupTradingLogRoutes(protected)

        s.router = router
        return router</span>
}

// setupHealthRoutes sets up health check routes
func (s *Server) setupHealthRoutes(router *gin.Engine) <span class="cov0" title="0">{
        healthHandler := NewHealthHandler(s.db, s.natsManager)

        // Kubernetes liveness probe - simple check that the app is running
        router.GET("/health/live", healthHandler.LivenessProbe)
        
        // Kubernetes readiness probe - check if app can serve traffic
        router.GET("/health/ready", healthHandler.ReadinessProbe)
        
        // Detailed health check with dependency information
        router.GET("/health", healthHandler.HealthCheck)
}</span>

// setupAuthRoutes sets up authentication routes
func (s *Server) setupAuthRoutes(api *gin.RouterGroup) <span class="cov0" title="0">{
        authHandler := NewAuthHandler(s.authService)

        auth := api.Group("/auth")
        auth.Use(middleware.AuthRateLimitMiddleware()) // Stricter rate limiting for auth

        auth.POST("/login", authHandler.Login)
        auth.POST("/callback", authHandler.Callback)
        auth.POST("/refresh", authHandler.Refresh)
        auth.POST("/logout", middleware.AuthMiddleware(s.jwtManager), authHandler.Logout)
}</span>

// setupUserRoutes sets up user management routes
func (s *Server) setupUserRoutes(protected *gin.RouterGroup) <span class="cov0" title="0">{
        userHandler := NewUserHandler(s.userService)

        users := protected.Group("/users")

        // Current user routes
        users.GET("/me", userHandler.GetCurrentUser)
        users.PUT("/me", userHandler.UpdateCurrentUser)
        users.GET("/me/stats", userHandler.GetUserStats)

        // Admin only routes
        adminUsers := users.Group("")
        adminUsers.Use(middleware.AdminMiddleware())

        adminUsers.GET("", userHandler.ListUsers)
        adminUsers.GET("/:id", userHandler.GetUserByID)
        adminUsers.PUT("/:id/disable", userHandler.DisableUser)
}</span>

// setupExchangeRoutes sets up exchange management routes
func (s *Server) setupExchangeRoutes(protected *gin.RouterGroup) <span class="cov0" title="0">{
        exchangeHandler := NewExchangeHandler(s.exchangeService)

        exchanges := protected.Group("/exchanges")

        // User exchange routes
        exchanges.POST("", exchangeHandler.CreateExchange)
        exchanges.GET("", exchangeHandler.GetUserExchanges)
        exchanges.GET("/:id", exchangeHandler.GetExchange)
        exchanges.PUT("/:id", exchangeHandler.UpdateExchange)
        exchanges.DELETE("/:id", exchangeHandler.DeleteExchange)

        // Admin exchange routes
        adminExchanges := protected.Group("/admin/exchanges")
        adminExchanges.Use(middleware.AdminMiddleware())

        adminExchanges.GET("", exchangeHandler.ListExchanges)
        adminExchanges.GET("/:id", exchangeHandler.GetExchangeByID)
}</span>

// setupSubAccountRoutes sets up sub-account management routes
func (s *Server) setupSubAccountRoutes(protected *gin.RouterGroup) <span class="cov0" title="0">{
        subAccountHandler := NewSubAccountHandler(s.subAccountService)

        subAccounts := protected.Group("/sub-accounts")

        // User sub-account routes
        subAccounts.POST("", subAccountHandler.CreateSubAccount)
        subAccounts.GET("", subAccountHandler.GetUserSubAccounts)
        subAccounts.GET("/:id", subAccountHandler.GetSubAccount)
        subAccounts.PUT("/:id", subAccountHandler.UpdateSubAccount)
        subAccounts.PUT("/:id/balance", subAccountHandler.UpdateBalance)
        subAccounts.DELETE("/:id", subAccountHandler.DeleteSubAccount)

        // Symbol-based queries
        subAccounts.GET("/symbol/:symbol", subAccountHandler.GetSubAccountsBySymbol)
}</span>

// setupTransactionRoutes sets up transaction query routes
func (s *Server) setupTransactionRoutes(protected *gin.RouterGroup) <span class="cov0" title="0">{
        transactionHandler := NewTransactionHandler(s.transactionService)

        transactions := protected.Group("/transactions")

        // User transaction routes
        transactions.GET("", transactionHandler.GetUserTransactions)
        transactions.GET("/:id", transactionHandler.GetTransaction)
        transactions.GET("/sub-account/:sub_account_id", transactionHandler.GetSubAccountTransactions)
        transactions.GET("/exchange/:exchange_id", transactionHandler.GetExchangeTransactions)
        transactions.GET("/time-range", transactionHandler.GetTransactionsByTimeRange)

        // Admin transaction routes
        adminTransactions := protected.Group("/admin/transactions")
        adminTransactions.Use(middleware.AdminMiddleware())

        adminTransactions.GET("", transactionHandler.ListAllTransactions)
        adminTransactions.GET("/:id", transactionHandler.GetTransactionByID)
}</span>

// setupTradingLogRoutes sets up trading log management routes
func (s *Server) setupTradingLogRoutes(protected *gin.RouterGroup) <span class="cov0" title="0">{
        tradingLogHandler := NewTradingLogHandler(s.tradingLogService)

        tradingLogs := protected.Group("/trading-logs")

        // User trading log routes
        tradingLogs.POST("", tradingLogHandler.CreateTradingLog)
        tradingLogs.GET("", tradingLogHandler.GetUserTradingLogs)
        tradingLogs.GET("/:id", tradingLogHandler.GetTradingLog)
        tradingLogs.DELETE("/:id", tradingLogHandler.DeleteTradingLog)
        tradingLogs.GET("/sub-account/:sub_account_id", tradingLogHandler.GetSubAccountTradingLogs)
        tradingLogs.GET("/exchange/:exchange_id", tradingLogHandler.GetExchangeTradingLogs)
        tradingLogs.GET("/time-range", tradingLogHandler.GetTradingLogsByTimeRange)

        // Admin trading log routes
        adminTradingLogs := protected.Group("/admin/trading-logs")
        adminTradingLogs.Use(middleware.AdminMiddleware())

        adminTradingLogs.GET("", tradingLogHandler.ListAllTradingLogs)
        adminTradingLogs.GET("/:id", tradingLogHandler.GetTradingLogByID)
}</span>

// setupMetricsRoutes sets up Prometheus metrics endpoints
func (s *Server) setupMetricsRoutes(router *gin.Engine) <span class="cov0" title="0">{
        router.GET("/metrics", gin.WrapH(promhttp.Handler()))
}</span>

// GetRouter returns the configured router
func (s *Server) GetRouter() *gin.Engine <span class="cov0" title="0">{
        if s.router == nil </span><span class="cov0" title="0">{
                return s.SetupRoutes()
        }</span>
        <span class="cov0" title="0">return s.router</span>
}

// GetMetrics returns the metrics instance
func (s *Server) GetMetrics() *metrics.Metrics <span class="cov0" title="0">{
        return s.metrics
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "net/http"

        "tiris-backend/internal/middleware"
        "tiris-backend/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// SubAccountHandler handles sub-account management endpoints
type SubAccountHandler struct {
        subAccountService *services.SubAccountService
}

// NewSubAccountHandler creates a new sub-account handler
func NewSubAccountHandler(subAccountService *services.SubAccountService) *SubAccountHandler <span class="cov0" title="0">{
        return &amp;SubAccountHandler{
                subAccountService: subAccountService,
        }
}</span>

// CreateSubAccount creates a new sub-account
// @Summary Create new sub-account
// @Description Creates a new sub-account for the authenticated user
// @Tags SubAccounts
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body services.CreateSubAccountRequest true "Create sub-account request"
// @Success 201 {object} services.SubAccountResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /sub-accounts [post]
func (h *SubAccountHandler) CreateSubAccount(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.CreateSubAccountRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_REQUEST",
                        "Invalid request format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccount, err := h.subAccountService.CreateSubAccount(c.Request.Context(), userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "sub-account name already exists for this exchange" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "SUBACCOUNT_NAME_EXISTS",
                                "Sub-account name already exists for this exchange",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "SUBACCOUNT_CREATE_FAILED",
                        "Failed to create sub-account",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, CreateSuccessResponse(subAccount, getTraceID(c)))</span>
}

// GetUserSubAccounts retrieves all sub-accounts for the current user
// @Summary Get user sub-accounts
// @Description Retrieves all sub-account configurations for the authenticated user, optionally filtered by exchange
// @Tags SubAccounts
// @Produce json
// @Security BearerAuth
// @Param exchange_id query string false "Filter by exchange ID"
// @Success 200 {array} services.SubAccountResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /sub-accounts [get]
func (h *SubAccountHandler) GetUserSubAccounts(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        // Parse optional exchange_id filter
        <span class="cov0" title="0">var exchangeID *uuid.UUID
        if exchangeIDStr := c.Query("exchange_id"); exchangeIDStr != "" </span><span class="cov0" title="0">{
                if parsed, err := uuid.Parse(exchangeIDStr); err == nil </span><span class="cov0" title="0">{
                        exchangeID = &amp;parsed
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_EXCHANGE_ID",
                                "Invalid exchange ID format",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
        }

        <span class="cov0" title="0">subAccounts, err := h.subAccountService.GetUserSubAccounts(c.Request.Context(), userID, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "SUBACCOUNTS_GET_FAILED",
                        "Failed to get sub-accounts",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "sub_accounts": subAccounts,
        }

        c.JSON(http.StatusOK, CreateSuccessResponse(response, getTraceID(c)))</span>
}

// GetSubAccount retrieves a specific sub-account by ID
// @Summary Get sub-account by ID
// @Description Retrieves a specific sub-account configuration by ID (must belong to authenticated user)
// @Tags SubAccounts
// @Produce json
// @Security BearerAuth
// @Param id path string true "Sub-account ID"
// @Success 200 {object} services.SubAccountResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /sub-accounts/{id} [get]
func (h *SubAccountHandler) GetSubAccount(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccountIDStr := c.Param("id")
        subAccountID, err := uuid.Parse(subAccountIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_SUBACCOUNT_ID",
                        "Invalid sub-account ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccount, err := h.subAccountService.GetSubAccount(c.Request.Context(), userID, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "sub-account not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "SUBACCOUNT_NOT_FOUND",
                                "Sub-account not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "SUBACCOUNT_GET_FAILED",
                        "Failed to get sub-account",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(subAccount, getTraceID(c)))</span>
}

// UpdateSubAccount updates an existing sub-account
// @Summary Update sub-account
// @Description Updates an existing sub-account configuration (must belong to authenticated user)
// @Tags SubAccounts
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Sub-account ID"
// @Param request body services.UpdateSubAccountRequest true "Update sub-account request"
// @Success 200 {object} services.SubAccountResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /sub-accounts/{id} [put]
func (h *SubAccountHandler) UpdateSubAccount(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccountIDStr := c.Param("id")
        subAccountID, err := uuid.Parse(subAccountIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_SUBACCOUNT_ID",
                        "Invalid sub-account ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.UpdateSubAccountRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_REQUEST",
                        "Invalid request format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccount, err := h.subAccountService.UpdateSubAccount(c.Request.Context(), userID, subAccountID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "sub-account not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "SUBACCOUNT_NOT_FOUND",
                                "Sub-account not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "sub-account name already exists for this exchange" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "SUBACCOUNT_NAME_EXISTS",
                                "Sub-account name already exists for this exchange",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "SUBACCOUNT_UPDATE_FAILED",
                        "Failed to update sub-account",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(subAccount, getTraceID(c)))</span>
}

// UpdateBalance updates sub-account balance
// @Summary Update sub-account balance
// @Description Updates sub-account balance with proper logging (must belong to authenticated user)
// @Tags SubAccounts
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Sub-account ID"
// @Param request body services.UpdateBalanceRequest true "Update balance request"
// @Success 200 {object} services.SubAccountResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /sub-accounts/{id}/balance [put]
func (h *SubAccountHandler) UpdateBalance(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccountIDStr := c.Param("id")
        subAccountID, err := uuid.Parse(subAccountIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_SUBACCOUNT_ID",
                        "Invalid sub-account ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.UpdateBalanceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_REQUEST",
                        "Invalid request format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccount, err := h.subAccountService.UpdateBalance(c.Request.Context(), userID, subAccountID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "sub-account not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "SUBACCOUNT_NOT_FOUND",
                                "Sub-account not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "insufficient balance" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INSUFFICIENT_BALANCE",
                                "Insufficient balance",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "BALANCE_UPDATE_FAILED",
                        "Failed to update balance",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(subAccount, getTraceID(c)))</span>
}

// DeleteSubAccount deletes a sub-account
// @Summary Delete sub-account
// @Description Deletes a sub-account configuration (must belong to authenticated user)
// @Tags SubAccounts
// @Produce json
// @Security BearerAuth
// @Param id path string true "Sub-account ID"
// @Success 200 {object} SuccessResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /sub-accounts/{id} [delete]
func (h *SubAccountHandler) DeleteSubAccount(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccountIDStr := c.Param("id")
        subAccountID, err := uuid.Parse(subAccountIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_SUBACCOUNT_ID",
                        "Invalid sub-account ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">err = h.subAccountService.DeleteSubAccount(c.Request.Context(), userID, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "sub-account not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "SUBACCOUNT_NOT_FOUND",
                                "Sub-account not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "cannot delete sub-account with positive balance" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "SUBACCOUNT_HAS_BALANCE",
                                "Cannot delete sub-account with positive balance",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "SUBACCOUNT_DELETE_FAILED",
                        "Failed to delete sub-account",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "message": "Sub-account deleted successfully",
        }

        c.JSON(http.StatusOK, CreateSuccessResponse(response, getTraceID(c)))</span>
}

// GetSubAccountsBySymbol retrieves sub-accounts by symbol
// @Summary Get sub-accounts by symbol
// @Description Retrieves all sub-accounts for a specific trading symbol (must belong to authenticated user)
// @Tags SubAccounts
// @Produce json
// @Security BearerAuth
// @Param symbol path string true "Trading symbol"
// @Success 200 {array} services.SubAccountResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /sub-accounts/symbol/{symbol} [get]
func (h *SubAccountHandler) GetSubAccountsBySymbol(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">symbol := c.Param("symbol")
        if symbol == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_SYMBOL",
                        "Symbol is required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccounts, err := h.subAccountService.GetSubAccountsBySymbol(c.Request.Context(), userID, symbol)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "SUBACCOUNTS_GET_FAILED",
                        "Failed to get sub-accounts by symbol",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "sub_accounts": subAccounts,
                "symbol":       symbol,
        }

        c.JSON(http.StatusOK, CreateSuccessResponse(response, getTraceID(c)))</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "net/http"
        "time"

        "tiris-backend/internal/middleware"
        "tiris-backend/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// TradingLogHandler handles trading log management endpoints
type TradingLogHandler struct {
        tradingLogService *services.TradingLogService
}

// NewTradingLogHandler creates a new trading log handler
func NewTradingLogHandler(tradingLogService *services.TradingLogService) *TradingLogHandler <span class="cov0" title="0">{
        return &amp;TradingLogHandler{
                tradingLogService: tradingLogService,
        }
}</span>

// CreateTradingLog creates a new trading log entry
// @Summary Create trading log
// @Description Creates a new trading log entry for the authenticated user
// @Tags TradingLogs
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body services.CreateTradingLogRequest true "Create trading log request"
// @Success 201 {object} services.TradingLogResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /trading-logs [post]
func (h *TradingLogHandler) CreateTradingLog(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.CreateTradingLogRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_REQUEST",
                        "Invalid request format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLog, err := h.tradingLogService.CreateTradingLog(c.Request.Context(), userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "sub-account not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "SUBACCOUNT_NOT_FOUND",
                                "Sub-account not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "transaction not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "TRANSACTION_NOT_FOUND",
                                "Transaction not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOG_CREATE_FAILED",
                        "Failed to create trading log",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, CreateSuccessResponse(tradingLog, getTraceID(c)))</span>
}

// GetUserTradingLogs retrieves all trading logs for the current user
// @Summary Get user trading logs
// @Description Retrieves trading log history for the authenticated user with filtering and pagination
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param type query string false "Filter by log type"
// @Param source query string false "Filter by source" Enums(manual, bot)
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param limit query int false "Number of logs to return" default(100)
// @Param offset query int false "Number of logs to skip" default(0)
// @Success 200 {object} services.TradingLogQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /trading-logs [get]
func (h *TradingLogHandler) GetUserTradingLogs(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TradingLogQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLogs, err := h.tradingLogService.GetUserTradingLogs(c.Request.Context(), userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "start date cannot be after end date" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_DATE_RANGE",
                                "Invalid date range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOGS_QUERY_FAILED",
                        "Failed to query trading logs",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(tradingLogs, getTraceID(c)))</span>
}

// GetSubAccountTradingLogs retrieves trading logs for a specific sub-account
// @Summary Get sub-account trading logs
// @Description Retrieves trading log history for a specific sub-account (must belong to authenticated user)
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param sub_account_id path string true "Sub-account ID"
// @Param type query string false "Filter by log type"
// @Param source query string false "Filter by source" Enums(manual, bot)
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param limit query int false "Number of logs to return" default(100)
// @Param offset query int false "Number of logs to skip" default(0)
// @Success 200 {object} services.TradingLogQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /trading-logs/sub-account/{sub_account_id} [get]
func (h *TradingLogHandler) GetSubAccountTradingLogs(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccountIDStr := c.Param("sub_account_id")
        subAccountID, err := uuid.Parse(subAccountIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_SUBACCOUNT_ID",
                        "Invalid sub-account ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TradingLogQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLogs, err := h.tradingLogService.GetSubAccountTradingLogs(c.Request.Context(), userID, subAccountID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "sub-account not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "SUBACCOUNT_NOT_FOUND",
                                "Sub-account not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "start date cannot be after end date" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_DATE_RANGE",
                                "Invalid date range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOGS_QUERY_FAILED",
                        "Failed to query sub-account trading logs",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(tradingLogs, getTraceID(c)))</span>
}

// GetExchangeTradingLogs retrieves trading logs for a specific exchange
// @Summary Get exchange trading logs
// @Description Retrieves trading log history for a specific exchange (must belong to authenticated user)
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param exchange_id path string true "Exchange ID"
// @Param type query string false "Filter by log type"
// @Param source query string false "Filter by source" Enums(manual, bot)
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param limit query int false "Number of logs to return" default(100)
// @Param offset query int false "Number of logs to skip" default(0)
// @Success 200 {object} services.TradingLogQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /trading-logs/exchange/{exchange_id} [get]
func (h *TradingLogHandler) GetExchangeTradingLogs(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchangeIDStr := c.Param("exchange_id")
        exchangeID, err := uuid.Parse(exchangeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_EXCHANGE_ID",
                        "Invalid exchange ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TradingLogQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLogs, err := h.tradingLogService.GetExchangeTradingLogs(c.Request.Context(), userID, exchangeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "start date cannot be after end date" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_DATE_RANGE",
                                "Invalid date range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOGS_QUERY_FAILED",
                        "Failed to query exchange trading logs",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(tradingLogs, getTraceID(c)))</span>
}

// GetTradingLog retrieves a specific trading log by ID
// @Summary Get trading log by ID
// @Description Retrieves a specific trading log by ID (must belong to authenticated user)
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param id path string true "Trading Log ID"
// @Success 200 {object} services.TradingLogResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /trading-logs/{id} [get]
func (h *TradingLogHandler) GetTradingLog(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLogIDStr := c.Param("id")
        tradingLogID, err := uuid.Parse(tradingLogIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_TRADING_LOG_ID",
                        "Invalid trading log ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLog, err := h.tradingLogService.GetTradingLog(c.Request.Context(), userID, tradingLogID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "trading log not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "TRADING_LOG_NOT_FOUND",
                                "Trading log not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOG_GET_FAILED",
                        "Failed to get trading log",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(tradingLog, getTraceID(c)))</span>
}

// GetTradingLogsByTimeRange retrieves trading logs within a specific time range
// @Summary Get trading logs by time range
// @Description Retrieves trading logs within a specific time range for the authenticated user
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param start_time query string true "Start time (RFC3339 format)"
// @Param end_time query string true "End time (RFC3339 format)"
// @Param type query string false "Filter by log type"
// @Param source query string false "Filter by source" Enums(manual, bot)
// @Param limit query int false "Number of logs to return" default(100)
// @Param offset query int false "Number of logs to skip" default(0)
// @Success 200 {object} services.TradingLogQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /trading-logs/time-range [get]
func (h *TradingLogHandler) GetTradingLogsByTimeRange(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        // Parse required time range parameters
        <span class="cov0" title="0">startTimeStr := c.Query("start_time")
        endTimeStr := c.Query("end_time")

        if startTimeStr == "" || endTimeStr == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "MISSING_TIME_RANGE",
                        "Start time and end time are required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">startTime, err := time.Parse(time.RFC3339, startTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_START_TIME",
                        "Invalid start time format (use RFC3339)",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">endTime, err := time.Parse(time.RFC3339, endTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_END_TIME",
                        "Invalid end time format (use RFC3339)",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TradingLogQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLogs, err := h.tradingLogService.GetTradingLogsByTimeRange(c.Request.Context(), userID, startTime, endTime, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "start time cannot be after end time" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_TIME_RANGE",
                                "Invalid time range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOGS_QUERY_FAILED",
                        "Failed to query trading logs by time range",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(tradingLogs, getTraceID(c)))</span>
}

// DeleteTradingLog deletes a trading log
// @Summary Delete trading log
// @Description Deletes a trading log entry (must belong to authenticated user and be manual)
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param id path string true "Trading Log ID"
// @Success 200 {object} SuccessResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /trading-logs/{id} [delete]
func (h *TradingLogHandler) DeleteTradingLog(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLogIDStr := c.Param("id")
        tradingLogID, err := uuid.Parse(tradingLogIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_TRADING_LOG_ID",
                        "Invalid trading log ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">err = h.tradingLogService.DeleteTradingLog(c.Request.Context(), userID, tradingLogID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "trading log not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "TRADING_LOG_NOT_FOUND",
                                "Trading log not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "cannot delete bot-generated trading logs" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "CANNOT_DELETE_BOT_LOG",
                                "Cannot delete bot-generated trading logs",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOG_DELETE_FAILED",
                        "Failed to delete trading log",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "message": "Trading log deleted successfully",
        }

        c.JSON(http.StatusOK, CreateSuccessResponse(response, getTraceID(c)))</span>
}

// ListAllTradingLogs lists all trading logs with filtering (admin only)
// @Summary List all trading logs
// @Description Lists all trading logs with filtering and pagination (admin only)
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param type query string false "Filter by log type"
// @Param source query string false "Filter by source" Enums(manual, bot)
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param limit query int false "Number of logs to return" default(100)
// @Param offset query int false "Number of logs to skip" default(0)
// @Success 200 {object} services.TradingLogQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /admin/trading-logs [get]
func (h *TradingLogHandler) ListAllTradingLogs(c *gin.Context) <span class="cov0" title="0">{
        var req services.TradingLogQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLogs, err := h.tradingLogService.ListAllTradingLogs(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "start date cannot be after end date" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_DATE_RANGE",
                                "Invalid date range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOGS_LIST_FAILED",
                        "Failed to list trading logs",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(tradingLogs, getTraceID(c)))</span>
}

// GetTradingLogByID retrieves trading log by ID (admin only)
// @Summary Get trading log by ID
// @Description Retrieves a trading log by ID (admin only)
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param id path string true "Trading Log ID"
// @Success 200 {object} services.TradingLogResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /admin/trading-logs/{id} [get]
func (h *TradingLogHandler) GetTradingLogByID(c *gin.Context) <span class="cov0" title="0">{
        tradingLogIDStr := c.Param("id")
        tradingLogID, err := uuid.Parse(tradingLogIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_TRADING_LOG_ID",
                        "Invalid trading log ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLog, err := h.tradingLogService.GetTradingLogByID(c.Request.Context(), tradingLogID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "trading log not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "TRADING_LOG_NOT_FOUND",
                                "Trading log not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOG_GET_FAILED",
                        "Failed to get trading log",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(tradingLog, getTraceID(c)))</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "net/http"
        "time"

        "tiris-backend/internal/middleware"
        "tiris-backend/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// TransactionHandler handles transaction query endpoints
type TransactionHandler struct {
        transactionService *services.TransactionService
}

// NewTransactionHandler creates a new transaction handler
func NewTransactionHandler(transactionService *services.TransactionService) *TransactionHandler <span class="cov0" title="0">{
        return &amp;TransactionHandler{
                transactionService: transactionService,
        }
}</span>

// GetUserTransactions retrieves all transactions for the current user
// @Summary Get user transactions
// @Description Retrieves transaction history for the authenticated user with filtering and pagination
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Param direction query string false "Filter by direction" Enums(debit, credit)
// @Param reason query string false "Filter by reason"
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param min_amount query number false "Minimum amount filter"
// @Param max_amount query number false "Maximum amount filter"
// @Param limit query int false "Number of transactions to return" default(100)
// @Param offset query int false "Number of transactions to skip" default(0)
// @Success 200 {object} services.TransactionQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /transactions [get]
func (h *TransactionHandler) GetUserTransactions(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TransactionQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transactions, err := h.transactionService.GetUserTransactions(c.Request.Context(), userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "start date cannot be after end date" ||
                        err.Error() == "min amount cannot be greater than max amount" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_FILTER_RANGE",
                                "Invalid filter range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRANSACTIONS_QUERY_FAILED",
                        "Failed to query transactions",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(transactions, getTraceID(c)))</span>
}

// GetSubAccountTransactions retrieves transactions for a specific sub-account
// @Summary Get sub-account transactions
// @Description Retrieves transaction history for a specific sub-account (must belong to authenticated user)
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Param sub_account_id path string true "Sub-account ID"
// @Param direction query string false "Filter by direction" Enums(debit, credit)
// @Param reason query string false "Filter by reason"
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param min_amount query number false "Minimum amount filter"
// @Param max_amount query number false "Maximum amount filter"
// @Param limit query int false "Number of transactions to return" default(100)
// @Param offset query int false "Number of transactions to skip" default(0)
// @Success 200 {object} services.TransactionQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /transactions/sub-account/{sub_account_id} [get]
func (h *TransactionHandler) GetSubAccountTransactions(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccountIDStr := c.Param("sub_account_id")
        subAccountID, err := uuid.Parse(subAccountIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_SUBACCOUNT_ID",
                        "Invalid sub-account ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TransactionQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transactions, err := h.transactionService.GetSubAccountTransactions(c.Request.Context(), userID, subAccountID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "sub-account not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "SUBACCOUNT_NOT_FOUND",
                                "Sub-account not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "start date cannot be after end date" ||
                        err.Error() == "min amount cannot be greater than max amount" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_FILTER_RANGE",
                                "Invalid filter range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRANSACTIONS_QUERY_FAILED",
                        "Failed to query sub-account transactions",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(transactions, getTraceID(c)))</span>
}

// GetExchangeTransactions retrieves transactions for a specific exchange
// @Summary Get exchange transactions
// @Description Retrieves transaction history for a specific exchange (must belong to authenticated user)
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Param exchange_id path string true "Exchange ID"
// @Param direction query string false "Filter by direction" Enums(debit, credit)
// @Param reason query string false "Filter by reason"
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param min_amount query number false "Minimum amount filter"
// @Param max_amount query number false "Maximum amount filter"
// @Param limit query int false "Number of transactions to return" default(100)
// @Param offset query int false "Number of transactions to skip" default(0)
// @Success 200 {object} services.TransactionQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /transactions/exchange/{exchange_id} [get]
func (h *TransactionHandler) GetExchangeTransactions(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchangeIDStr := c.Param("exchange_id")
        exchangeID, err := uuid.Parse(exchangeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_EXCHANGE_ID",
                        "Invalid exchange ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TransactionQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transactions, err := h.transactionService.GetExchangeTransactions(c.Request.Context(), userID, exchangeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "start date cannot be after end date" ||
                        err.Error() == "min amount cannot be greater than max amount" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_FILTER_RANGE",
                                "Invalid filter range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRANSACTIONS_QUERY_FAILED",
                        "Failed to query exchange transactions",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(transactions, getTraceID(c)))</span>
}

// GetTransaction retrieves a specific transaction by ID
// @Summary Get transaction by ID
// @Description Retrieves a specific transaction by ID (must belong to authenticated user)
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Param id path string true "Transaction ID"
// @Success 200 {object} services.TransactionResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /transactions/{id} [get]
func (h *TransactionHandler) GetTransaction(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transactionIDStr := c.Param("id")
        transactionID, err := uuid.Parse(transactionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_TRANSACTION_ID",
                        "Invalid transaction ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transaction, err := h.transactionService.GetTransaction(c.Request.Context(), userID, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "transaction not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "TRANSACTION_NOT_FOUND",
                                "Transaction not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRANSACTION_GET_FAILED",
                        "Failed to get transaction",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(transaction, getTraceID(c)))</span>
}

// GetTransactionsByTimeRange retrieves transactions within a specific time range
// @Summary Get transactions by time range
// @Description Retrieves transactions within a specific time range for the authenticated user
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Param start_time query string true "Start time (RFC3339 format)"
// @Param end_time query string true "End time (RFC3339 format)"
// @Param direction query string false "Filter by direction" Enums(debit, credit)
// @Param reason query string false "Filter by reason"
// @Param min_amount query number false "Minimum amount filter"
// @Param max_amount query number false "Maximum amount filter"
// @Param limit query int false "Number of transactions to return" default(100)
// @Param offset query int false "Number of transactions to skip" default(0)
// @Success 200 {object} services.TransactionQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /transactions/time-range [get]
func (h *TransactionHandler) GetTransactionsByTimeRange(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        // Parse required time range parameters
        <span class="cov0" title="0">startTimeStr := c.Query("start_time")
        endTimeStr := c.Query("end_time")

        if startTimeStr == "" || endTimeStr == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "MISSING_TIME_RANGE",
                        "Start time and end time are required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">startTime, err := time.Parse(time.RFC3339, startTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_START_TIME",
                        "Invalid start time format (use RFC3339)",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">endTime, err := time.Parse(time.RFC3339, endTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_END_TIME",
                        "Invalid end time format (use RFC3339)",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TransactionQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transactions, err := h.transactionService.GetTransactionsByTimeRange(c.Request.Context(), userID, startTime, endTime, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "start time cannot be after end time" ||
                        err.Error() == "min amount cannot be greater than max amount" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_FILTER_RANGE",
                                "Invalid filter range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRANSACTIONS_QUERY_FAILED",
                        "Failed to query transactions by time range",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(transactions, getTraceID(c)))</span>
}

// ListAllTransactions lists all transactions with filtering (admin only)
// @Summary List all transactions
// @Description Lists all transactions with filtering and pagination (admin only)
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Param direction query string false "Filter by direction" Enums(debit, credit)
// @Param reason query string false "Filter by reason"
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param min_amount query number false "Minimum amount filter"
// @Param max_amount query number false "Maximum amount filter"
// @Param limit query int false "Number of transactions to return" default(100)
// @Param offset query int false "Number of transactions to skip" default(0)
// @Success 200 {object} services.TransactionQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /admin/transactions [get]
func (h *TransactionHandler) ListAllTransactions(c *gin.Context) <span class="cov0" title="0">{
        var req services.TransactionQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transactions, err := h.transactionService.ListAllTransactions(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "start date cannot be after end date" ||
                        err.Error() == "min amount cannot be greater than max amount" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_FILTER_RANGE",
                                "Invalid filter range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRANSACTIONS_LIST_FAILED",
                        "Failed to list transactions",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(transactions, getTraceID(c)))</span>
}

// GetTransactionByID retrieves transaction by ID (admin only)
// @Summary Get transaction by ID
// @Description Retrieves a transaction by ID (admin only)
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Param id path string true "Transaction ID"
// @Success 200 {object} services.TransactionResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /admin/transactions/{id} [get]
func (h *TransactionHandler) GetTransactionByID(c *gin.Context) <span class="cov0" title="0">{
        transactionIDStr := c.Param("id")
        transactionID, err := uuid.Parse(transactionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_TRANSACTION_ID",
                        "Invalid transaction ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transaction, err := h.transactionService.GetTransactionByID(c.Request.Context(), transactionID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "transaction not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "TRANSACTION_NOT_FOUND",
                                "Transaction not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRANSACTION_GET_FAILED",
                        "Failed to get transaction",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(transaction, getTraceID(c)))</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import "time"

// SuccessResponse represents a successful API response
type SuccessResponse struct {
        Success  bool             `json:"success"`
        Data     interface{}      `json:"data"`
        Metadata ResponseMetadata `json:"metadata"`
}

// ErrorResponse represents an error API response
type ErrorResponse struct {
        Success  bool             `json:"success"`
        Error    ErrorDetail      `json:"error"`
        Metadata ResponseMetadata `json:"metadata"`
}

// ErrorDetail represents error details
type ErrorDetail struct {
        Code    string `json:"code"`
        Message string `json:"message"`
        Details string `json:"details,omitempty"`
}

// ResponseMetadata represents response metadata
type ResponseMetadata struct {
        Timestamp string `json:"timestamp"`
        TraceID   string `json:"trace_id,omitempty"`
}

// PaginationMetadata represents pagination information
type PaginationMetadata struct {
        Total      int64 `json:"total"`
        Limit      int   `json:"limit"`
        Offset     int   `json:"offset"`
        HasMore    bool  `json:"has_more"`
        NextOffset *int  `json:"next_offset,omitempty"`
}

// PaginatedResponse represents a paginated API response
type PaginatedResponse struct {
        Success    bool                `json:"success"`
        Data       interface{}         `json:"data"`
        Pagination *PaginationMetadata `json:"pagination,omitempty"`
        Metadata   ResponseMetadata    `json:"metadata"`
}

// CreateSuccessResponse creates a success response
func CreateSuccessResponse(data interface{}, traceID string) SuccessResponse <span class="cov0" title="0">{
        return SuccessResponse{
                Success: true,
                Data:    data,
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   traceID,
                },
        }
}</span>

// CreateErrorResponse creates an error response
func CreateErrorResponse(code, message, details, traceID string) ErrorResponse <span class="cov0" title="0">{
        return ErrorResponse{
                Success: false,
                Error: ErrorDetail{
                        Code:    code,
                        Message: message,
                        Details: details,
                },
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   traceID,
                },
        }
}</span>

// CreatePaginatedResponse creates a paginated response
func CreatePaginatedResponse(data interface{}, pagination *PaginationMetadata, traceID string) PaginatedResponse <span class="cov0" title="0">{
        return PaginatedResponse{
                Success:    true,
                Data:       data,
                Pagination: pagination,
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   traceID,
                },
        }
}</span>

// HealthCheckResponse represents health check response
type HealthCheckResponse struct {
        Status    string                 `json:"status"`
        Checks    map[string]string      `json:"checks,omitempty"`
        Timestamp string                 `json:"timestamp"`
        Metadata  map[string]interface{} `json:"metadata,omitempty"`
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "net/http"
        "strconv"

        "tiris-backend/internal/middleware"
        "tiris-backend/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// UserHandler handles user management endpoints
type UserHandler struct {
        userService *services.UserService
}

// NewUserHandler creates a new user handler
func NewUserHandler(userService *services.UserService) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                userService: userService,
        }
}</span>

// GetCurrentUser retrieves current user profile
// @Summary Get current user profile
// @Description Retrieves the profile of the currently authenticated user
// @Tags Users
// @Produce json
// @Security BearerAuth
// @Success 200 {object} services.UserResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users/me [get]
func (h *UserHandler) GetCurrentUser(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.GetCurrentUser(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "USER_GET_FAILED",
                        "Failed to get user profile",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(user, getTraceID(c)))</span>
}

// UpdateCurrentUser updates current user profile
// @Summary Update current user profile
// @Description Updates the profile of the currently authenticated user
// @Tags Users
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body services.UpdateUserRequest true "Update user request"
// @Success 200 {object} services.UserResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users/me [put]
func (h *UserHandler) UpdateCurrentUser(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_REQUEST",
                        "Invalid request format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.UpdateCurrentUser(c.Request.Context(), userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "username already taken" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "USERNAME_TAKEN",
                                "Username is already taken",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "USER_UPDATE_FAILED",
                        "Failed to update user profile",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(user, getTraceID(c)))</span>
}

// GetUserStats retrieves current user statistics
// @Summary Get current user statistics
// @Description Retrieves statistics for the currently authenticated user
// @Tags Users
// @Produce json
// @Security BearerAuth
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users/me/stats [get]
func (h *UserHandler) GetUserStats(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.userService.GetUserStats(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "STATS_GET_FAILED",
                        "Failed to get user statistics",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(stats, getTraceID(c)))</span>
}

// ListUsers lists all users (admin only)
// @Summary List all users
// @Description Lists all users with pagination (admin only)
// @Tags Users
// @Produce json
// @Security BearerAuth
// @Param limit query int false "Number of users to return" default(100)
// @Param offset query int false "Number of users to skip" default(0)
// @Success 200 {object} PaginatedResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users [get]
func (h *UserHandler) ListUsers(c *gin.Context) <span class="cov0" title="0">{
        // Parse pagination parameters
        limit := 100
        if l := c.Query("limit"); l != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(l); err == nil &amp;&amp; parsed &gt; 0 &amp;&amp; parsed &lt;= 1000 </span><span class="cov0" title="0">{
                        limit = parsed
                }</span>
        }

        <span class="cov0" title="0">offset := 0
        if o := c.Query("offset"); o != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(o); err == nil &amp;&amp; parsed &gt;= 0 </span><span class="cov0" title="0">{
                        offset = parsed
                }</span>
        }

        <span class="cov0" title="0">users, total, err := h.userService.ListUsers(c.Request.Context(), limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "USERS_LIST_FAILED",
                        "Failed to list users",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        // Create pagination metadata
        <span class="cov0" title="0">hasMore := int64(offset+limit) &lt; total
        var nextOffset *int
        if hasMore </span><span class="cov0" title="0">{
                next := offset + limit
                nextOffset = &amp;next
        }</span>

        <span class="cov0" title="0">pagination := &amp;PaginationMetadata{
                Total:      total,
                Limit:      limit,
                Offset:     offset,
                HasMore:    hasMore,
                NextOffset: nextOffset,
        }

        response := map[string]interface{}{
                "users": users,
        }

        c.JSON(http.StatusOK, CreatePaginatedResponse(response, pagination, getTraceID(c)))</span>
}

// GetUserByID retrieves user by ID (admin only)
// @Summary Get user by ID
// @Description Retrieves a user by their ID (admin only)
// @Tags Users
// @Produce json
// @Security BearerAuth
// @Param id path string true "User ID"
// @Success 200 {object} services.UserResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users/{id} [get]
func (h *UserHandler) GetUserByID(c *gin.Context) <span class="cov0" title="0">{
        userIDStr := c.Param("id")
        userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_USER_ID",
                        "Invalid user ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.GetUserByID(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "user not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "USER_NOT_FOUND",
                                "User not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "USER_GET_FAILED",
                        "Failed to get user",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(user, getTraceID(c)))</span>
}

// DisableUser disables a user account (admin only)
// @Summary Disable user account
// @Description Disables a user account by ID (admin only)
// @Tags Users
// @Produce json
// @Security BearerAuth
// @Param id path string true "User ID"
// @Success 200 {object} SuccessResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users/{id}/disable [put]
func (h *UserHandler) DisableUser(c *gin.Context) <span class="cov0" title="0">{
        userIDStr := c.Param("id")
        userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_USER_ID",
                        "Invalid user ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">err = h.userService.DisableUser(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "user not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "USER_NOT_FOUND",
                                "User not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "USER_DISABLE_FAILED",
                        "Failed to disable user",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "message": "User account disabled successfully",
        }

        c.JSON(http.StatusOK, CreateSuccessResponse(response, getTraceID(c)))</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package database

import (
        "fmt"
        "time"

        "tiris-backend/internal/config"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

type DB struct {
        *gorm.DB
}

func Initialize(cfg config.DatabaseConfig) (*DB, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf(
                "host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
                cfg.Host,
                cfg.Port,
                cfg.Username,
                cfg.Password,
                cfg.DatabaseName,
                cfg.SSLMode,
        )

        // Configure GORM logger
        var logLevel logger.LogLevel
        if cfg.SSLMode == "disable" </span><span class="cov0" title="0">{ // Assume development environment
                logLevel = logger.Info
        }</span> else<span class="cov0" title="0"> {
                logLevel = logger.Error
        }</span>

        <span class="cov0" title="0">gormConfig := &amp;gorm.Config{
                Logger: logger.Default.LogMode(logLevel),
        }

        db, err := gorm.Open(postgres.Open(dsn), gormConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        // Get underlying SQL DB to configure connection pool
        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get underlying SQL DB: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(cfg.MaxConns)
        sqlDB.SetMaxIdleConns(cfg.MaxIdleConns)
        sqlDB.SetConnMaxLifetime(time.Duration(cfg.MaxLifetime) * time.Second)

        // Test the connection
        if err := sqlDB.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        // Enable TimescaleDB extension
        <span class="cov0" title="0">if err := enableTimescaleDB(db); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to enable TimescaleDB: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;DB{db}, nil</span>
}

func enableTimescaleDB(db *gorm.DB) error <span class="cov0" title="0">{
        // Check if TimescaleDB extension exists
        var extensionExists bool
        err := db.Raw("SELECT EXISTS(SELECT 1 FROM pg_extension WHERE extname = 'timescaledb')").Scan(&amp;extensionExists).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check TimescaleDB extension: %w", err)
        }</span>

        // Create extension if it doesn't exist (requires superuser privileges)
        <span class="cov0" title="0">if !extensionExists </span><span class="cov0" title="0">{
                err = db.Exec("CREATE EXTENSION IF NOT EXISTS timescaledb CASCADE").Error
                if err != nil </span><span class="cov0" title="0">{
                        // Log warning but don't fail if we can't create the extension
                        // This might happen in managed database environments
                        fmt.Printf("Warning: Could not create TimescaleDB extension: %v\n", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func Close(db *DB) error <span class="cov0" title="0">{
        if db == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">sqlDB, err := db.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying SQL DB: %w", err)
        }</span>

        <span class="cov0" title="0">return sqlDB.Close()</span>
}

func (db *DB) HealthCheck() error <span class="cov0" title="0">{
        sqlDB, err := db.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying SQL DB: %w", err)
        }</span>

        <span class="cov0" title="0">return sqlDB.Ping()</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package database

import (
        "errors"
        "fmt"

        "tiris-backend/internal/config"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        "gorm.io/gorm"
)

func RunMigrations(db *gorm.DB, cfg config.DatabaseConfig) error <span class="cov0" title="0">{
        // Get the underlying sql.DB
        sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying SQL DB: %w", err)
        }</span>

        // Create postgres driver instance
        <span class="cov0" title="0">driver, err := postgres.WithInstance(sqlDB, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create postgres driver: %w", err)
        }</span>

        // Create migrate instance
        <span class="cov0" title="0">m, err := migrate.NewWithDatabaseInstance(
                "file://migrations",
                "postgres",
                driver,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrate instance: %w", err)
        }</span>
        <span class="cov0" title="0">defer m.Close()

        // Run migrations
        err = m.Up()
        if err != nil &amp;&amp; !errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to run migrations: %w", err)
        }</span>

        <span class="cov0" title="0">if errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                fmt.Println("No new migrations to run")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Migrations completed successfully")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func RollbackMigrations(db *gorm.DB, steps int) error <span class="cov0" title="0">{
        // Get the underlying sql.DB
        sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get underlying SQL DB: %w", err)
        }</span>

        // Create postgres driver instance
        <span class="cov0" title="0">driver, err := postgres.WithInstance(sqlDB, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create postgres driver: %w", err)
        }</span>

        // Create migrate instance
        <span class="cov0" title="0">m, err := migrate.NewWithDatabaseInstance(
                "file://migrations",
                "postgres",
                driver,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrate instance: %w", err)
        }</span>
        <span class="cov0" title="0">defer m.Close()

        // Get current version
        currentVersion, dirty, err := m.Version()
        if err != nil &amp;&amp; !errors.Is(err, migrate.ErrNilVersion) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current migration version: %w", err)
        }</span>

        <span class="cov0" title="0">if dirty </span><span class="cov0" title="0">{
                return fmt.Errorf("database is in dirty state, manual intervention required")
        }</span>

        <span class="cov0" title="0">if errors.Is(err, migrate.ErrNilVersion) </span><span class="cov0" title="0">{
                fmt.Println("No migrations to rollback")
                return nil
        }</span>

        // Calculate target version
        <span class="cov0" title="0">targetVersion := int(currentVersion) - steps
        if targetVersion &lt; 0 </span><span class="cov0" title="0">{
                targetVersion = 0
        }</span>

        // Migrate to target version
        <span class="cov0" title="0">err = m.Migrate(uint(targetVersion))
        if err != nil &amp;&amp; !errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to rollback migrations: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Rolled back %d migration(s)\n", steps)
        return nil</span>
}

func GetMigrationVersion(db *gorm.DB) (uint, bool, error) <span class="cov0" title="0">{
        // Get the underlying sql.DB
        sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return 0, false, fmt.Errorf("failed to get underlying SQL DB: %w", err)
        }</span>

        // Create postgres driver instance
        <span class="cov0" title="0">driver, err := postgres.WithInstance(sqlDB, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return 0, false, fmt.Errorf("failed to create postgres driver: %w", err)
        }</span>

        // Create migrate instance
        <span class="cov0" title="0">m, err := migrate.NewWithDatabaseInstance(
                "file://migrations",
                "postgres",
                driver,
        )
        if err != nil </span><span class="cov0" title="0">{
                return 0, false, fmt.Errorf("failed to create migrate instance: %w", err)
        }</span>
        <span class="cov0" title="0">defer m.Close()

        // Get current version
        version, dirty, err := m.Version()
        if err != nil &amp;&amp; !errors.Is(err, migrate.ErrNilVersion) </span><span class="cov0" title="0">{
                return 0, false, fmt.Errorf("failed to get migration version: %w", err)
        }</span>

        <span class="cov0" title="0">if errors.Is(err, migrate.ErrNilVersion) </span><span class="cov0" title="0">{
                return 0, dirty, nil
        }</span>

        <span class="cov0" title="0">return version, dirty, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "net/http"

        "tiris-backend/pkg/auth"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// AuthMiddleware creates a JWT authentication middleware
func AuthMiddleware(jwtManager *auth.JWTManager) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Get authorization header
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "error": gin.H{
                                        "code":    "AUTH_REQUIRED",
                                        "message": "Authorization header is required",
                                },
                        })
                        c.Abort()
                        return
                }</span>

                // Extract token from header
                <span class="cov0" title="0">token, err := auth.ExtractTokenFromHeader(authHeader)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "error": gin.H{
                                        "code":    "INVALID_TOKEN",
                                        "message": "Invalid authorization header format",
                                },
                        })
                        c.Abort()
                        return
                }</span>

                // Validate token
                <span class="cov0" title="0">claims, err := jwtManager.ValidateToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "error": gin.H{
                                        "code":    "INVALID_TOKEN",
                                        "message": "Invalid or expired token",
                                },
                        })
                        c.Abort()
                        return
                }</span>

                // Set user context
                <span class="cov0" title="0">c.Set("user_id", claims.UserID)
                c.Set("username", claims.Username)
                c.Set("email", claims.Email)
                c.Set("role", claims.Role)
                c.Set("claims", claims)

                c.Next()</span>
        }
}

// OptionalAuthMiddleware creates an optional JWT authentication middleware
// If token is provided, it validates it, otherwise continues without authentication
func OptionalAuthMiddleware(jwtManager *auth.JWTManager) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Get authorization header
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Extract token from header
                <span class="cov0" title="0">token, err := auth.ExtractTokenFromHeader(authHeader)
                if err != nil </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Validate token
                <span class="cov0" title="0">claims, err := jwtManager.ValidateToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Set user context
                <span class="cov0" title="0">c.Set("user_id", claims.UserID)
                c.Set("username", claims.Username)
                c.Set("email", claims.Email)
                c.Set("role", claims.Role)
                c.Set("claims", claims)

                c.Next()</span>
        }
}

// AdminMiddleware ensures the user has admin role
func AdminMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                role, exists := c.Get("role")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "error": gin.H{
                                        "code":    "AUTH_REQUIRED",
                                        "message": "Authentication required",
                                },
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if role != "admin" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "success": false,
                                "error": gin.H{
                                        "code":    "ACCESS_DENIED",
                                        "message": "Admin access required",
                                },
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// GetUserID extracts user ID from gin context
func GetUserID(c *gin.Context) (uuid.UUID, bool) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                return uuid.Nil, false
        }</span>

        <span class="cov0" title="0">id, ok := userID.(uuid.UUID)
        return id, ok</span>
}

// GetUsername extracts username from gin context
func GetUsername(c *gin.Context) (string, bool) <span class="cov0" title="0">{
        username, exists := c.Get("username")
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">name, ok := username.(string)
        return name, ok</span>
}

// GetEmail extracts email from gin context
func GetEmail(c *gin.Context) (string, bool) <span class="cov0" title="0">{
        email, exists := c.Get("email")
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">emailStr, ok := email.(string)
        return emailStr, ok</span>
}

// GetRole extracts role from gin context
func GetRole(c *gin.Context) (string, bool) <span class="cov0" title="0">{
        role, exists := c.Get("role")
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">roleStr, ok := role.(string)
        return roleStr, ok</span>
}

// GetClaims extracts full JWT claims from gin context
func GetClaims(c *gin.Context) (*auth.Claims, bool) <span class="cov0" title="0">{
        claims, exists := c.Get("claims")
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">jwtClaims, ok := claims.(*auth.Claims)
        return jwtClaims, ok</span>
}

// IsAuthenticated checks if the request is authenticated
func IsAuthenticated(c *gin.Context) bool <span class="cov0" title="0">{
        _, exists := c.Get("user_id")
        return exists
}</span>

// RequireUserOwnership middleware ensures the user can only access their own resources
func RequireUserOwnership() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                userID, exists := GetUserID(c)
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "success": false,
                                "error": gin.H{
                                        "code":    "AUTH_REQUIRED",
                                        "message": "Authentication required",
                                },
                        })
                        c.Abort()
                        return
                }</span>

                // Check if user is admin (admins can access any resource)
                <span class="cov0" title="0">role, _ := GetRole(c)
                if role == "admin" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Get resource user ID from path parameter
                <span class="cov0" title="0">resourceUserIDStr := c.Param("user_id")
                if resourceUserIDStr != "" </span><span class="cov0" title="0">{
                        resourceUserID, err := uuid.Parse(resourceUserIDStr)
                        if err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusBadRequest, gin.H{
                                        "success": false,
                                        "error": gin.H{
                                                "code":    "INVALID_USER_ID",
                                                "message": "Invalid user ID format",
                                        },
                                })
                                c.Abort()
                                return
                        }</span>

                        <span class="cov0" title="0">if userID != resourceUserID </span><span class="cov0" title="0">{
                                c.JSON(http.StatusForbidden, gin.H{
                                        "success": false,
                                        "error": gin.H{
                                                "code":    "ACCESS_DENIED",
                                                "message": "Access denied to this resource",
                                        },
                                })
                                c.Abort()
                                return
                        }</span>
                }

                <span class="cov0" title="0">c.Next()</span>
        }
}

// CORS middleware for handling cross-origin requests
func CORSMiddleware(allowedOrigins []string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                origin := c.Request.Header.Get("Origin")

                // Check if origin is allowed
                allowed := false
                for _, allowedOrigin := range allowedOrigins </span><span class="cov0" title="0">{
                        if origin == allowedOrigin || allowedOrigin == "*" </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if allowed </span><span class="cov0" title="0">{
                        c.Header("Access-Control-Allow-Origin", origin)
                }</span>

                <span class="cov0" title="0">c.Header("Access-Control-Allow-Credentials", "true")
                c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                c.Header("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE, PATCH")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequestIDMiddleware adds a unique request ID to each request
func RequestIDMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = uuid.New().String()
                }</span>

                <span class="cov0" title="0">c.Header("X-Request-ID", requestID)
                c.Set("request_id", requestID)
                c.Next()</span>
        }
}

// SecurityHeadersMiddleware adds security headers
func SecurityHeadersMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("X-Content-Type-Options", "nosniff")
                c.Header("X-Frame-Options", "DENY")
                c.Header("X-XSS-Protection", "1; mode=block")
                c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
                c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
                c.Header("Content-Security-Policy", "default-src 'self'")
                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import (
        "bytes"
        "encoding/json"
        "io"
        "log"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// LogEntry represents a structured log entry
type LogEntry struct {
        Timestamp    time.Time  `json:"timestamp"`
        RequestID    string     `json:"request_id"`
        Method       string     `json:"method"`
        Path         string     `json:"path"`
        Query        string     `json:"query,omitempty"`
        StatusCode   int        `json:"status_code"`
        Duration     float64    `json:"duration_ms"`
        ClientIP     string     `json:"client_ip"`
        UserAgent    string     `json:"user_agent"`
        UserID       *uuid.UUID `json:"user_id,omitempty"`
        Username     *string    `json:"username,omitempty"`
        RequestSize  int64      `json:"request_size"`
        ResponseSize int        `json:"response_size"`
        Error        *string    `json:"error,omitempty"`
        Level        string     `json:"level"`
        Service      string     `json:"service"`
}

// responseWriter wrapper to capture response size
type responseWriter struct {
        gin.ResponseWriter
        size int
}

func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        size, err := rw.ResponseWriter.Write(b)
        rw.size += size
        return size, err
}</span>

func (rw *responseWriter) WriteString(s string) (int, error) <span class="cov0" title="0">{
        size, err := rw.ResponseWriter.WriteString(s)
        rw.size += size
        return size, err
}</span>

// LoggingMiddleware creates a structured logging middleware
func LoggingMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()

                // Generate request ID if not present
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = uuid.New().String()
                        c.Header("X-Request-ID", requestID)
                }</span>

                // Wrap response writer to capture response size
                <span class="cov0" title="0">rw := &amp;responseWriter{
                        ResponseWriter: c.Writer,
                        size:           0,
                }
                c.Writer = rw

                // Get request size
                var requestSize int64
                if c.Request.Body != nil </span><span class="cov0" title="0">{
                        // Read body to calculate size
                        bodyBytes, err := io.ReadAll(c.Request.Body)
                        if err == nil </span><span class="cov0" title="0">{
                                requestSize = int64(len(bodyBytes))
                                // Restore body for further processing
                                c.Request.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
                        }</span>
                }

                // Process request
                <span class="cov0" title="0">c.Next()

                // Calculate duration
                duration := time.Since(start)

                // Get user info if authenticated
                var userID *uuid.UUID
                var username *string
                if id, exists := GetUserID(c); exists </span><span class="cov0" title="0">{
                        userID = &amp;id
                }</span>
                <span class="cov0" title="0">if name, exists := GetUsername(c); exists </span><span class="cov0" title="0">{
                        username = &amp;name
                }</span>

                // Get error if any
                <span class="cov0" title="0">var errorMsg *string
                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        err := c.Errors.Last().Error()
                        errorMsg = &amp;err
                }</span>

                // Determine log level based on status code
                <span class="cov0" title="0">level := "info"
                statusCode := c.Writer.Status()
                if statusCode &gt;= 400 &amp;&amp; statusCode &lt; 500 </span><span class="cov0" title="0">{
                        level = "warn"
                }</span> else<span class="cov0" title="0"> if statusCode &gt;= 500 </span><span class="cov0" title="0">{
                        level = "error"
                }</span>

                // Create log entry
                <span class="cov0" title="0">logEntry := LogEntry{
                        Timestamp:    start,
                        RequestID:    requestID,
                        Method:       c.Request.Method,
                        Path:         c.Request.URL.Path,
                        Query:        c.Request.URL.RawQuery,
                        StatusCode:   statusCode,
                        Duration:     float64(duration.Nanoseconds()) / 1000000, // Convert to milliseconds
                        ClientIP:     c.ClientIP(),
                        UserAgent:    c.Request.UserAgent(),
                        UserID:       userID,
                        Username:     username,
                        RequestSize:  requestSize,
                        ResponseSize: rw.size,
                        Error:        errorMsg,
                        Level:        level,
                        Service:      "tiris-backend",
                }

                // Log the entry as JSON
                logJSON, err := json.Marshal(logEntry)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to marshal log entry: %v", err)
                        return
                }</span>

                <span class="cov0" title="0">log.Println(string(logJSON))</span>
        }
}

// ErrorLoggingMiddleware logs errors with more detail
func ErrorLoggingMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.CustomRecovery(func(c *gin.Context, recovered interface{}) </span><span class="cov0" title="0">{
                requestID := c.GetHeader("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = uuid.New().String()
                }</span>

                // Get user info if authenticated
                <span class="cov0" title="0">var userID *uuid.UUID
                var username *string
                if id, exists := GetUserID(c); exists </span><span class="cov0" title="0">{
                        userID = &amp;id
                }</span>
                <span class="cov0" title="0">if name, exists := GetUsername(c); exists </span><span class="cov0" title="0">{
                        username = &amp;name
                }</span>

                // Create detailed error log entry
                <span class="cov0" title="0">errorEntry := map[string]interface{}{
                        "timestamp":   time.Now(),
                        "request_id":  requestID,
                        "level":       "error",
                        "service":     "tiris-backend",
                        "type":        "panic_recovery",
                        "method":      c.Request.Method,
                        "path":        c.Request.URL.Path,
                        "client_ip":   c.ClientIP(),
                        "user_agent":  c.Request.UserAgent(),
                        "user_id":     userID,
                        "username":    username,
                        "panic_value": recovered,
                }

                // Log the error
                errorJSON, err := json.Marshal(errorEntry)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to marshal error entry: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        log.Println(string(errorJSON))
                }</span>

                // Return 500 error
                <span class="cov0" title="0">c.JSON(500, gin.H{
                        "success": false,
                        "error": gin.H{
                                "code":       "INTERNAL_ERROR",
                                "message":    "Internal server error",
                                "request_id": requestID,
                        },
                })</span>
        })
}

// HealthCheckLoggingMiddleware provides minimal logging for health checks
func HealthCheckLoggingMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Skip detailed logging for health check endpoints
                if c.Request.URL.Path == "/health/live" || c.Request.URL.Path == "/health/ready" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Use standard logging for other endpoints
                <span class="cov0" title="0">LoggingMiddleware()(c)</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "strconv"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
)

// RateLimiter represents a token bucket rate limiter
type RateLimiter struct {
        tokens     int
        maxTokens  int
        refillRate time.Duration
        lastRefill time.Time
        mutex      sync.Mutex
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(maxTokens int, refillRate time.Duration) *RateLimiter <span class="cov0" title="0">{
        return &amp;RateLimiter{
                tokens:     maxTokens,
                maxTokens:  maxTokens,
                refillRate: refillRate,
                lastRefill: time.Now(),
        }
}</span>

// Allow checks if a request is allowed
func (rl *RateLimiter) Allow() bool <span class="cov0" title="0">{
        rl.mutex.Lock()
        defer rl.mutex.Unlock()

        // Refill tokens based on time elapsed
        now := time.Now()
        elapsed := now.Sub(rl.lastRefill)
        tokensToAdd := int(elapsed / rl.refillRate)

        if tokensToAdd &gt; 0 </span><span class="cov0" title="0">{
                rl.tokens += tokensToAdd
                if rl.tokens &gt; rl.maxTokens </span><span class="cov0" title="0">{
                        rl.tokens = rl.maxTokens
                }</span>
                <span class="cov0" title="0">rl.lastRefill = now</span>
        }

        // Check if we have tokens available
        <span class="cov0" title="0">if rl.tokens &gt; 0 </span><span class="cov0" title="0">{
                rl.tokens--
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// GetTokens returns the current number of available tokens
func (rl *RateLimiter) GetTokens() int <span class="cov0" title="0">{
        rl.mutex.Lock()
        defer rl.mutex.Unlock()
        return rl.tokens
}</span>

// RateLimitStore manages rate limiters for different keys
type RateLimitStore struct {
        limiters   map[string]*RateLimiter
        mutex      sync.RWMutex
        maxTokens  int
        refillRate time.Duration
}

// NewRateLimitStore creates a new rate limit store
func NewRateLimitStore(maxTokens int, refillRate time.Duration) *RateLimitStore <span class="cov0" title="0">{
        return &amp;RateLimitStore{
                limiters:   make(map[string]*RateLimiter),
                maxTokens:  maxTokens,
                refillRate: refillRate,
        }
}</span>

// GetLimiter gets or creates a rate limiter for a key
func (rls *RateLimitStore) GetLimiter(key string) *RateLimiter <span class="cov0" title="0">{
        rls.mutex.RLock()
        limiter, exists := rls.limiters[key]
        rls.mutex.RUnlock()

        if exists </span><span class="cov0" title="0">{
                return limiter
        }</span>

        // Create new limiter
        <span class="cov0" title="0">rls.mutex.Lock()
        defer rls.mutex.Unlock()

        // Check again in case another goroutine created it
        if limiter, exists := rls.limiters[key]; exists </span><span class="cov0" title="0">{
                return limiter
        }</span>

        <span class="cov0" title="0">limiter = NewRateLimiter(rls.maxTokens, rls.refillRate)
        rls.limiters[key] = limiter
        return limiter</span>
}

// RateLimitConfig represents rate limiting configuration
type RateLimitConfig struct {
        RequestsPerHour int                       // Maximum requests per hour
        WindowDuration  time.Duration             // Time window for rate limiting
        KeyFunc         func(*gin.Context) string // Function to generate rate limit key
}

// DefaultKeyFunc generates a rate limit key based on IP address
func DefaultKeyFunc(c *gin.Context) string <span class="cov0" title="0">{
        return c.ClientIP()
}</span>

// UserKeyFunc generates a rate limit key based on user ID
func UserKeyFunc(c *gin.Context) string <span class="cov0" title="0">{
        userID, exists := GetUserID(c)
        if exists </span><span class="cov0" title="0">{
                return fmt.Sprintf("user:%s", userID.String())
        }</span>
        <span class="cov0" title="0">return c.ClientIP()</span>
}

// EndpointKeyFunc generates a rate limit key based on endpoint and user/IP
func EndpointKeyFunc(c *gin.Context) string <span class="cov0" title="0">{
        endpoint := c.Request.Method + ":" + c.FullPath()
        userID, exists := GetUserID(c)
        if exists </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s:user:%s", endpoint, userID.String())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s:ip:%s", endpoint, c.ClientIP())</span>
}

// RateLimitMiddleware creates a rate limiting middleware
func RateLimitMiddleware(config RateLimitConfig) gin.HandlerFunc <span class="cov0" title="0">{
        if config.KeyFunc == nil </span><span class="cov0" title="0">{
                config.KeyFunc = DefaultKeyFunc
        }</span>

        <span class="cov0" title="0">if config.WindowDuration == 0 </span><span class="cov0" title="0">{
                config.WindowDuration = time.Hour
        }</span>

        // Calculate refill rate based on requests per hour
        <span class="cov0" title="0">refillRate := config.WindowDuration / time.Duration(config.RequestsPerHour)
        store := NewRateLimitStore(config.RequestsPerHour, refillRate)

        return func(c *gin.Context) </span><span class="cov0" title="0">{
                key := config.KeyFunc(c)
                limiter := store.GetLimiter(key)

                if !limiter.Allow() </span><span class="cov0" title="0">{
                        // Calculate reset time
                        resetTime := time.Now().Add(refillRate).Unix()

                        // Set rate limit headers
                        c.Header("X-RateLimit-Limit", strconv.Itoa(config.RequestsPerHour))
                        c.Header("X-RateLimit-Remaining", "0")
                        c.Header("X-RateLimit-Reset", strconv.FormatInt(resetTime, 10))
                        c.Header("X-RateLimit-Window", strconv.Itoa(int(config.WindowDuration.Seconds())))

                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "success": false,
                                "error": gin.H{
                                        "code":    "RATE_LIMIT_EXCEEDED",
                                        "message": "Rate limit exceeded. Please try again later.",
                                },
                        })
                        c.Abort()
                        return
                }</span>

                // Set rate limit headers for successful requests
                <span class="cov0" title="0">remaining := limiter.GetTokens()
                resetTime := time.Now().Add(refillRate).Unix()

                c.Header("X-RateLimit-Limit", strconv.Itoa(config.RequestsPerHour))
                c.Header("X-RateLimit-Remaining", strconv.Itoa(remaining))
                c.Header("X-RateLimit-Reset", strconv.FormatInt(resetTime, 10))
                c.Header("X-RateLimit-Window", strconv.Itoa(int(config.WindowDuration.Seconds())))

                c.Next()</span>
        }
}

// AuthRateLimitMiddleware applies specific rate limiting for authentication endpoints
func AuthRateLimitMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return RateLimitMiddleware(RateLimitConfig{
                RequestsPerHour: 60, // 60 requests per hour for auth endpoints
                WindowDuration:  time.Hour,
                KeyFunc: func(c *gin.Context) string </span><span class="cov0" title="0">{
                        return fmt.Sprintf("auth:%s", c.ClientIP())
                }</span>,
        })
}

// APIRateLimitMiddleware applies general rate limiting for API endpoints
func APIRateLimitMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return RateLimitMiddleware(RateLimitConfig{
                RequestsPerHour: 1000, // 1000 requests per hour for general API
                WindowDuration:  time.Hour,
                KeyFunc:         UserKeyFunc,
        })
}</span>

// TradingRateLimitMiddleware applies specific rate limiting for trading endpoints
func TradingRateLimitMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return RateLimitMiddleware(RateLimitConfig{
                RequestsPerHour: 600, // 600 requests per hour for trading operations
                WindowDuration:  time.Hour,
                KeyFunc: func(c *gin.Context) string </span><span class="cov0" title="0">{
                        userID, exists := GetUserID(c)
                        if exists </span><span class="cov0" title="0">{
                                return fmt.Sprintf("trading:user:%s", userID.String())
                        }</span>
                        <span class="cov0" title="0">return fmt.Sprintf("trading:ip:%s", c.ClientIP())</span>
                },
        })
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package nats

import (
        "context"
        "fmt"
        "log"
        "time"

        "tiris-backend/internal/config"

        "github.com/nats-io/nats.go"
)

// Client represents a NATS JetStream client
type Client struct {
        conn *nats.Conn
        js   nats.JetStreamContext
        cfg  config.NATSConfig
}

// NewClient creates a new NATS JetStream client
func NewClient(cfg config.NATSConfig) (*Client, error) <span class="cov0" title="0">{
        // Connect to NATS server
        opts := []nats.Option{
                nats.Name(cfg.ClientID),
                nats.ReconnectWait(2 * time.Second),
                nats.MaxReconnects(-1), // Reconnect indefinitely
                nats.DisconnectErrHandler(func(nc *nats.Conn, err error) </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("NATS disconnected: %v", err)
                        }</span> else<span class="cov0" title="0"> {
                                log.Println("NATS disconnected")
                        }</span>
                }),
                nats.ReconnectHandler(func(nc *nats.Conn) <span class="cov0" title="0">{
                        log.Printf("NATS reconnected to %v", nc.ConnectedUrl())
                }</span>),
                nats.ClosedHandler(func(nc *nats.Conn) <span class="cov0" title="0">{
                        log.Println("NATS connection closed")
                }</span>),
        }

        <span class="cov0" title="0">conn, err := nats.Connect(cfg.URL, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to NATS: %w", err)
        }</span>

        // Create JetStream context
        <span class="cov0" title="0">js, err := conn.JetStream()
        if err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to create JetStream context: %w", err)
        }</span>

        <span class="cov0" title="0">client := &amp;Client{
                conn: conn,
                js:   js,
                cfg:  cfg,
        }

        // Initialize streams
        if err := client.initializeStreams(); err != nil </span><span class="cov0" title="0">{
                client.Close()
                return nil, fmt.Errorf("failed to initialize streams: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("NATS JetStream client initialized successfully")
        return client, nil</span>
}

// Close closes the NATS connection
func (c *Client) Close() <span class="cov0" title="0">{
        if c.conn != nil </span><span class="cov0" title="0">{
                c.conn.Close()
                log.Println("NATS connection closed")
        }</span>
}

// Publish publishes a message to a subject
func (c *Client) Publish(subject string, data []byte) error <span class="cov0" title="0">{
        _, err := c.js.Publish(subject, data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to publish message to %s: %w", subject, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// PublishAsync publishes a message asynchronously
func (c *Client) PublishAsync(subject string, data []byte) (nats.PubAckFuture, error) <span class="cov0" title="0">{
        ack, err := c.js.PublishAsync(subject, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to publish async message to %s: %w", subject, err)
        }</span>
        <span class="cov0" title="0">return ack, nil</span>
}

// Subscribe creates a subscription to a subject
func (c *Client) Subscribe(subject string, handler nats.MsgHandler) (*nats.Subscription, error) <span class="cov0" title="0">{
        sub, err := c.js.Subscribe(subject, handler, nats.Durable(c.cfg.DurableName))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to subscribe to %s: %w", subject, err)
        }</span>
        <span class="cov0" title="0">return sub, nil</span>
}

// QueueSubscribe creates a queue subscription
func (c *Client) QueueSubscribe(subject, queue string, handler nats.MsgHandler) (*nats.Subscription, error) <span class="cov0" title="0">{
        sub, err := c.js.QueueSubscribe(subject, queue, handler, nats.Durable(c.cfg.DurableName))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to queue subscribe to %s: %w", subject, err)
        }</span>
        <span class="cov0" title="0">return sub, nil</span>
}

// GetStreamInfo returns information about a stream
func (c *Client) GetStreamInfo(streamName string) (*nats.StreamInfo, error) <span class="cov0" title="0">{
        info, err := c.js.StreamInfo(streamName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get stream info for %s: %w", streamName, err)
        }</span>
        <span class="cov0" title="0">return info, nil</span>
}

// GetConsumerInfo returns information about a consumer
func (c *Client) GetConsumerInfo(streamName, consumerName string) (*nats.ConsumerInfo, error) <span class="cov0" title="0">{
        info, err := c.js.ConsumerInfo(streamName, consumerName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get consumer info for %s/%s: %w", streamName, consumerName, err)
        }</span>
        <span class="cov0" title="0">return info, nil</span>
}

// HealthCheck checks the health of the NATS connection
func (c *Client) HealthCheck() error <span class="cov0" title="0">{
        if c.conn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NATS connection is nil")
        }</span>

        <span class="cov0" title="0">if !c.conn.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("NATS connection is not connected")
        }</span>

        // Test JetStream connectivity by getting account info
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := c.js.AccountInfo(nats.Context(ctx))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NATS JetStream health check failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// initializeStreams creates the required streams for the application
func (c *Client) initializeStreams() error <span class="cov0" title="0">{
        streams := []StreamConfig{
                {
                        Name:        "TRADING",
                        Description: "Trading events stream",
                        Subjects:    []string{"trading.orders.*", "trading.balance.*", "trading.signals.*"},
                        MaxAge:      24 * time.Hour * 30, // 30 days
                        Storage:     nats.FileStorage,
                        Replicas:    1,
                },
                {
                        Name:        "TRADING_ERRORS",
                        Description: "Trading error events stream",
                        Subjects:    []string{"trading.errors"},
                        MaxAge:      24 * time.Hour * 7, // 7 days
                        Storage:     nats.FileStorage,
                        Replicas:    1,
                },
                {
                        Name:        "SYSTEM",
                        Description: "System events stream",
                        Subjects:    []string{"system.*"},
                        MaxAge:      24 * time.Hour * 7, // 7 days
                        Storage:     nats.FileStorage,
                        Replicas:    1,
                },
        }

        for _, streamCfg := range streams </span><span class="cov0" title="0">{
                if err := c.createOrUpdateStream(streamCfg); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// StreamConfig represents a stream configuration
type StreamConfig struct {
        Name        string
        Description string
        Subjects    []string
        MaxAge      time.Duration
        Storage     nats.StorageType
        Replicas    int
}

// createOrUpdateStream creates or updates a stream
func (c *Client) createOrUpdateStream(cfg StreamConfig) error <span class="cov0" title="0">{
        streamConfig := &amp;nats.StreamConfig{
                Name:        cfg.Name,
                Description: cfg.Description,
                Subjects:    cfg.Subjects,
                MaxAge:      cfg.MaxAge,
                Storage:     cfg.Storage,
                Replicas:    cfg.Replicas,
        }

        // Try to get existing stream
        _, err := c.js.StreamInfo(cfg.Name)
        if err != nil </span><span class="cov0" title="0">{
                // Stream doesn't exist, create it
                _, err = c.js.AddStream(streamConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create stream %s: %w", cfg.Name, err)
                }</span>
                <span class="cov0" title="0">log.Printf("Created NATS stream: %s", cfg.Name)</span>
        } else<span class="cov0" title="0"> {
                // Stream exists, update it
                _, err = c.js.UpdateStream(streamConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update stream %s: %w", cfg.Name, err)
                }</span>
                <span class="cov0" title="0">log.Printf("Updated NATS stream: %s", cfg.Name)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package nats

import (
        "encoding/json"
        "fmt"
        "time"

        "tiris-backend/internal/models"

        "github.com/google/uuid"
        "gorm.io/datatypes"
)

// isEventProcessed checks if an event has already been processed
func (ec *EventConsumer) isEventProcessed(eventID string) (bool, error) <span class="cov0" title="0">{
        event, err := ec.repos.EventProcessing.GetByEventID(ec.ctx, eventID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return event != nil, nil</span>
}

// markEventAsProcessed marks an event as successfully processed
func (ec *EventConsumer) markEventAsProcessed(eventID, eventType string, userID *uuid.UUID, subAccountID *uuid.UUID) error <span class="cov0" title="0">{
        event := &amp;models.EventProcessing{
                EventID:      eventID,
                EventType:    eventType,
                UserID:       userID,
                SubAccountID: subAccountID,
                Status:       "processed",
                ProcessedAt:  time.Now(),
        }
        return ec.repos.EventProcessing.Create(ec.ctx, event)
}</span>

// createTradingLogFromOrderEvent creates a trading log entry from an order event
func (ec *EventConsumer) createTradingLogFromOrderEvent(event *OrderEvent) error <span class="cov0" title="0">{
        metadata, err := json.Marshal(map[string]interface{}{
                "order_id":          event.OrderID,
                "symbol":            event.Symbol,
                "side":              event.Side,
                "type":              event.Type,
                "amount":            event.Amount,
                "price":             event.Price,
                "status":            event.Status,
                "event_id":          event.EventID,
                "original_metadata": event.Metadata,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        <span class="cov0" title="0">log := &amp;models.TradingLog{
                UserID:       event.UserID,
                ExchangeID:   event.ExchangeID,
                SubAccountID: &amp;event.SubAccountID,
                Timestamp:    event.Timestamp,
                Type:         fmt.Sprintf("order_%s", getOrderAction(event.EventType)),
                Source:       "bot",
                Message:      event.Message,
                Info:         datatypes.JSON(metadata),
        }

        return ec.repos.TradingLog.Create(ec.ctx, log)</span>
}

// createTradingLogFromBalanceEvent creates a trading log entry from a balance event
func (ec *EventConsumer) createTradingLogFromBalanceEvent(event *BalanceEvent, transactionID *uuid.UUID) error <span class="cov0" title="0">{
        metadata, err := json.Marshal(map[string]interface{}{
                "symbol":            event.Symbol,
                "previous_balance":  event.PreviousBalance,
                "new_balance":       event.NewBalance,
                "amount":            event.Amount,
                "direction":         event.Direction,
                "reason":            event.Reason,
                "related_order_id":  event.RelatedOrderID,
                "event_id":          event.EventID,
                "original_metadata": event.Metadata,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        <span class="cov0" title="0">message := fmt.Sprintf("Balance updated: %s %f %s (was %f, now %f)",
                event.Direction, event.Amount, event.Symbol, event.PreviousBalance, event.NewBalance)

        log := &amp;models.TradingLog{
                UserID:        event.UserID,
                ExchangeID:    event.ExchangeID,
                SubAccountID:  &amp;event.SubAccountID,
                TransactionID: transactionID,
                Timestamp:     event.Timestamp,
                Type:          "balance_update",
                Source:        "bot",
                Message:       message,
                Info:          datatypes.JSON(metadata),
        }

        return ec.repos.TradingLog.Create(ec.ctx, log)</span>
}

// createTradingLogFromErrorEvent creates a trading log entry from an error event
func (ec *EventConsumer) createTradingLogFromErrorEvent(event *ErrorEvent) error <span class="cov0" title="0">{
        metadata, err := json.Marshal(map[string]interface{}{
                "error_code":        event.ErrorCode,
                "severity":          event.Severity,
                "component":         event.Component,
                "stack_trace":       event.StackTrace,
                "event_id":          event.EventID,
                "original_metadata": event.Metadata,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        <span class="cov0" title="0">message := fmt.Sprintf("[%s] %s: %s", event.Severity, event.Component, event.ErrorMessage)

        log := &amp;models.TradingLog{
                UserID:       event.UserID,
                ExchangeID:   event.ExchangeID,
                SubAccountID: event.SubAccountID,
                Timestamp:    event.Timestamp,
                Type:         "system_error",
                Source:       "bot",
                Message:      message,
                Info:         datatypes.JSON(metadata),
        }

        return ec.repos.TradingLog.Create(ec.ctx, log)</span>
}

// createTradingLogFromSignalEvent creates a trading log entry from a signal event
func (ec *EventConsumer) createTradingLogFromSignalEvent(event *SignalEvent) error <span class="cov0" title="0">{
        metadata, err := json.Marshal(map[string]interface{}{
                "signal_type":       event.SignalType,
                "symbol":            event.Symbol,
                "confidence":        event.Confidence,
                "price":             event.Price,
                "strategy":          event.Strategy,
                "reasoning":         event.Reasoning,
                "event_id":          event.EventID,
                "original_metadata": event.Metadata,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        <span class="cov0" title="0">message := fmt.Sprintf("Trading signal: %s %s (%.1f%% confidence) - %s",
                event.SignalType, event.Symbol, event.Confidence*100, event.Reasoning)

        log := &amp;models.TradingLog{
                UserID:       event.UserID,
                ExchangeID:   event.ExchangeID,
                SubAccountID: event.SubAccountID,
                Timestamp:    event.Timestamp,
                Type:         "trading_signal",
                Source:       "bot",
                Message:      message,
                Info:         datatypes.JSON(metadata),
        }

        return ec.repos.TradingLog.Create(ec.ctx, log)</span>
}

// getOrderAction extracts the action from order event type
func getOrderAction(eventType EventType) string <span class="cov0" title="0">{
        switch eventType </span>{
        case EventOrderCreated:<span class="cov0" title="0">
                return "created"</span>
        case EventOrderFilled:<span class="cov0" title="0">
                return "filled"</span>
        case EventOrderCancelled:<span class="cov0" title="0">
                return "cancelled"</span>
        case EventOrderFailed:<span class="cov0" title="0">
                return "failed"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package nats

import (
        "context"
        "encoding/json"
        "fmt"
        "log"

        "tiris-backend/internal/repositories"

        "github.com/nats-io/nats.go"
)

// EventConsumer manages event consumption from NATS streams
type EventConsumer struct {
        client *Client
        repos  *repositories.Repositories
        ctx    context.Context
        cancel context.CancelFunc
}

// NewEventConsumer creates a new event consumer
func NewEventConsumer(client *Client, repos *repositories.Repositories) *EventConsumer <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        return &amp;EventConsumer{
                client: client,
                repos:  repos,
                ctx:    ctx,
                cancel: cancel,
        }
}</span>

// Start starts consuming events from all streams
func (ec *EventConsumer) Start() error <span class="cov0" title="0">{
        log.Println("Starting NATS event consumers...")

        // Start order event consumer
        if err := ec.startOrderEventConsumer(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start order event consumer: %w", err)
        }</span>

        // Start balance event consumer
        <span class="cov0" title="0">if err := ec.startBalanceEventConsumer(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start balance event consumer: %w", err)
        }</span>

        // Start error event consumer
        <span class="cov0" title="0">if err := ec.startErrorEventConsumer(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start error event consumer: %w", err)
        }</span>

        // Start signal event consumer
        <span class="cov0" title="0">if err := ec.startSignalEventConsumer(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start signal event consumer: %w", err)
        }</span>

        // Start heartbeat event consumer
        <span class="cov0" title="0">if err := ec.startHeartbeatEventConsumer(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start heartbeat event consumer: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("All NATS event consumers started successfully")
        return nil</span>
}

// Stop stops all event consumers
func (ec *EventConsumer) Stop() <span class="cov0" title="0">{
        log.Println("Stopping NATS event consumers...")
        ec.cancel()
}</span>

// startOrderEventConsumer starts consuming order events
func (ec *EventConsumer) startOrderEventConsumer() error <span class="cov0" title="0">{
        subjects := []string{
                string(EventOrderCreated),
                string(EventOrderFilled),
                string(EventOrderCancelled),
                string(EventOrderFailed),
        }

        for _, subject := range subjects </span><span class="cov0" title="0">{
                _, err := ec.client.QueueSubscribe(subject, "order-processors", func(msg *nats.Msg) </span><span class="cov0" title="0">{
                        if err := ec.handleOrderEvent(msg); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error handling order event: %v", err)
                                // Negative acknowledgment will cause redelivery
                                msg.Nak()
                        }</span> else<span class="cov0" title="0"> {
                                msg.Ack()
                        }</span>
                })
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to subscribe to %s: %w", subject, err)
                }</span>
                <span class="cov0" title="0">log.Printf("Subscribed to order events: %s", subject)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// startBalanceEventConsumer starts consuming balance events
func (ec *EventConsumer) startBalanceEventConsumer() error <span class="cov0" title="0">{
        subjects := []string{
                string(EventBalanceUpdated),
                string(EventBalanceLocked),
                string(EventBalanceUnlocked),
        }

        for _, subject := range subjects </span><span class="cov0" title="0">{
                _, err := ec.client.QueueSubscribe(subject, "balance-processors", func(msg *nats.Msg) </span><span class="cov0" title="0">{
                        if err := ec.handleBalanceEvent(msg); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error handling balance event: %v", err)
                                msg.Nak()
                        }</span> else<span class="cov0" title="0"> {
                                msg.Ack()
                        }</span>
                })
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to subscribe to %s: %w", subject, err)
                }</span>
                <span class="cov0" title="0">log.Printf("Subscribed to balance events: %s", subject)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// startErrorEventConsumer starts consuming error events
func (ec *EventConsumer) startErrorEventConsumer() error <span class="cov0" title="0">{
        _, err := ec.client.QueueSubscribe(string(EventSystemError), "error-processors", func(msg *nats.Msg) </span><span class="cov0" title="0">{
                if err := ec.handleErrorEvent(msg); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error handling error event: %v", err)
                        msg.Nak()
                }</span> else<span class="cov0" title="0"> {
                        msg.Ack()
                }</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to subscribe to error events: %w", err)
        }</span>
        <span class="cov0" title="0">log.Printf("Subscribed to error events: %s", EventSystemError)

        return nil</span>
}

// startSignalEventConsumer starts consuming signal events
func (ec *EventConsumer) startSignalEventConsumer() error <span class="cov0" title="0">{
        _, err := ec.client.QueueSubscribe(string(EventSignalGenerated), "signal-processors", func(msg *nats.Msg) </span><span class="cov0" title="0">{
                if err := ec.handleSignalEvent(msg); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error handling signal event: %v", err)
                        msg.Nak()
                }</span> else<span class="cov0" title="0"> {
                        msg.Ack()
                }</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to subscribe to signal events: %w", err)
        }</span>
        <span class="cov0" title="0">log.Printf("Subscribed to signal events: %s", EventSignalGenerated)

        return nil</span>
}

// startHeartbeatEventConsumer starts consuming heartbeat events
func (ec *EventConsumer) startHeartbeatEventConsumer() error <span class="cov0" title="0">{
        _, err := ec.client.QueueSubscribe(string(EventBotHeartbeat), "heartbeat-processors", func(msg *nats.Msg) </span><span class="cov0" title="0">{
                if err := ec.handleHeartbeatEvent(msg); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error handling heartbeat event: %v", err)
                        msg.Nak()
                }</span> else<span class="cov0" title="0"> {
                        msg.Ack()
                }</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to subscribe to heartbeat events: %w", err)
        }</span>
        <span class="cov0" title="0">log.Printf("Subscribed to heartbeat events: %s", EventBotHeartbeat)

        return nil</span>
}

// handleOrderEvent processes order events
func (ec *EventConsumer) handleOrderEvent(msg *nats.Msg) error <span class="cov0" title="0">{
        var event OrderEvent
        if err := json.Unmarshal(msg.Data, &amp;event); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal order event: %w", err)
        }</span>

        // Check for duplicate event
        <span class="cov0" title="0">if exists, err := ec.isEventProcessed(event.EventID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check event deduplication: %w", err)
        }</span> else<span class="cov0" title="0"> if exists </span><span class="cov0" title="0">{
                log.Printf("Skipping duplicate order event: %s", event.EventID)
                return nil
        }</span>

        // Process the order event
        <span class="cov0" title="0">log.Printf("Processing order event: %s - %s - %s", event.EventType, event.OrderID, event.Status)

        // Create trading log entry
        if err := ec.createTradingLogFromOrderEvent(&amp;event); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create trading log: %w", err)
        }</span>

        // Mark event as processed
        <span class="cov0" title="0">if err := ec.markEventAsProcessed(event.EventID, string(event.EventType), &amp;event.UserID, &amp;event.SubAccountID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark event as processed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleBalanceEvent processes balance events
func (ec *EventConsumer) handleBalanceEvent(msg *nats.Msg) error <span class="cov0" title="0">{
        var event BalanceEvent
        if err := json.Unmarshal(msg.Data, &amp;event); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal balance event: %w", err)
        }</span>

        // Check for duplicate event
        <span class="cov0" title="0">if exists, err := ec.isEventProcessed(event.EventID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check event deduplication: %w", err)
        }</span> else<span class="cov0" title="0"> if exists </span><span class="cov0" title="0">{
                log.Printf("Skipping duplicate balance event: %s", event.EventID)
                return nil
        }</span>

        // Process the balance event
        <span class="cov0" title="0">log.Printf("Processing balance event: %s - %s - %f -&gt; %f",
                event.EventType, event.Symbol, event.PreviousBalance, event.NewBalance)

        // Update balance and create transaction
        transactionID, err := ec.repos.SubAccount.UpdateBalance(
                ec.ctx,
                event.SubAccountID,
                event.NewBalance,
                event.Amount,
                event.Direction,
                event.Reason,
                event.Metadata,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update balance: %w", err)
        }</span>

        // Create trading log entry
        <span class="cov0" title="0">if err := ec.createTradingLogFromBalanceEvent(&amp;event, transactionID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create trading log: %w", err)
        }</span>

        // Mark event as processed
        <span class="cov0" title="0">if err := ec.markEventAsProcessed(event.EventID, string(event.EventType), &amp;event.UserID, &amp;event.SubAccountID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark event as processed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleErrorEvent processes error events
func (ec *EventConsumer) handleErrorEvent(msg *nats.Msg) error <span class="cov0" title="0">{
        var event ErrorEvent
        if err := json.Unmarshal(msg.Data, &amp;event); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal error event: %w", err)
        }</span>

        // Check for duplicate event
        <span class="cov0" title="0">if exists, err := ec.isEventProcessed(event.EventID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check event deduplication: %w", err)
        }</span> else<span class="cov0" title="0"> if exists </span><span class="cov0" title="0">{
                log.Printf("Skipping duplicate error event: %s", event.EventID)
                return nil
        }</span>

        // Process the error event
        <span class="cov0" title="0">log.Printf("Processing error event: %s - %s - %s", event.EventType, event.Severity, event.ErrorMessage)

        // Create trading log entry for error
        if err := ec.createTradingLogFromErrorEvent(&amp;event); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create trading log: %w", err)
        }</span>

        // Mark event as processed
        <span class="cov0" title="0">if err := ec.markEventAsProcessed(event.EventID, string(event.EventType), &amp;event.UserID, event.SubAccountID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark event as processed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleSignalEvent processes signal events
func (ec *EventConsumer) handleSignalEvent(msg *nats.Msg) error <span class="cov0" title="0">{
        var event SignalEvent
        if err := json.Unmarshal(msg.Data, &amp;event); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal signal event: %w", err)
        }</span>

        // Check for duplicate event
        <span class="cov0" title="0">if exists, err := ec.isEventProcessed(event.EventID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check event deduplication: %w", err)
        }</span> else<span class="cov0" title="0"> if exists </span><span class="cov0" title="0">{
                log.Printf("Skipping duplicate signal event: %s", event.EventID)
                return nil
        }</span>

        // Process the signal event
        <span class="cov0" title="0">log.Printf("Processing signal event: %s - %s - %s - %.2f confidence",
                event.EventType, event.SignalType, event.Symbol, event.Confidence)

        // Create trading log entry for signal
        if err := ec.createTradingLogFromSignalEvent(&amp;event); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create trading log: %w", err)
        }</span>

        // Mark event as processed
        <span class="cov0" title="0">if err := ec.markEventAsProcessed(event.EventID, string(event.EventType), &amp;event.UserID, event.SubAccountID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark event as processed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleHeartbeatEvent processes heartbeat events
func (ec *EventConsumer) handleHeartbeatEvent(msg *nats.Msg) error <span class="cov0" title="0">{
        var event HeartbeatEvent
        if err := json.Unmarshal(msg.Data, &amp;event); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal heartbeat event: %w", err)
        }</span>

        // Check for duplicate event (though heartbeats are typically not critical to deduplicate)
        <span class="cov0" title="0">if exists, err := ec.isEventProcessed(event.EventID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check event deduplication: %w", err)
        }</span> else<span class="cov0" title="0"> if exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Process the heartbeat event
        <span class="cov0" title="0">log.Printf("Processing heartbeat event: %s - %s - %s", event.EventType, event.Component, event.Status)

        // Mark event as processed
        if err := ec.markEventAsProcessed(event.EventID, string(event.EventType), &amp;event.UserID, nil); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark event as processed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package nats

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"
)

// EventType represents the type of trading event
type EventType string

const (
        // Order Events
        EventOrderCreated   EventType = "trading.orders.created"
        EventOrderFilled    EventType = "trading.orders.filled"
        EventOrderCancelled EventType = "trading.orders.cancelled"
        EventOrderFailed    EventType = "trading.orders.failed"

        // Balance Events
        EventBalanceUpdated  EventType = "trading.balance.updated"
        EventBalanceLocked   EventType = "trading.balance.locked"
        EventBalanceUnlocked EventType = "trading.balance.unlocked"

        // System Events
        EventSystemError     EventType = "trading.errors"
        EventSignalGenerated EventType = "trading.signals"
        EventBotHeartbeat    EventType = "system.heartbeat"
)

// BaseEvent represents the common fields for all events
type BaseEvent struct {
        EventID    string    `json:"event_id"`
        EventType  EventType `json:"event_type"`
        Timestamp  time.Time `json:"timestamp"`
        UserID     uuid.UUID `json:"user_id"`
        ExchangeID uuid.UUID `json:"exchange_id"`
        Source     string    `json:"source"` // "tiris-bot", "manual", etc.
        Version    string    `json:"version"`
}

// OrderEvent represents order-related events
type OrderEvent struct {
        BaseEvent
        SubAccountID uuid.UUID              `json:"sub_account_id"`
        OrderID      string                 `json:"order_id"`
        Symbol       string                 `json:"symbol"`
        Side         string                 `json:"side"` // "buy", "sell"
        Type         string                 `json:"type"` // "market", "limit", etc.
        Amount       float64                `json:"amount"`
        Price        *float64               `json:"price,omitempty"`
        Status       string                 `json:"status"`
        Message      string                 `json:"message"`
        Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

// BalanceEvent represents balance update events
type BalanceEvent struct {
        BaseEvent
        SubAccountID    uuid.UUID              `json:"sub_account_id"`
        Symbol          string                 `json:"symbol"`
        PreviousBalance float64                `json:"previous_balance"`
        NewBalance      float64                `json:"new_balance"`
        Amount          float64                `json:"amount"`
        Direction       string                 `json:"direction"` // "debit", "credit"
        Reason          string                 `json:"reason"`
        RelatedOrderID  *string                `json:"related_order_id,omitempty"`
        Metadata        map[string]interface{} `json:"metadata,omitempty"`
}

// ErrorEvent represents error events
type ErrorEvent struct {
        BaseEvent
        SubAccountID *uuid.UUID             `json:"sub_account_id,omitempty"`
        ErrorCode    string                 `json:"error_code"`
        ErrorMessage string                 `json:"error_message"`
        Severity     string                 `json:"severity"` // "low", "medium", "high", "critical"
        Component    string                 `json:"component"`
        StackTrace   *string                `json:"stack_trace,omitempty"`
        Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

// SignalEvent represents trading signal events
type SignalEvent struct {
        BaseEvent
        SubAccountID *uuid.UUID             `json:"sub_account_id,omitempty"`
        SignalType   string                 `json:"signal_type"` // "buy", "sell", "hold"
        Symbol       string                 `json:"symbol"`
        Confidence   float64                `json:"confidence"` // 0.0 to 1.0
        Price        *float64               `json:"price,omitempty"`
        Strategy     string                 `json:"strategy"`
        Reasoning    string                 `json:"reasoning"`
        Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

// HeartbeatEvent represents system heartbeat events
type HeartbeatEvent struct {
        BaseEvent
        Status    string                 `json:"status"` // "healthy", "degraded", "unhealthy"
        Component string                 `json:"component"`
        Metrics   map[string]interface{} `json:"metrics,omitempty"`
}

// NewBaseEvent creates a new base event with common fields
func NewBaseEvent(eventType EventType, userID, exchangeID uuid.UUID, source string) BaseEvent <span class="cov0" title="0">{
        return BaseEvent{
                EventID:    uuid.New().String(),
                EventType:  eventType,
                Timestamp:  time.Now().UTC(),
                UserID:     userID,
                ExchangeID: exchangeID,
                Source:     source,
                Version:    "1.0",
        }
}</span>

// NewOrderEvent creates a new order event
func NewOrderEvent(eventType EventType, userID, exchangeID, subAccountID uuid.UUID, source string) *OrderEvent <span class="cov0" title="0">{
        return &amp;OrderEvent{
                BaseEvent:    NewBaseEvent(eventType, userID, exchangeID, source),
                SubAccountID: subAccountID,
        }
}</span>

// NewBalanceEvent creates a new balance event
func NewBalanceEvent(userID, exchangeID, subAccountID uuid.UUID, source string) *BalanceEvent <span class="cov0" title="0">{
        return &amp;BalanceEvent{
                BaseEvent:    NewBaseEvent(EventBalanceUpdated, userID, exchangeID, source),
                SubAccountID: subAccountID,
        }
}</span>

// NewErrorEvent creates a new error event
func NewErrorEvent(userID, exchangeID uuid.UUID, source string) *ErrorEvent <span class="cov0" title="0">{
        return &amp;ErrorEvent{
                BaseEvent: NewBaseEvent(EventSystemError, userID, exchangeID, source),
        }
}</span>

// NewSignalEvent creates a new signal event
func NewSignalEvent(userID, exchangeID uuid.UUID, source string) *SignalEvent <span class="cov0" title="0">{
        return &amp;SignalEvent{
                BaseEvent: NewBaseEvent(EventSignalGenerated, userID, exchangeID, source),
        }
}</span>

// NewHeartbeatEvent creates a new heartbeat event
func NewHeartbeatEvent(userID, exchangeID uuid.UUID, source, component string) *HeartbeatEvent <span class="cov0" title="0">{
        return &amp;HeartbeatEvent{
                BaseEvent: NewBaseEvent(EventBotHeartbeat, userID, exchangeID, source),
                Component: component,
        }
}</span>

// MarshalEvent marshals an event to JSON
func MarshalEvent(event interface{}) ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(event)
}</span>

// UnmarshalEvent unmarshals JSON data to the appropriate event type
func UnmarshalEvent(data []byte, eventType EventType) (interface{}, error) <span class="cov0" title="0">{
        switch eventType </span>{
        case EventOrderCreated, EventOrderFilled, EventOrderCancelled, EventOrderFailed:<span class="cov0" title="0">
                var event OrderEvent
                err := json.Unmarshal(data, &amp;event)
                return &amp;event, err</span>

        case EventBalanceUpdated, EventBalanceLocked, EventBalanceUnlocked:<span class="cov0" title="0">
                var event BalanceEvent
                err := json.Unmarshal(data, &amp;event)
                return &amp;event, err</span>

        case EventSystemError:<span class="cov0" title="0">
                var event ErrorEvent
                err := json.Unmarshal(data, &amp;event)
                return &amp;event, err</span>

        case EventSignalGenerated:<span class="cov0" title="0">
                var event SignalEvent
                err := json.Unmarshal(data, &amp;event)
                return &amp;event, err</span>

        case EventBotHeartbeat:<span class="cov0" title="0">
                var event HeartbeatEvent
                err := json.Unmarshal(data, &amp;event)
                return &amp;event, err</span>

        default:<span class="cov0" title="0">
                var event BaseEvent
                err := json.Unmarshal(data, &amp;event)
                return &amp;event, err</span>
        }
}

// GetSubject returns the NATS subject for an event type
func GetSubject(eventType EventType) string <span class="cov0" title="0">{
        return string(eventType)
}</span>

// ValidateEvent performs basic validation on an event
func ValidateEvent(event interface{}) error <span class="cov0" title="0">{
        switch e := event.(type) </span>{
        case *OrderEvent:<span class="cov0" title="0">
                if e.EventID == "" || e.UserID == uuid.Nil || e.ExchangeID == uuid.Nil || e.SubAccountID == uuid.Nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing required fields in OrderEvent")
                }</span>
        case *BalanceEvent:<span class="cov0" title="0">
                if e.EventID == "" || e.UserID == uuid.Nil || e.ExchangeID == uuid.Nil || e.SubAccountID == uuid.Nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing required fields in BalanceEvent")
                }</span>
        case *ErrorEvent:<span class="cov0" title="0">
                if e.EventID == "" || e.UserID == uuid.Nil || e.ExchangeID == uuid.Nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing required fields in ErrorEvent")
                }</span>
        case *SignalEvent:<span class="cov0" title="0">
                if e.EventID == "" || e.UserID == uuid.Nil || e.ExchangeID == uuid.Nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing required fields in SignalEvent")
                }</span>
        case *HeartbeatEvent:<span class="cov0" title="0">
                if e.EventID == "" || e.UserID == uuid.Nil || e.ExchangeID == uuid.Nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing required fields in HeartbeatEvent")
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown event type")</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package nats

import (
        "fmt"
        "log"

        "tiris-backend/internal/config"
        "tiris-backend/internal/repositories"
)

// Manager manages NATS client and event consumers
type Manager struct {
        client   *Client
        consumer *EventConsumer
        cfg      config.NATSConfig
}

// NewManager creates a new NATS manager
func NewManager(cfg config.NATSConfig, repos *repositories.Repositories) (*Manager, error) <span class="cov0" title="0">{
        // Create NATS client
        client, err := NewClient(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create NATS client: %w", err)
        }</span>

        // Create event consumer
        <span class="cov0" title="0">consumer := NewEventConsumer(client, repos)

        return &amp;Manager{
                client:   client,
                consumer: consumer,
                cfg:      cfg,
        }, nil</span>
}

// Start starts the NATS manager and begins consuming events
func (m *Manager) Start() error <span class="cov0" title="0">{
        log.Println("Starting NATS manager...")

        // Start consuming events
        if err := m.consumer.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start event consumer: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("NATS manager started successfully")
        return nil</span>
}

// Stop stops the NATS manager and closes connections
func (m *Manager) Stop() <span class="cov0" title="0">{
        log.Println("Stopping NATS manager...")

        if m.consumer != nil </span><span class="cov0" title="0">{
                m.consumer.Stop()
        }</span>

        <span class="cov0" title="0">if m.client != nil </span><span class="cov0" title="0">{
                m.client.Close()
        }</span>

        <span class="cov0" title="0">log.Println("NATS manager stopped")</span>
}

// GetClient returns the NATS client for publishing events
func (m *Manager) GetClient() *Client <span class="cov0" title="0">{
        return m.client
}</span>

// HealthCheck performs a health check on the NATS connection
func (m *Manager) HealthCheck() error <span class="cov0" title="0">{
        if m.client == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NATS client is not initialized")
        }</span>
        <span class="cov0" title="0">return m.client.HealthCheck()</span>
}

// IsConnected returns true if the NATS connection is active
func (m *Manager) IsConnected() bool <span class="cov0" title="0">{
        if m.client == nil || m.client.conn == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return m.client.conn.IsConnected()</span>
}

// GetConnectionStats returns detailed connection statistics
func (m *Manager) GetConnectionStats() map[string]interface{} <span class="cov0" title="0">{
        if m.client == nil || m.client.conn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">stats := m.client.conn.Stats()
        return map[string]interface{}{
                "connected_url":     m.client.conn.ConnectedUrl(),
                "client_id":         m.client.conn.Opts.Name,
                "discovered_urls":   m.client.conn.DiscoveredServers(),
                "bytes_sent":        stats.OutBytes,
                "bytes_received":    stats.InBytes,
                "messages_sent":     stats.OutMsgs,
                "messages_received": stats.InMsgs,
                "reconnects":        stats.Reconnects,
                "last_error":        func() string </span><span class="cov0" title="0">{
                        if err := m.client.conn.LastError(); err != nil </span><span class="cov0" title="0">{
                                return err.Error()
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                }(),
        }
}

// PublishEvent publishes an event to the appropriate stream
func (m *Manager) PublishEvent(event interface{}) error <span class="cov0" title="0">{
        if m.client == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NATS client is not initialized")
        }</span>

        // Validate the event
        <span class="cov0" title="0">if err := ValidateEvent(event); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("event validation failed: %w", err)
        }</span>

        // Marshal the event
        <span class="cov0" title="0">data, err := MarshalEvent(event)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal event: %w", err)
        }</span>

        // Determine the subject based on event type
        <span class="cov0" title="0">var subject string
        switch e := event.(type) </span>{
        case *OrderEvent:<span class="cov0" title="0">
                subject = GetSubject(e.EventType)</span>
        case *BalanceEvent:<span class="cov0" title="0">
                subject = GetSubject(e.EventType)</span>
        case *ErrorEvent:<span class="cov0" title="0">
                subject = GetSubject(e.EventType)</span>
        case *SignalEvent:<span class="cov0" title="0">
                subject = GetSubject(e.EventType)</span>
        case *HeartbeatEvent:<span class="cov0" title="0">
                subject = GetSubject(e.EventType)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown event type")</span>
        }

        // Publish the event
        <span class="cov0" title="0">return m.client.Publish(subject, data)</span>
}

// PublishEventAsync publishes an event asynchronously
func (m *Manager) PublishEventAsync(event interface{}) error <span class="cov0" title="0">{
        if m.client == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("NATS client is not initialized")
        }</span>

        // Validate the event
        <span class="cov0" title="0">if err := ValidateEvent(event); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("event validation failed: %w", err)
        }</span>

        // Marshal the event
        <span class="cov0" title="0">data, err := MarshalEvent(event)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal event: %w", err)
        }</span>

        // Determine the subject based on event type
        <span class="cov0" title="0">var subject string
        switch e := event.(type) </span>{
        case *OrderEvent:<span class="cov0" title="0">
                subject = GetSubject(e.EventType)</span>
        case *BalanceEvent:<span class="cov0" title="0">
                subject = GetSubject(e.EventType)</span>
        case *ErrorEvent:<span class="cov0" title="0">
                subject = GetSubject(e.EventType)</span>
        case *SignalEvent:<span class="cov0" title="0">
                subject = GetSubject(e.EventType)</span>
        case *HeartbeatEvent:<span class="cov0" title="0">
                subject = GetSubject(e.EventType)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown event type")</span>
        }

        // Publish the event asynchronously
        <span class="cov0" title="0">_, err = m.client.PublishAsync(subject, data)
        return err</span>
}

// GetStreamInfo returns information about a stream
func (m *Manager) GetStreamInfo(streamName string) (interface{}, error) <span class="cov0" title="0">{
        if m.client == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("NATS client is not initialized")
        }</span>
        <span class="cov0" title="0">return m.client.GetStreamInfo(streamName)</span>
}

// GetConsumerInfo returns information about a consumer
func (m *Manager) GetConsumerInfo(streamName, consumerName string) (interface{}, error) <span class="cov0" title="0">{
        if m.client == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("NATS client is not initialized")
        }</span>
        <span class="cov0" title="0">return m.client.GetConsumerInfo(streamName, consumerName)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package repositories

import (
        "context"
        "errors"
        "time"

        "tiris-backend/internal/models"

        "gorm.io/gorm"
)

type eventProcessingRepository struct {
        db *gorm.DB
}

// NewEventProcessingRepository creates a new event processing repository instance
func NewEventProcessingRepository(db *gorm.DB) EventProcessingRepository <span class="cov0" title="0">{
        return &amp;eventProcessingRepository{db: db}
}</span>

func (r *eventProcessingRepository) Create(ctx context.Context, event *models.EventProcessing) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(event).Error
}</span>

func (r *eventProcessingRepository) GetByEventID(ctx context.Context, eventID string) (*models.EventProcessing, error) <span class="cov0" title="0">{
        var event models.EventProcessing
        err := r.db.WithContext(ctx).Where("event_id = ?", eventID).First(&amp;event).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;event, nil</span>
}

func (r *eventProcessingRepository) GetByEventType(ctx context.Context, eventType string, filters EventProcessingFilters) ([]*models.EventProcessing, int64, error) <span class="cov0" title="0">{
        var events []*models.EventProcessing
        var total int64

        // Build base query
        query := r.db.WithContext(ctx).Model(&amp;models.EventProcessing{}).Where("event_type = ?", eventType)

        // Apply filters
        if filters.Status != nil </span><span class="cov0" title="0">{
                query = query.Where("status = ?", *filters.Status)
        }</span>
        <span class="cov0" title="0">if filters.StartDate != nil </span><span class="cov0" title="0">{
                query = query.Where("processed_at &gt;= ?", *filters.StartDate)
        }</span>
        <span class="cov0" title="0">if filters.EndDate != nil </span><span class="cov0" title="0">{
                query = query.Where("processed_at &lt;= ?", *filters.EndDate)
        }</span>

        // Get total count
        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Apply pagination and ordering
        <span class="cov0" title="0">if filters.Limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(filters.Limit)
        }</span>
        <span class="cov0" title="0">if filters.Offset &gt; 0 </span><span class="cov0" title="0">{
                query = query.Offset(filters.Offset)
        }</span>

        <span class="cov0" title="0">err := query.Order("processed_at DESC").Find(&amp;events).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return events, total, nil</span>
}

func (r *eventProcessingRepository) Update(ctx context.Context, event *models.EventProcessing) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(event).Error
}</span>

func (r *eventProcessingRepository) MarkAsProcessed(ctx context.Context, eventID string) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).
                Model(&amp;models.EventProcessing{}).
                Where("event_id = ?", eventID).
                Updates(map[string]interface{}{
                        "status":       "processed",
                        "processed_at": time.Now(),
                }).Error
}</span>

func (r *eventProcessingRepository) MarkAsFailed(ctx context.Context, eventID string, errorMessage string, retryCount int) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).
                Model(&amp;models.EventProcessing{}).
                Where("event_id = ?", eventID).
                Updates(map[string]interface{}{
                        "status":        "failed",
                        "error_message": errorMessage,
                        "retry_count":   retryCount,
                        "processed_at":  time.Now(),
                }).Error
}</span>

func (r *eventProcessingRepository) GetFailedEvents(ctx context.Context, maxRetries int) ([]*models.EventProcessing, error) <span class="cov0" title="0">{
        var events []*models.EventProcessing
        err := r.db.WithContext(ctx).
                Where("status = ? AND retry_count &lt; ?", "failed", maxRetries).
                Order("processed_at ASC").
                Find(&amp;events).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return events, nil</span>
}

func (r *eventProcessingRepository) DeleteOldEvents(ctx context.Context, olderThan time.Time) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).
                Where("processed_at &lt; ? AND status = ?", olderThan, "processed").
                Delete(&amp;models.EventProcessing{}).Error
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package repositories

import (
        "context"
        "errors"

        "tiris-backend/internal/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

type exchangeRepository struct {
        db *gorm.DB
}

// NewExchangeRepository creates a new exchange repository instance
func NewExchangeRepository(db *gorm.DB) ExchangeRepository <span class="cov0" title="0">{
        return &amp;exchangeRepository{db: db}
}</span>

func (r *exchangeRepository) Create(ctx context.Context, exchange *models.Exchange) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(exchange).Error
}</span>

func (r *exchangeRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.Exchange, error) <span class="cov0" title="0">{
        var exchange models.Exchange
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;exchange).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;exchange, nil</span>
}

func (r *exchangeRepository) GetByUserID(ctx context.Context, userID uuid.UUID) ([]*models.Exchange, error) <span class="cov0" title="0">{
        var exchanges []*models.Exchange
        err := r.db.WithContext(ctx).
                Where("user_id = ?", userID).
                Order("created_at DESC").
                Find(&amp;exchanges).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return exchanges, nil</span>
}

func (r *exchangeRepository) GetByUserIDAndType(ctx context.Context, userID uuid.UUID, exchangeType string) ([]*models.Exchange, error) <span class="cov0" title="0">{
        var exchanges []*models.Exchange
        err := r.db.WithContext(ctx).
                Where("user_id = ? AND type = ?", userID, exchangeType).
                Order("created_at DESC").
                Find(&amp;exchanges).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return exchanges, nil</span>
}

func (r *exchangeRepository) Update(ctx context.Context, exchange *models.Exchange) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(exchange).Error
}</span>

func (r *exchangeRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // Check if there are any sub-accounts associated with this exchange
        var count int64
        if err := r.db.WithContext(ctx).Model(&amp;models.SubAccount{}).Where("exchange_id = ?", id).Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                return errors.New("cannot delete exchange with existing sub-accounts")
        }</span>

        <span class="cov0" title="0">return r.db.WithContext(ctx).Delete(&amp;models.Exchange{}, id).Error</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package repositories

import (
        "context"
        "errors"

        "tiris-backend/internal/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

type oauthTokenRepository struct {
        db *gorm.DB
}

// NewOAuthTokenRepository creates a new OAuth token repository instance
func NewOAuthTokenRepository(db *gorm.DB) OAuthTokenRepository <span class="cov0" title="0">{
        return &amp;oauthTokenRepository{db: db}
}</span>

func (r *oauthTokenRepository) Create(ctx context.Context, token *models.OAuthToken) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(token).Error
}</span>

func (r *oauthTokenRepository) GetByUserIDAndProvider(ctx context.Context, userID uuid.UUID, provider string) (*models.OAuthToken, error) <span class="cov0" title="0">{
        var token models.OAuthToken
        err := r.db.WithContext(ctx).
                Where("user_id = ? AND provider = ?", userID, provider).
                First(&amp;token).Error

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;token, nil</span>
}

func (r *oauthTokenRepository) GetByProviderUserID(ctx context.Context, provider, providerUserID string) (*models.OAuthToken, error) <span class="cov0" title="0">{
        var token models.OAuthToken
        err := r.db.WithContext(ctx).
                Where("provider = ? AND provider_user_id = ?", provider, providerUserID).
                First(&amp;token).Error

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;token, nil</span>
}

func (r *oauthTokenRepository) Update(ctx context.Context, token *models.OAuthToken) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(token).Error
}</span>

func (r *oauthTokenRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;models.OAuthToken{}, id).Error
}</span>

func (r *oauthTokenRepository) DeleteByUserID(ctx context.Context, userID uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Where("user_id = ?", userID).Delete(&amp;models.OAuthToken{}).Error
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package repositories

import (
        "gorm.io/gorm"
)

// Repositories contains all repository instances
type Repositories struct {
        User            UserRepository
        OAuthToken      OAuthTokenRepository
        Exchange        ExchangeRepository
        SubAccount      SubAccountRepository
        Transaction     TransactionRepository
        TradingLog      TradingLogRepository
        EventProcessing EventProcessingRepository
}

// NewRepositories creates a new repository container with all repositories
func NewRepositories(db *gorm.DB) *Repositories <span class="cov0" title="0">{
        return &amp;Repositories{
                User:            NewUserRepository(db),
                OAuthToken:      NewOAuthTokenRepository(db),
                Exchange:        NewExchangeRepository(db),
                SubAccount:      NewSubAccountRepository(db),
                Transaction:     NewTransactionRepository(db),
                TradingLog:      NewTradingLogRepository(db),
                EventProcessing: NewEventProcessingRepository(db),
        }
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package repositories

import (
        "context"
        "encoding/json"
        "errors"

        "tiris-backend/internal/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

type subAccountRepository struct {
        db *gorm.DB
}

// NewSubAccountRepository creates a new sub-account repository instance
func NewSubAccountRepository(db *gorm.DB) SubAccountRepository <span class="cov0" title="0">{
        return &amp;subAccountRepository{db: db}
}</span>

func (r *subAccountRepository) Create(ctx context.Context, subAccount *models.SubAccount) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(subAccount).Error
}</span>

func (r *subAccountRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.SubAccount, error) <span class="cov0" title="0">{
        var subAccount models.SubAccount
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;subAccount).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;subAccount, nil</span>
}

func (r *subAccountRepository) GetByUserID(ctx context.Context, userID uuid.UUID, exchangeID *uuid.UUID) ([]*models.SubAccount, error) <span class="cov0" title="0">{
        var subAccounts []*models.SubAccount
        query := r.db.WithContext(ctx).Where("user_id = ?", userID)

        if exchangeID != nil </span><span class="cov0" title="0">{
                query = query.Where("exchange_id = ?", *exchangeID)
        }</span>

        <span class="cov0" title="0">err := query.Order("created_at DESC").Find(&amp;subAccounts).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return subAccounts, nil</span>
}

func (r *subAccountRepository) GetByExchangeID(ctx context.Context, exchangeID uuid.UUID) ([]*models.SubAccount, error) <span class="cov0" title="0">{
        var subAccounts []*models.SubAccount
        err := r.db.WithContext(ctx).
                Where("exchange_id = ?", exchangeID).
                Order("created_at DESC").
                Find(&amp;subAccounts).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return subAccounts, nil</span>
}

func (r *subAccountRepository) GetBySymbol(ctx context.Context, userID uuid.UUID, symbol string) ([]*models.SubAccount, error) <span class="cov0" title="0">{
        var subAccounts []*models.SubAccount
        err := r.db.WithContext(ctx).
                Where("user_id = ? AND symbol = ?", userID, symbol).
                Order("created_at DESC").
                Find(&amp;subAccounts).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return subAccounts, nil</span>
}

func (r *subAccountRepository) Update(ctx context.Context, subAccount *models.SubAccount) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(subAccount).Error
}</span>

func (r *subAccountRepository) UpdateBalance(ctx context.Context, subAccountID uuid.UUID, newBalance float64, amount float64, direction, reason string, info interface{}) (*uuid.UUID, error) <span class="cov0" title="0">{
        // Convert info to JSON string if it's not already
        var infoJSON string
        if info != nil </span><span class="cov0" title="0">{
                if str, ok := info.(string); ok </span><span class="cov0" title="0">{
                        infoJSON = str
                }</span> else<span class="cov0" title="0"> {
                        infoBytes, err := json.Marshal(info)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">infoJSON = string(infoBytes)</span>
                }
        } else<span class="cov0" title="0"> {
                infoJSON = "{}"
        }</span>

        // Call the database function
        <span class="cov0" title="0">var transactionID uuid.UUID
        err := r.db.WithContext(ctx).Raw(
                "SELECT update_sub_account_balance(?, ?, ?, ?, ?, ?::jsonb)",
                subAccountID, newBalance, amount, direction, reason, infoJSON,
        ).Scan(&amp;transactionID).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;transactionID, nil</span>
}

func (r *subAccountRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // First check if balance is zero
        var subAccount models.SubAccount
        if err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;subAccount).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if subAccount.Balance != 0 </span><span class="cov0" title="0">{
                return errors.New("cannot delete sub-account with non-zero balance")
        }</span>

        <span class="cov0" title="0">return r.db.WithContext(ctx).Delete(&amp;models.SubAccount{}, id).Error</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package repositories

import (
        "context"
        "errors"
        "time"

        "tiris-backend/internal/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

type tradingLogRepository struct {
        db *gorm.DB
}

// NewTradingLogRepository creates a new trading log repository instance
func NewTradingLogRepository(db *gorm.DB) TradingLogRepository <span class="cov0" title="0">{
        return &amp;tradingLogRepository{db: db}
}</span>

func (r *tradingLogRepository) Create(ctx context.Context, log *models.TradingLog) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(log).Error
}</span>

func (r *tradingLogRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.TradingLog, error) <span class="cov0" title="0">{
        var log models.TradingLog
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;log).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;log, nil</span>
}

func (r *tradingLogRepository) GetByUserID(ctx context.Context, userID uuid.UUID, filters TradingLogFilters) ([]*models.TradingLog, int64, error) <span class="cov0" title="0">{
        return r.getTradingLogs(ctx, filters, "user_id = ?", userID)
}</span>

func (r *tradingLogRepository) GetBySubAccountID(ctx context.Context, subAccountID uuid.UUID, filters TradingLogFilters) ([]*models.TradingLog, int64, error) <span class="cov0" title="0">{
        return r.getTradingLogs(ctx, filters, "sub_account_id = ?", subAccountID)
}</span>

func (r *tradingLogRepository) GetByExchangeID(ctx context.Context, exchangeID uuid.UUID, filters TradingLogFilters) ([]*models.TradingLog, int64, error) <span class="cov0" title="0">{
        return r.getTradingLogs(ctx, filters, "exchange_id = ?", exchangeID)
}</span>

func (r *tradingLogRepository) GetByTimeRange(ctx context.Context, startTime, endTime time.Time, filters TradingLogFilters) ([]*models.TradingLog, int64, error) <span class="cov0" title="0">{
        return r.getTradingLogs(ctx, filters, "timestamp BETWEEN ? AND ?", startTime, endTime)
}</span>

func (r *tradingLogRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;models.TradingLog{}, id).Error
}</span>

func (r *tradingLogRepository) getTradingLogs(ctx context.Context, filters TradingLogFilters, whereClause string, whereArgs ...interface{}) ([]*models.TradingLog, int64, error) <span class="cov0" title="0">{
        var logs []*models.TradingLog
        var total int64

        // Build base query
        query := r.db.WithContext(ctx).Model(&amp;models.TradingLog{}).Where(whereClause, whereArgs...)

        // Apply filters
        if filters.Type != nil </span><span class="cov0" title="0">{
                query = query.Where("type = ?", *filters.Type)
        }</span>
        <span class="cov0" title="0">if filters.Source != nil </span><span class="cov0" title="0">{
                query = query.Where("source = ?", *filters.Source)
        }</span>
        <span class="cov0" title="0">if filters.StartDate != nil </span><span class="cov0" title="0">{
                query = query.Where("timestamp &gt;= ?", *filters.StartDate)
        }</span>
        <span class="cov0" title="0">if filters.EndDate != nil </span><span class="cov0" title="0">{
                query = query.Where("timestamp &lt;= ?", *filters.EndDate)
        }</span>

        // Get total count
        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Apply pagination and ordering
        <span class="cov0" title="0">if filters.Limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(filters.Limit)
        }</span>
        <span class="cov0" title="0">if filters.Offset &gt; 0 </span><span class="cov0" title="0">{
                query = query.Offset(filters.Offset)
        }</span>

        <span class="cov0" title="0">err := query.Order("timestamp DESC").Find(&amp;logs).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return logs, total, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package repositories

import (
        "context"
        "errors"
        "time"

        "tiris-backend/internal/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

type transactionRepository struct {
        db *gorm.DB
}

// NewTransactionRepository creates a new transaction repository instance
func NewTransactionRepository(db *gorm.DB) TransactionRepository <span class="cov0" title="0">{
        return &amp;transactionRepository{db: db}
}</span>

func (r *transactionRepository) Create(ctx context.Context, transaction *models.Transaction) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(transaction).Error
}</span>

func (r *transactionRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.Transaction, error) <span class="cov0" title="0">{
        var transaction models.Transaction
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;transaction).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;transaction, nil</span>
}

func (r *transactionRepository) GetByUserID(ctx context.Context, userID uuid.UUID, filters TransactionFilters) ([]*models.Transaction, int64, error) <span class="cov0" title="0">{
        return r.getTransactions(ctx, filters, "user_id = ?", userID)
}</span>

func (r *transactionRepository) GetBySubAccountID(ctx context.Context, subAccountID uuid.UUID, filters TransactionFilters) ([]*models.Transaction, int64, error) <span class="cov0" title="0">{
        return r.getTransactions(ctx, filters, "sub_account_id = ?", subAccountID)
}</span>

func (r *transactionRepository) GetByExchangeID(ctx context.Context, exchangeID uuid.UUID, filters TransactionFilters) ([]*models.Transaction, int64, error) <span class="cov0" title="0">{
        return r.getTransactions(ctx, filters, "exchange_id = ?", exchangeID)
}</span>

func (r *transactionRepository) GetByTimeRange(ctx context.Context, startTime, endTime time.Time, filters TransactionFilters) ([]*models.Transaction, int64, error) <span class="cov0" title="0">{
        return r.getTransactions(ctx, filters, "timestamp BETWEEN ? AND ?", startTime, endTime)
}</span>

func (r *transactionRepository) getTransactions(ctx context.Context, filters TransactionFilters, whereClause string, whereArgs ...interface{}) ([]*models.Transaction, int64, error) <span class="cov0" title="0">{
        var transactions []*models.Transaction
        var total int64

        // Build base query
        query := r.db.WithContext(ctx).Model(&amp;models.Transaction{}).Where(whereClause, whereArgs...)

        // Apply filters
        if filters.Direction != nil </span><span class="cov0" title="0">{
                query = query.Where("direction = ?", *filters.Direction)
        }</span>
        <span class="cov0" title="0">if filters.Reason != nil </span><span class="cov0" title="0">{
                query = query.Where("reason = ?", *filters.Reason)
        }</span>
        <span class="cov0" title="0">if filters.StartDate != nil </span><span class="cov0" title="0">{
                query = query.Where("timestamp &gt;= ?", *filters.StartDate)
        }</span>
        <span class="cov0" title="0">if filters.EndDate != nil </span><span class="cov0" title="0">{
                query = query.Where("timestamp &lt;= ?", *filters.EndDate)
        }</span>
        <span class="cov0" title="0">if filters.MinAmount != nil </span><span class="cov0" title="0">{
                query = query.Where("amount &gt;= ?", *filters.MinAmount)
        }</span>
        <span class="cov0" title="0">if filters.MaxAmount != nil </span><span class="cov0" title="0">{
                query = query.Where("amount &lt;= ?", *filters.MaxAmount)
        }</span>

        // Get total count
        <span class="cov0" title="0">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Apply pagination and ordering
        <span class="cov0" title="0">if filters.Limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(filters.Limit)
        }</span>
        <span class="cov0" title="0">if filters.Offset &gt; 0 </span><span class="cov0" title="0">{
                query = query.Offset(filters.Offset)
        }</span>

        <span class="cov0" title="0">err := query.Order("timestamp DESC").Find(&amp;transactions).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return transactions, total, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package repositories

import (
        "context"
        "errors"

        "tiris-backend/internal/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

type userRepository struct {
        db *gorm.DB
}

// NewUserRepository creates a new user repository instance
func NewUserRepository(db *gorm.DB) UserRepository <span class="cov0" title="0">{
        return &amp;userRepository{db: db}
}</span>

func (r *userRepository) Create(ctx context.Context, user *models.User) error <span class="cov0" title="0">{
        if err := r.db.WithContext(ctx).Create(user).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *userRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.User, error) <span class="cov0" title="0">{
        var user models.User
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) GetByEmail(ctx context.Context, email string) (*models.User, error) <span class="cov0" title="0">{
        var user models.User
        err := r.db.WithContext(ctx).Where("email = ?", email).First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) GetByUsername(ctx context.Context, username string) (*models.User, error) <span class="cov0" title="0">{
        var user models.User
        err := r.db.WithContext(ctx).Where("username = ?", username).First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) Update(ctx context.Context, user *models.User) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Save(user).Error
}</span>

func (r *userRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Delete(&amp;models.User{}, id).Error
}</span>

func (r *userRepository) List(ctx context.Context, limit, offset int) ([]*models.User, int64, error) <span class="cov0" title="0">{
        var users []*models.User
        var total int64

        // Get total count
        if err := r.db.WithContext(ctx).Model(&amp;models.User{}).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get paginated results
        <span class="cov0" title="0">err := r.db.WithContext(ctx).
                Limit(limit).
                Offset(offset).
                Order("created_at DESC").
                Find(&amp;users).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return users, total, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "tiris-backend/internal/models"
        "tiris-backend/internal/repositories"
        "tiris-backend/pkg/auth"

        "github.com/google/uuid"
        "golang.org/x/oauth2"
        "gorm.io/datatypes"
)

// AuthService handles authentication business logic
type AuthService struct {
        repos        *repositories.Repositories
        jwtManager   auth.JWTManagerInterface
        oauthManager auth.OAuthManagerInterface
}

// NewAuthService creates a new authentication service
func NewAuthService(repos *repositories.Repositories, jwtManager auth.JWTManagerInterface, oauthManager auth.OAuthManagerInterface) *AuthService <span class="cov10" title="10">{
        return &amp;AuthService{
                repos:        repos,
                jwtManager:   jwtManager,
                oauthManager: oauthManager,
        }
}</span>

// LoginRequest represents a login request
type LoginRequest struct {
        Provider    string `json:"provider" binding:"required,oneof=google wechat"`
        RedirectURL string `json:"redirect_uri" binding:"required,url"`
}

// LoginResponse represents a login response with auth URL
type LoginResponse struct {
        AuthURL string `json:"auth_url"`
        State   string `json:"state"`
}

// CallbackRequest represents an OAuth callback request
type CallbackRequest struct {
        Provider string `json:"provider" binding:"required,oneof=google wechat"`
        Code     string `json:"code" binding:"required"`
        State    string `json:"state" binding:"required"`
}

// AuthResponse represents an authentication response with tokens
type AuthResponse struct {
        AccessToken  string    `json:"access_token"`
        RefreshToken string    `json:"refresh_token"`
        TokenType    string    `json:"token_type"`
        ExpiresIn    int64     `json:"expires_in"`
        User         *UserInfo `json:"user"`
}

// UserInfo represents user information in auth response
type UserInfo struct {
        ID       uuid.UUID              `json:"id"`
        Username string                 `json:"username"`
        Email    string                 `json:"email"`
        Avatar   *string                `json:"avatar,omitempty"`
        Info     map[string]interface{} `json:"info"`
}

// RefreshRequest represents a token refresh request
type RefreshRequest struct {
        RefreshToken string `json:"refresh_token" binding:"required"`
}

// InitiateLogin initiates OAuth login flow
func (s *AuthService) InitiateLogin(ctx context.Context, req *LoginRequest) (*LoginResponse, error) <span class="cov3" title="2">{
        // Generate state for CSRF protection
        state := auth.GenerateState()

        // Get OAuth authorization URL
        authURL, err := s.oauthManager.GetAuthURL(auth.OAuthProvider(req.Provider), state)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to generate auth URL: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;LoginResponse{
                AuthURL: authURL,
                State:   state,
        }, nil</span>
}

// HandleCallback handles OAuth callback and creates/updates user
func (s *AuthService) HandleCallback(ctx context.Context, req *CallbackRequest, expectedState string) (*AuthResponse, error) <span class="cov6" title="4">{
        // Validate state to prevent CSRF attacks
        if err := auth.ValidateState(expectedState, req.State); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid state parameter: %w", err)
        }</span>

        // Exchange code for token
        <span class="cov5" title="3">token, err := s.oauthManager.ExchangeCodeForToken(auth.OAuthProvider(req.Provider), req.Code)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to exchange code for token: %w", err)
        }</span>

        // Get user info from OAuth provider
        <span class="cov3" title="2">oauthUser, err := s.oauthManager.GetUserInfo(auth.OAuthProvider(req.Provider), token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user info: %w", err)
        }</span>

        // Find or create user
        <span class="cov3" title="2">user, err := s.findOrCreateUser(ctx, oauthUser, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find or create user: %w", err)
        }</span>

        // Generate JWT tokens
        <span class="cov3" title="2">tokenPair, err := s.jwtManager.GenerateTokenPair(user.ID, user.Username, user.Email, "user")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate tokens: %w", err)
        }</span>

        // Convert user info
        <span class="cov3" title="2">var avatar *string
        if user.Avatar != nil &amp;&amp; *user.Avatar != "" </span><span class="cov3" title="2">{
                avatar = user.Avatar
        }</span>

        <span class="cov3" title="2">var userInfoMap map[string]interface{}
        if err := json.Unmarshal(user.Info, &amp;userInfoMap); err != nil </span><span class="cov0" title="0">{
                userInfoMap = make(map[string]interface{})
        }</span>

        <span class="cov3" title="2">userInfo := &amp;UserInfo{
                ID:       user.ID,
                Username: user.Username,
                Email:    user.Email,
                Avatar:   avatar,
                Info:     userInfoMap,
        }

        return &amp;AuthResponse{
                AccessToken:  tokenPair.AccessToken,
                RefreshToken: tokenPair.RefreshToken,
                TokenType:    tokenPair.TokenType,
                ExpiresIn:    tokenPair.ExpiresIn,
                User:         userInfo,
        }, nil</span>
}

// RefreshToken refreshes an access token using refresh token
func (s *AuthService) RefreshToken(ctx context.Context, req *RefreshRequest) (*AuthResponse, error) <span class="cov5" title="3">{
        // Validate refresh token and get user ID
        userID, err := s.jwtManager.ValidateRefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid refresh token: %w", err)
        }</span>

        // Get user from database
        <span class="cov3" title="2">user, err := s.repos.User.GetByID(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found")
        }</span>

        // Generate new access token
        <span class="cov1" title="1">accessToken, err := s.jwtManager.RefreshToken(req.RefreshToken, user.Username, user.Email, "user")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to refresh token: %w", err)
        }</span>

        // Convert user info
        <span class="cov1" title="1">var avatar *string
        if user.Avatar != nil &amp;&amp; *user.Avatar != "" </span><span class="cov1" title="1">{
                avatar = user.Avatar
        }</span>

        <span class="cov1" title="1">var userInfoMap map[string]interface{}
        if err := json.Unmarshal(user.Info, &amp;userInfoMap); err != nil </span><span class="cov0" title="0">{
                userInfoMap = make(map[string]interface{})
        }</span>

        <span class="cov1" title="1">userInfo := &amp;UserInfo{
                ID:       user.ID,
                Username: user.Username,
                Email:    user.Email,
                Avatar:   avatar,
                Info:     userInfoMap,
        }

        return &amp;AuthResponse{
                AccessToken:  accessToken,
                RefreshToken: req.RefreshToken, // Keep the same refresh token
                TokenType:    "Bearer",
                ExpiresIn:    3600, // 1 hour
                User:         userInfo,
        }, nil</span>
}

// Logout invalidates user session
func (s *AuthService) Logout(ctx context.Context, userID uuid.UUID) error <span class="cov1" title="1">{
        // In a more sophisticated implementation, we might maintain a blacklist of tokens
        // For now, we just return success since JWT tokens are stateless
        // The client should discard the tokens
        return nil
}</span>

// findOrCreateUser finds existing user or creates new one from OAuth info
func (s *AuthService) findOrCreateUser(ctx context.Context, oauthUser *auth.OAuthUser, token *oauth2.Token) (*models.User, error) <span class="cov3" title="2">{
        // Check if OAuth token already exists
        existingToken, err := s.repos.OAuthToken.GetByProviderUserID(ctx, oauthUser.Provider, oauthUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing OAuth token: %w", err)
        }</span>

        <span class="cov3" title="2">if existingToken != nil </span><span class="cov1" title="1">{
                // User exists, update OAuth token and return user
                existingToken.AccessToken = token.AccessToken
                if token.RefreshToken != "" </span><span class="cov1" title="1">{
                        existingToken.RefreshToken = &amp;token.RefreshToken
                }</span>
                <span class="cov1" title="1">if !token.Expiry.IsZero() </span><span class="cov1" title="1">{
                        existingToken.ExpiresAt = &amp;token.Expiry
                }</span>
                <span class="cov1" title="1">existingToken.UpdatedAt = time.Now()

                // Update OAuth token info
                infoMap := map[string]interface{}{
                        "last_login": time.Now(),
                        "provider_data": map[string]interface{}{
                                "name":   oauthUser.Name,
                                "avatar": oauthUser.Avatar,
                        },
                }
                infoJSON, _ := json.Marshal(infoMap)
                existingToken.Info = datatypes.JSON(infoJSON)

                if err := s.repos.OAuthToken.Update(ctx, existingToken); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to update OAuth token: %w", err)
                }</span>

                // Get and return the user
                <span class="cov1" title="1">user, err := s.repos.User.GetByID(ctx, existingToken.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get existing user: %w", err)
                }</span>

                // Update user avatar if provided
                <span class="cov1" title="1">if oauthUser.Avatar != "" &amp;&amp; (user.Avatar == nil || *user.Avatar != oauthUser.Avatar) </span><span class="cov0" title="0">{
                        user.Avatar = &amp;oauthUser.Avatar
                        if err := s.repos.User.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to update user avatar: %w", err)
                        }</span>
                }

                <span class="cov1" title="1">return user, nil</span>
        }

        // Check if user exists by email
        <span class="cov1" title="1">existingUser, err := s.repos.User.GetByEmail(ctx, oauthUser.Email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing user: %w", err)
        }</span>

        <span class="cov1" title="1">var user *models.User
        if existingUser != nil </span><span class="cov0" title="0">{
                // User exists with this email, link OAuth account
                user = existingUser
        }</span> else<span class="cov1" title="1"> {
                // Create new user
                user = &amp;models.User{
                        Username: s.generateUsername(oauthUser.Name, oauthUser.Email),
                        Email:    oauthUser.Email,
                        Avatar:   &amp;oauthUser.Avatar,
                        Settings: datatypes.JSON{},
                        Info: func() datatypes.JSON </span><span class="cov1" title="1">{
                                infoMap := map[string]interface{}{
                                        "oauth_provider": oauthUser.Provider,
                                        "created_via":    "oauth",
                                        "first_login":    time.Now(),
                                }
                                infoJSON, _ := json.Marshal(infoMap)
                                return datatypes.JSON(infoJSON)
                        }</span>(),
                }

                <span class="cov1" title="1">if err := s.repos.User.Create(ctx, user); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create user: %w", err)
                }</span>
        }

        // Create OAuth token record
        <span class="cov1" title="1">oauthToken := &amp;models.OAuthToken{
                UserID:         user.ID,
                Provider:       oauthUser.Provider,
                ProviderUserID: oauthUser.ID,
                AccessToken:    token.AccessToken,
                RefreshToken:   &amp;token.RefreshToken,
                ExpiresAt:      &amp;token.Expiry,
                Info: func() datatypes.JSON </span><span class="cov1" title="1">{
                        infoMap := map[string]interface{}{
                                "provider_data": map[string]interface{}{
                                        "name":   oauthUser.Name,
                                        "avatar": oauthUser.Avatar,
                                },
                                "first_auth": time.Now(),
                        }
                        infoJSON, _ := json.Marshal(infoMap)
                        return datatypes.JSON(infoJSON)
                }</span>(),
        }

        <span class="cov1" title="1">if err := s.repos.OAuthToken.Create(ctx, oauthToken); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create OAuth token: %w", err)
        }</span>

        <span class="cov1" title="1">return user, nil</span>
}

// generateUsername generates a unique username from name and email
func (s *AuthService) generateUsername(name, email string) string <span class="cov1" title="1">{
        // Start with name if available
        if name != "" </span><span class="cov1" title="1">{
                // Clean name: remove spaces, convert to lowercase
                username := ""
                for _, char := range name </span><span class="cov9" title="8">{
                        if (char &gt;= 'a' &amp;&amp; char &lt;= 'z') || (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') || (char &gt;= '0' &amp;&amp; char &lt;= '9') </span><span class="cov8" title="7">{
                                username += string(char)
                        }</span>
                }
                <span class="cov1" title="1">if len(username) &gt;= 3 </span><span class="cov1" title="1">{
                        return username[:min(len(username), 20)]
                }</span>
        }

        // Fall back to email prefix
        <span class="cov0" title="0">if email != "" </span><span class="cov0" title="0">{
                atIndex := strings.Index(email, "@")
                if atIndex &gt; 0 </span><span class="cov0" title="0">{
                        parts := email[:atIndex]
                        if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                                return parts[:min(len(parts), 20)]
                        }</span>
                }
        }

        // Last resort: generate random username
        <span class="cov0" title="0">return fmt.Sprintf("user%d", time.Now().Unix())</span>
}

// min returns the minimum of two integers
func min(a, b int) int <span class="cov1" title="1">{
        if a &lt; b </span><span class="cov1" title="1">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"

        "tiris-backend/internal/models"
        "tiris-backend/internal/repositories"

        "github.com/google/uuid"
        "gorm.io/datatypes"
)

// ExchangeService handles exchange business logic
type ExchangeService struct {
        repos *repositories.Repositories
}

// NewExchangeService creates a new exchange service
func NewExchangeService(repos *repositories.Repositories) *ExchangeService <span class="cov10" title="13">{
        return &amp;ExchangeService{
                repos: repos,
        }
}</span>

// ExchangeResponse represents exchange information in responses
type ExchangeResponse struct {
        ID        uuid.UUID              `json:"id"`
        UserID    uuid.UUID              `json:"user_id"`
        Name      string                 `json:"name"`
        Type      string                 `json:"type"`
        APIKey    string                 `json:"api_key,omitempty"` // Masked in production
        Status    string                 `json:"status"`
        Info      map[string]interface{} `json:"info"`
        CreatedAt string                 `json:"created_at"`
        UpdatedAt string                 `json:"updated_at"`
}

// CreateExchangeRequest represents exchange creation request
type CreateExchangeRequest struct {
        Name      string `json:"name" binding:"required,min=1,max=100"`
        Type      string `json:"type" binding:"required,oneof=binance okx bybit"`
        APIKey    string `json:"api_key" binding:"required,min=1"`
        APISecret string `json:"api_secret" binding:"required,min=1"`
}

// UpdateExchangeRequest represents exchange update request
type UpdateExchangeRequest struct {
        Name      *string `json:"name,omitempty" binding:"omitempty,min=1,max=100"`
        APIKey    *string `json:"api_key,omitempty" binding:"omitempty,min=1"`
        APISecret *string `json:"api_secret,omitempty" binding:"omitempty,min=1"`
        Status    *string `json:"status,omitempty" binding:"omitempty,oneof=active inactive"`
}

// CreateExchange creates a new exchange configuration
func (s *ExchangeService) CreateExchange(ctx context.Context, userID uuid.UUID, req *CreateExchangeRequest) (*ExchangeResponse, error) <span class="cov4" title="3">{
        // Check if user has reached the maximum number of exchanges
        existingExchanges, err := s.repos.Exchange.GetByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing exchanges: %w", err)
        }</span>

        // Limit to 10 exchanges per user for now
        <span class="cov4" title="3">if len(existingExchanges) &gt;= 10 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("maximum number of exchanges reached (10)")
        }</span>

        // Check if exchange name is unique for this user
        <span class="cov3" title="2">for _, exchange := range existingExchanges </span><span class="cov1" title="1">{
                if exchange.Name == req.Name </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("exchange name already exists")
                }</span>
        }

        // Create info JSON with metadata
        <span class="cov1" title="1">infoData := map[string]interface{}{
                "created_by":  "api",
                "api_version": "v1",
        }

        infoJSON, err := json.Marshal(infoData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encode info: %w", err)
        }</span>

        // Create exchange model
        <span class="cov1" title="1">exchange := &amp;models.Exchange{
                ID:        uuid.New(),
                UserID:    userID,
                Name:      req.Name,
                Type:      req.Type,
                APIKey:    req.APIKey,
                APISecret: req.APISecret,
                Status:    "active", // Default to active
                Info:      datatypes.JSON(infoJSON),
        }

        // Save to database
        if err := s.repos.Exchange.Create(ctx, exchange); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create exchange: %w", err)
        }</span>

        <span class="cov1" title="1">return s.convertToExchangeResponse(exchange), nil</span>
}

// GetUserExchanges retrieves all exchanges for a user
func (s *ExchangeService) GetUserExchanges(ctx context.Context, userID uuid.UUID) ([]*ExchangeResponse, error) <span class="cov1" title="1">{
        exchanges, err := s.repos.Exchange.GetByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user exchanges: %w", err)
        }</span>

        <span class="cov1" title="1">var responses []*ExchangeResponse
        for _, exchange := range exchanges </span><span class="cov3" title="2">{
                responses = append(responses, s.convertToExchangeResponse(exchange))
        }</span>

        <span class="cov1" title="1">return responses, nil</span>
}

// GetExchange retrieves a specific exchange by ID (must belong to user)
func (s *ExchangeService) GetExchange(ctx context.Context, userID, exchangeID uuid.UUID) (*ExchangeResponse, error) <span class="cov4" title="3">{
        exchange, err := s.repos.Exchange.GetByID(ctx, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get exchange: %w", err)
        }</span>
        <span class="cov4" title="3">if exchange == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        // Check if exchange belongs to the user
        <span class="cov3" title="2">if exchange.UserID != userID </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        <span class="cov1" title="1">return s.convertToExchangeResponse(exchange), nil</span>
}

// UpdateExchange updates an existing exchange
func (s *ExchangeService) UpdateExchange(ctx context.Context, userID, exchangeID uuid.UUID, req *UpdateExchangeRequest) (*ExchangeResponse, error) <span class="cov3" title="2">{
        // Get existing exchange
        exchange, err := s.repos.Exchange.GetByID(ctx, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get exchange: %w", err)
        }</span>
        <span class="cov3" title="2">if exchange == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        // Check if exchange belongs to the user
        <span class="cov3" title="2">if exchange.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        // Update fields if provided
        <span class="cov3" title="2">if req.Name != nil </span><span class="cov3" title="2">{
                // Check if new name is unique for this user
                userExchanges, err := s.repos.Exchange.GetByUserID(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to check exchange names: %w", err)
                }</span>

                <span class="cov3" title="2">for _, userExchange := range userExchanges </span><span class="cov4" title="3">{
                        if userExchange.ID != exchangeID &amp;&amp; userExchange.Name == *req.Name </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("exchange name already exists")
                        }</span>
                }

                <span class="cov1" title="1">exchange.Name = *req.Name</span>
        }

        <span class="cov1" title="1">if req.APIKey != nil </span><span class="cov1" title="1">{
                exchange.APIKey = *req.APIKey
        }</span>

        <span class="cov1" title="1">if req.APISecret != nil </span><span class="cov0" title="0">{
                exchange.APISecret = *req.APISecret
        }</span>

        <span class="cov1" title="1">if req.Status != nil </span><span class="cov1" title="1">{
                exchange.Status = *req.Status
        }</span>

        // Save updated exchange
        <span class="cov1" title="1">if err := s.repos.Exchange.Update(ctx, exchange); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update exchange: %w", err)
        }</span>

        <span class="cov1" title="1">return s.convertToExchangeResponse(exchange), nil</span>
}

// DeleteExchange deletes an exchange (soft delete)
func (s *ExchangeService) DeleteExchange(ctx context.Context, userID, exchangeID uuid.UUID) error <span class="cov3" title="2">{
        // Get existing exchange to verify ownership
        exchange, err := s.repos.Exchange.GetByID(ctx, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get exchange: %w", err)
        }</span>
        <span class="cov3" title="2">if exchange == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("exchange not found")
        }</span>

        // Check if exchange belongs to the user
        <span class="cov3" title="2">if exchange.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("exchange not found")
        }</span>

        // Check if exchange has sub-accounts
        <span class="cov3" title="2">subAccounts, err := s.repos.SubAccount.GetByExchangeID(ctx, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check sub-accounts: %w", err)
        }</span>

        <span class="cov3" title="2">if len(subAccounts) &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("cannot delete exchange with existing sub-accounts")
        }</span>

        // Soft delete the exchange
        <span class="cov1" title="1">if err := s.repos.Exchange.Delete(ctx, exchangeID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete exchange: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ListExchanges lists all exchanges with pagination (admin only)
// For now, returns all exchanges without pagination since we don't have List method
func (s *ExchangeService) ListExchanges(ctx context.Context, limit, offset int) ([]*ExchangeResponse, int64, error) <span class="cov0" title="0">{
        // This would need a List method in the repository
        // For now, we'll return an error indicating this is not implemented
        return nil, 0, fmt.Errorf("list exchanges not implemented yet")
}</span>

// GetExchangeByID retrieves exchange by ID (admin only)
func (s *ExchangeService) GetExchangeByID(ctx context.Context, exchangeID uuid.UUID) (*ExchangeResponse, error) <span class="cov1" title="1">{
        exchange, err := s.repos.Exchange.GetByID(ctx, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get exchange: %w", err)
        }</span>
        <span class="cov1" title="1">if exchange == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        <span class="cov1" title="1">return s.convertToExchangeResponse(exchange), nil</span>
}

// convertToExchangeResponse converts an exchange model to response format
func (s *ExchangeService) convertToExchangeResponse(exchange *models.Exchange) *ExchangeResponse <span class="cov8" title="8">{
        var info map[string]interface{}
        if err := json.Unmarshal(exchange.Info, &amp;info); err != nil </span><span class="cov1" title="1">{
                info = make(map[string]interface{})
        }</span>

        // Mask API key for security (show only first 4 and last 4 characters)
        <span class="cov8" title="8">maskedAPIKey := exchange.APIKey
        if len(maskedAPIKey) &gt; 8 </span><span class="cov7" title="7">{
                maskedAPIKey = maskedAPIKey[:4] + "****" + maskedAPIKey[len(maskedAPIKey)-4:]
        }</span>

        <span class="cov8" title="8">return &amp;ExchangeResponse{
                ID:        exchange.ID,
                UserID:    exchange.UserID,
                Name:      exchange.Name,
                Type:      exchange.Type,
                APIKey:    maskedAPIKey,
                Status:    exchange.Status,
                Info:      info,
                CreatedAt: exchange.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt: exchange.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"

        "tiris-backend/internal/models"
        "tiris-backend/internal/repositories"

        "github.com/google/uuid"
        "gorm.io/datatypes"
)

// SubAccountService handles sub-account business logic
type SubAccountService struct {
        repos *repositories.Repositories
}

// NewSubAccountService creates a new sub-account service
func NewSubAccountService(repos *repositories.Repositories) *SubAccountService <span class="cov10" title="14">{
        return &amp;SubAccountService{
                repos: repos,
        }
}</span>

// SubAccountResponse represents sub-account information in responses
type SubAccountResponse struct {
        ID         uuid.UUID              `json:"id"`
        UserID     uuid.UUID              `json:"user_id"`
        ExchangeID uuid.UUID              `json:"exchange_id"`
        Name       string                 `json:"name"`
        Symbol     string                 `json:"symbol"`
        Balance    float64                `json:"balance"`
        Info       map[string]interface{} `json:"info"`
        CreatedAt  string                 `json:"created_at"`
        UpdatedAt  string                 `json:"updated_at"`
}

// CreateSubAccountRequest represents sub-account creation request
type CreateSubAccountRequest struct {
        ExchangeID uuid.UUID `json:"exchange_id" binding:"required"`
        Name       string    `json:"name" binding:"required,min=1,max=100"`
        Symbol     string    `json:"symbol" binding:"required,min=1,max=20"`
}

// UpdateSubAccountRequest represents sub-account update request
type UpdateSubAccountRequest struct {
        Name    *string  `json:"name,omitempty" binding:"omitempty,min=1,max=100"`
        Symbol  *string  `json:"symbol,omitempty" binding:"omitempty,min=1,max=20"`
        Balance *float64 `json:"balance,omitempty" binding:"omitempty,min=0"`
}

// UpdateBalanceRequest represents balance update request
type UpdateBalanceRequest struct {
        Amount    float64                `json:"amount" binding:"required"`
        Direction string                 `json:"direction" binding:"required,oneof=credit debit"`
        Reason    string                 `json:"reason" binding:"required,min=1,max=255"`
        Info      map[string]interface{} `json:"info,omitempty"`
}

// CreateSubAccount creates a new sub-account
func (s *SubAccountService) CreateSubAccount(ctx context.Context, userID uuid.UUID, req *CreateSubAccountRequest) (*SubAccountResponse, error) <span class="cov5" title="4">{
        // Verify user owns the exchange
        exchange, err := s.repos.Exchange.GetByID(ctx, req.ExchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to verify exchange: %w", err)
        }</span>
        <span class="cov5" title="4">if exchange == nil || exchange.UserID != userID </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        // Check if sub-account name is unique for this user+exchange combination
        <span class="cov3" title="2">existingSubAccounts, err := s.repos.SubAccount.GetByUserID(ctx, userID, &amp;req.ExchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing sub-accounts: %w", err)
        }</span>

        <span class="cov3" title="2">for _, subAccount := range existingSubAccounts </span><span class="cov1" title="1">{
                if subAccount.Name == req.Name </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("sub-account name already exists for this exchange")
                }</span>
        }

        // Create info JSON with metadata
        <span class="cov1" title="1">infoData := map[string]interface{}{
                "created_by":    "api",
                "api_version":   "v1",
                "exchange_type": exchange.Type,
        }

        infoJSON, err := json.Marshal(infoData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encode info: %w", err)
        }</span>

        // Create sub-account model
        <span class="cov1" title="1">subAccount := &amp;models.SubAccount{
                ID:         uuid.New(),
                UserID:     userID,
                ExchangeID: req.ExchangeID,
                Name:       req.Name,
                Symbol:     req.Symbol,
                Balance:    0.0, // Start with zero balance
                Info:       datatypes.JSON(infoJSON),
        }

        // Save to database
        if err := s.repos.SubAccount.Create(ctx, subAccount); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sub-account: %w", err)
        }</span>

        <span class="cov1" title="1">return s.convertToSubAccountResponse(subAccount), nil</span>
}

// GetUserSubAccounts retrieves all sub-accounts for a user
func (s *SubAccountService) GetUserSubAccounts(ctx context.Context, userID uuid.UUID, exchangeID *uuid.UUID) ([]*SubAccountResponse, error) <span class="cov3" title="2">{
        // If exchangeID is provided, verify user owns it
        if exchangeID != nil </span><span class="cov1" title="1">{
                exchange, err := s.repos.Exchange.GetByID(ctx, *exchangeID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to verify exchange: %w", err)
                }</span>
                <span class="cov1" title="1">if exchange == nil || exchange.UserID != userID </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("exchange not found")
                }</span>
        }

        <span class="cov3" title="2">subAccounts, err := s.repos.SubAccount.GetByUserID(ctx, userID, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user sub-accounts: %w", err)
        }</span>

        <span class="cov3" title="2">var responses []*SubAccountResponse
        for _, subAccount := range subAccounts </span><span class="cov4" title="3">{
                responses = append(responses, s.convertToSubAccountResponse(subAccount))
        }</span>

        <span class="cov3" title="2">return responses, nil</span>
}

// GetSubAccount retrieves a specific sub-account by ID (must belong to user)
func (s *SubAccountService) GetSubAccount(ctx context.Context, userID, subAccountID uuid.UUID) (*SubAccountResponse, error) <span class="cov4" title="3">{
        subAccount, err := s.repos.SubAccount.GetByID(ctx, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sub-account: %w", err)
        }</span>
        <span class="cov4" title="3">if subAccount == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        // Check if sub-account belongs to the user
        <span class="cov3" title="2">if subAccount.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        <span class="cov3" title="2">return s.convertToSubAccountResponse(subAccount), nil</span>
}

// UpdateSubAccount updates an existing sub-account
func (s *SubAccountService) UpdateSubAccount(ctx context.Context, userID, subAccountID uuid.UUID, req *UpdateSubAccountRequest) (*SubAccountResponse, error) <span class="cov1" title="1">{
        // Get existing sub-account
        subAccount, err := s.repos.SubAccount.GetByID(ctx, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sub-account: %w", err)
        }</span>
        <span class="cov1" title="1">if subAccount == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        // Check if sub-account belongs to the user
        <span class="cov1" title="1">if subAccount.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        // Update fields if provided
        <span class="cov1" title="1">if req.Name != nil </span><span class="cov1" title="1">{
                // Check if new name is unique for this user+exchange
                userSubAccounts, err := s.repos.SubAccount.GetByUserID(ctx, userID, &amp;subAccount.ExchangeID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to check sub-account names: %w", err)
                }</span>

                <span class="cov1" title="1">for _, userSubAccount := range userSubAccounts </span><span class="cov1" title="1">{
                        if userSubAccount.ID != subAccountID &amp;&amp; userSubAccount.Name == *req.Name </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("sub-account name already exists for this exchange")
                        }</span>
                }

                <span class="cov1" title="1">subAccount.Name = *req.Name</span>
        }

        <span class="cov1" title="1">if req.Symbol != nil </span><span class="cov1" title="1">{
                subAccount.Symbol = *req.Symbol
        }</span>

        // Note: Direct balance updates should use UpdateBalance method for proper logging
        <span class="cov1" title="1">if req.Balance != nil </span><span class="cov1" title="1">{
                subAccount.Balance = *req.Balance
        }</span>

        // Save updated sub-account
        <span class="cov1" title="1">if err := s.repos.SubAccount.Update(ctx, subAccount); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update sub-account: %w", err)
        }</span>

        <span class="cov1" title="1">return s.convertToSubAccountResponse(subAccount), nil</span>
}

// UpdateBalance updates sub-account balance with proper logging
func (s *SubAccountService) UpdateBalance(ctx context.Context, userID, subAccountID uuid.UUID, req *UpdateBalanceRequest) (*SubAccountResponse, error) <span class="cov3" title="2">{
        // Verify sub-account belongs to user
        subAccount, err := s.repos.SubAccount.GetByID(ctx, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sub-account: %w", err)
        }</span>
        <span class="cov3" title="2">if subAccount == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        <span class="cov3" title="2">if subAccount.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        // Calculate new balance
        <span class="cov3" title="2">var newBalance float64
        switch req.Direction </span>{
        case "credit":<span class="cov1" title="1">
                newBalance = subAccount.Balance + req.Amount</span>
        case "debit":<span class="cov1" title="1">
                newBalance = subAccount.Balance - req.Amount
                if newBalance &lt; 0 </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("insufficient balance")
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid direction")</span>
        }

        // Use repository method for atomic balance update with logging
        <span class="cov1" title="1">_, err = s.repos.SubAccount.UpdateBalance(ctx, subAccountID, newBalance, req.Amount, req.Direction, req.Reason, req.Info)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update balance: %w", err)
        }</span>

        // Return updated sub-account
        <span class="cov1" title="1">return s.GetSubAccount(ctx, userID, subAccountID)</span>
}

// DeleteSubAccount deletes a sub-account (soft delete)
func (s *SubAccountService) DeleteSubAccount(ctx context.Context, userID, subAccountID uuid.UUID) error <span class="cov3" title="2">{
        // Get existing sub-account to verify ownership
        subAccount, err := s.repos.SubAccount.GetByID(ctx, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get sub-account: %w", err)
        }</span>
        <span class="cov3" title="2">if subAccount == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("sub-account not found")
        }</span>

        // Check if sub-account belongs to the user
        <span class="cov3" title="2">if subAccount.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("sub-account not found")
        }</span>

        // Check if sub-account has balance
        <span class="cov3" title="2">if subAccount.Balance &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("cannot delete sub-account with positive balance")
        }</span>

        // Soft delete the sub-account
        <span class="cov1" title="1">if err := s.repos.SubAccount.Delete(ctx, subAccountID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete sub-account: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// GetSubAccountsBySymbol retrieves sub-accounts by symbol
func (s *SubAccountService) GetSubAccountsBySymbol(ctx context.Context, userID uuid.UUID, symbol string) ([]*SubAccountResponse, error) <span class="cov1" title="1">{
        subAccounts, err := s.repos.SubAccount.GetBySymbol(ctx, userID, symbol)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sub-accounts by symbol: %w", err)
        }</span>

        <span class="cov1" title="1">var responses []*SubAccountResponse
        for _, subAccount := range subAccounts </span><span class="cov3" title="2">{
                responses = append(responses, s.convertToSubAccountResponse(subAccount))
        }</span>

        <span class="cov1" title="1">return responses, nil</span>
}

// convertToSubAccountResponse converts a sub-account model to response format
func (s *SubAccountService) convertToSubAccountResponse(subAccount *models.SubAccount) *SubAccountResponse <span class="cov8" title="9">{
        var info map[string]interface{}
        if err := json.Unmarshal(subAccount.Info, &amp;info); err != nil </span><span class="cov3" title="2">{
                info = make(map[string]interface{})
        }</span>

        <span class="cov8" title="9">return &amp;SubAccountResponse{
                ID:         subAccount.ID,
                UserID:     subAccount.UserID,
                ExchangeID: subAccount.ExchangeID,
                Name:       subAccount.Name,
                Symbol:     subAccount.Symbol,
                Balance:    subAccount.Balance,
                Info:       info,
                CreatedAt:  subAccount.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt:  subAccount.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "tiris-backend/internal/models"
        "tiris-backend/internal/repositories"

        "github.com/google/uuid"
        "gorm.io/datatypes"
)

// TradingLogService handles trading log business logic
type TradingLogService struct {
        repos *repositories.Repositories
}

// NewTradingLogService creates a new trading log service
func NewTradingLogService(repos *repositories.Repositories) *TradingLogService <span class="cov10" title="17">{
        return &amp;TradingLogService{
                repos: repos,
        }
}</span>

// TradingLogResponse represents trading log information in responses
type TradingLogResponse struct {
        ID            uuid.UUID              `json:"id"`
        UserID        uuid.UUID              `json:"user_id"`
        ExchangeID    uuid.UUID              `json:"exchange_id"`
        SubAccountID  *uuid.UUID             `json:"sub_account_id,omitempty"`
        TransactionID *uuid.UUID             `json:"transaction_id,omitempty"`
        Timestamp     string                 `json:"timestamp"`
        Type          string                 `json:"type"`
        Source        string                 `json:"source"`
        Message       string                 `json:"message"`
        Info          map[string]interface{} `json:"info"`
}

// CreateTradingLogRequest represents trading log creation request
type CreateTradingLogRequest struct {
        ExchangeID    uuid.UUID              `json:"exchange_id" binding:"required"`
        SubAccountID  *uuid.UUID             `json:"sub_account_id,omitempty"`
        TransactionID *uuid.UUID             `json:"transaction_id,omitempty"`
        Type          string                 `json:"type" binding:"required,min=1,max=50"`
        Source        string                 `json:"source" binding:"required,oneof=manual bot"`
        Message       string                 `json:"message" binding:"required,min=1"`
        Info          map[string]interface{} `json:"info,omitempty"`
}

// TradingLogQueryRequest represents trading log query parameters
type TradingLogQueryRequest struct {
        Type      *string    `form:"type"`
        Source    *string    `form:"source" binding:"omitempty,oneof=manual bot"`
        StartDate *time.Time `form:"start_date" time_format:"2006-01-02T15:04:05Z07:00"`
        EndDate   *time.Time `form:"end_date" time_format:"2006-01-02T15:04:05Z07:00"`
        Limit     int        `form:"limit" binding:"omitempty,min=1,max=1000"`
        Offset    int        `form:"offset" binding:"omitempty,min=0"`
}

// TradingLogQueryResponse represents paginated trading log results
type TradingLogQueryResponse struct {
        TradingLogs []*TradingLogResponse `json:"trading_logs"`
        Total       int64                 `json:"total"`
        Limit       int                   `json:"limit"`
        Offset      int                   `json:"offset"`
        HasMore     bool                  `json:"has_more"`
}

// CreateTradingLog creates a new trading log entry
func (s *TradingLogService) CreateTradingLog(ctx context.Context, userID uuid.UUID, req *CreateTradingLogRequest) (*TradingLogResponse, error) <span class="cov5" title="4">{
        // Verify user owns the exchange
        exchange, err := s.repos.Exchange.GetByID(ctx, req.ExchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to verify exchange: %w", err)
        }</span>
        <span class="cov5" title="4">if exchange == nil || exchange.UserID != userID </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        // Verify sub-account ownership if provided
        <span class="cov3" title="2">if req.SubAccountID != nil </span><span class="cov1" title="1">{
                subAccount, err := s.repos.SubAccount.GetByID(ctx, *req.SubAccountID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to verify sub-account: %w", err)
                }</span>
                <span class="cov1" title="1">if subAccount == nil || subAccount.UserID != userID </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("sub-account not found")
                }</span>
        }

        // Verify transaction ownership if provided
        <span class="cov3" title="2">if req.TransactionID != nil </span><span class="cov1" title="1">{
                transaction, err := s.repos.Transaction.GetByID(ctx, *req.TransactionID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to verify transaction: %w", err)
                }</span>
                <span class="cov1" title="1">if transaction == nil || transaction.UserID != userID </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("transaction not found")
                }</span>
        }

        // Create info JSON with metadata
        <span class="cov3" title="2">infoData := req.Info
        if infoData == nil </span><span class="cov1" title="1">{
                infoData = make(map[string]interface{})
        }</span>
        // Add metadata
        <span class="cov3" title="2">infoData["created_by"] = "api"
        infoData["api_version"] = "v1"
        infoData["exchange_type"] = exchange.Type

        infoJSON, err := json.Marshal(infoData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encode info: %w", err)
        }</span>

        // Create trading log model
        <span class="cov3" title="2">tradingLog := &amp;models.TradingLog{
                ID:            uuid.New(),
                UserID:        userID,
                ExchangeID:    req.ExchangeID,
                SubAccountID:  req.SubAccountID,
                TransactionID: req.TransactionID,
                Timestamp:     time.Now().UTC(),
                Type:          req.Type,
                Source:        req.Source,
                Message:       req.Message,
                Info:          datatypes.JSON(infoJSON),
        }

        // Save to database
        if err := s.repos.TradingLog.Create(ctx, tradingLog); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create trading log: %w", err)
        }</span>

        <span class="cov3" title="2">return s.convertToTradingLogResponse(tradingLog), nil</span>
}

// GetUserTradingLogs retrieves trading logs for a user with filtering
func (s *TradingLogService) GetUserTradingLogs(ctx context.Context, userID uuid.UUID, req *TradingLogQueryRequest) (*TradingLogQueryResponse, error) <span class="cov5" title="4">{
        // Set default pagination
        if req.Limit == 0 </span><span class="cov3" title="2">{
                req.Limit = 100
        }</span>

        // Validate date range
        <span class="cov5" title="4">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>

        // Create filters
        <span class="cov4" title="3">filters := repositories.TradingLogFilters{
                Type:      req.Type,
                Source:    req.Source,
                StartDate: req.StartDate,
                EndDate:   req.EndDate,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query trading logs
        tradingLogs, total, err := s.repos.TradingLog.GetByUserID(ctx, userID, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user trading logs: %w", err)
        }</span>

        // Convert to response format
        <span class="cov4" title="3">var responses []*TradingLogResponse
        for _, tradingLog := range tradingLogs </span><span class="cov4" title="3">{
                responses = append(responses, s.convertToTradingLogResponse(tradingLog))
        }</span>

        <span class="cov4" title="3">return &amp;TradingLogQueryResponse{
                TradingLogs: responses,
                Total:       total,
                Limit:       req.Limit,
                Offset:      req.Offset,
                HasMore:     int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetSubAccountTradingLogs retrieves trading logs for a specific sub-account
func (s *TradingLogService) GetSubAccountTradingLogs(ctx context.Context, userID, subAccountID uuid.UUID, req *TradingLogQueryRequest) (*TradingLogQueryResponse, error) <span class="cov1" title="1">{
        // Verify user owns the sub-account
        subAccount, err := s.repos.SubAccount.GetByID(ctx, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to verify sub-account: %w", err)
        }</span>
        <span class="cov1" title="1">if subAccount == nil || subAccount.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        // Set default pagination
        <span class="cov1" title="1">if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate date range
        <span class="cov1" title="1">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>

        // Create filters
        <span class="cov1" title="1">filters := repositories.TradingLogFilters{
                Type:      req.Type,
                Source:    req.Source,
                StartDate: req.StartDate,
                EndDate:   req.EndDate,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query trading logs
        tradingLogs, total, err := s.repos.TradingLog.GetBySubAccountID(ctx, subAccountID, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sub-account trading logs: %w", err)
        }</span>

        // Convert to response format
        <span class="cov1" title="1">var responses []*TradingLogResponse
        for _, tradingLog := range tradingLogs </span><span class="cov1" title="1">{
                responses = append(responses, s.convertToTradingLogResponse(tradingLog))
        }</span>

        <span class="cov1" title="1">return &amp;TradingLogQueryResponse{
                TradingLogs: responses,
                Total:       total,
                Limit:       req.Limit,
                Offset:      req.Offset,
                HasMore:     int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetExchangeTradingLogs retrieves trading logs for a specific exchange
func (s *TradingLogService) GetExchangeTradingLogs(ctx context.Context, userID, exchangeID uuid.UUID, req *TradingLogQueryRequest) (*TradingLogQueryResponse, error) <span class="cov1" title="1">{
        // Verify user owns the exchange
        exchange, err := s.repos.Exchange.GetByID(ctx, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to verify exchange: %w", err)
        }</span>
        <span class="cov1" title="1">if exchange == nil || exchange.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        // Set default pagination
        <span class="cov1" title="1">if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate date range
        <span class="cov1" title="1">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>

        // Create filters
        <span class="cov1" title="1">filters := repositories.TradingLogFilters{
                Type:      req.Type,
                Source:    req.Source,
                StartDate: req.StartDate,
                EndDate:   req.EndDate,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query trading logs
        tradingLogs, total, err := s.repos.TradingLog.GetByExchangeID(ctx, exchangeID, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get exchange trading logs: %w", err)
        }</span>

        // Convert to response format
        <span class="cov1" title="1">var responses []*TradingLogResponse
        for _, tradingLog := range tradingLogs </span><span class="cov1" title="1">{
                responses = append(responses, s.convertToTradingLogResponse(tradingLog))
        }</span>

        <span class="cov1" title="1">return &amp;TradingLogQueryResponse{
                TradingLogs: responses,
                Total:       total,
                Limit:       req.Limit,
                Offset:      req.Offset,
                HasMore:     int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetTradingLog retrieves a specific trading log by ID
func (s *TradingLogService) GetTradingLog(ctx context.Context, userID, tradingLogID uuid.UUID) (*TradingLogResponse, error) <span class="cov3" title="2">{
        tradingLog, err := s.repos.TradingLog.GetByID(ctx, tradingLogID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trading log: %w", err)
        }</span>
        <span class="cov3" title="2">if tradingLog == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("trading log not found")
        }</span>

        // Check if trading log belongs to the user
        <span class="cov1" title="1">if tradingLog.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("trading log not found")
        }</span>

        <span class="cov1" title="1">return s.convertToTradingLogResponse(tradingLog), nil</span>
}

// GetTradingLogsByTimeRange retrieves trading logs within a specific time range
func (s *TradingLogService) GetTradingLogsByTimeRange(ctx context.Context, userID uuid.UUID, startTime, endTime time.Time, req *TradingLogQueryRequest) (*TradingLogQueryResponse, error) <span class="cov1" title="1">{
        // Validate time range
        if startTime.After(endTime) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("start time cannot be after end time")
        }</span>

        // Set default pagination
        <span class="cov1" title="1">if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Create filters (override date filters with provided time range)
        <span class="cov1" title="1">filters := repositories.TradingLogFilters{
                Type:      req.Type,
                Source:    req.Source,
                StartDate: &amp;startTime,
                EndDate:   &amp;endTime,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query trading logs by time range
        tradingLogs, _, err := s.repos.TradingLog.GetByTimeRange(ctx, startTime, endTime, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trading logs by time range: %w", err)
        }</span>

        // Filter to only include user's trading logs
        <span class="cov1" title="1">var userTradingLogs []*models.TradingLog
        for _, tradingLog := range tradingLogs </span><span class="cov3" title="2">{
                if tradingLog.UserID == userID </span><span class="cov1" title="1">{
                        userTradingLogs = append(userTradingLogs, tradingLog)
                }</span>
        }

        // Convert to response format
        <span class="cov1" title="1">var responses []*TradingLogResponse
        for _, tradingLog := range userTradingLogs </span><span class="cov1" title="1">{
                responses = append(responses, s.convertToTradingLogResponse(tradingLog))
        }</span>

        // Recalculate total for user's trading logs only
        <span class="cov1" title="1">userTotal := int64(len(userTradingLogs))

        return &amp;TradingLogQueryResponse{
                TradingLogs: responses,
                Total:       userTotal,
                Limit:       req.Limit,
                Offset:      req.Offset,
                HasMore:     int64(req.Offset+req.Limit) &lt; userTotal,
        }, nil</span>
}

// DeleteTradingLog deletes a trading log (soft delete)
func (s *TradingLogService) DeleteTradingLog(ctx context.Context, userID, tradingLogID uuid.UUID) error <span class="cov3" title="2">{
        // Get existing trading log to verify ownership
        tradingLog, err := s.repos.TradingLog.GetByID(ctx, tradingLogID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get trading log: %w", err)
        }</span>
        <span class="cov3" title="2">if tradingLog == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("trading log not found")
        }</span>

        // Check if trading log belongs to the user
        <span class="cov3" title="2">if tradingLog.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("trading log not found")
        }</span>

        // Only allow deletion of manual logs
        <span class="cov3" title="2">if tradingLog.Source != "manual" </span><span class="cov1" title="1">{
                return fmt.Errorf("cannot delete bot-generated trading logs")
        }</span>

        // Delete the trading log
        <span class="cov1" title="1">if err := s.repos.TradingLog.Delete(ctx, tradingLogID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete trading log: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ListAllTradingLogs lists all trading logs with pagination (admin only)
func (s *TradingLogService) ListAllTradingLogs(ctx context.Context, req *TradingLogQueryRequest) (*TradingLogQueryResponse, error) <span class="cov1" title="1">{
        // Set default pagination
        if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate date range
        <span class="cov1" title="1">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>

        // For admin queries, we'll use a time range approach to get all trading logs
        // Use a very broad time range if no specific dates provided
        <span class="cov1" title="1">startTime := time.Date(2020, 1, 1, 0, 0, 0, 0, time.UTC)
        endTime := time.Now().UTC()

        if req.StartDate != nil </span><span class="cov0" title="0">{
                startTime = *req.StartDate
        }</span>
        <span class="cov1" title="1">if req.EndDate != nil </span><span class="cov0" title="0">{
                endTime = *req.EndDate
        }</span>

        // Create filters
        <span class="cov1" title="1">filters := repositories.TradingLogFilters{
                Type:      req.Type,
                Source:    req.Source,
                StartDate: &amp;startTime,
                EndDate:   &amp;endTime,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query all trading logs in time range
        tradingLogs, total, err := s.repos.TradingLog.GetByTimeRange(ctx, startTime, endTime, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list all trading logs: %w", err)
        }</span>

        // Convert to response format
        <span class="cov1" title="1">var responses []*TradingLogResponse
        for _, tradingLog := range tradingLogs </span><span class="cov3" title="2">{
                responses = append(responses, s.convertToTradingLogResponse(tradingLog))
        }</span>

        <span class="cov1" title="1">return &amp;TradingLogQueryResponse{
                TradingLogs: responses,
                Total:       total,
                Limit:       req.Limit,
                Offset:      req.Offset,
                HasMore:     int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetTradingLogByID retrieves trading log by ID (admin only)
func (s *TradingLogService) GetTradingLogByID(ctx context.Context, tradingLogID uuid.UUID) (*TradingLogResponse, error) <span class="cov1" title="1">{
        tradingLog, err := s.repos.TradingLog.GetByID(ctx, tradingLogID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trading log: %w", err)
        }</span>
        <span class="cov1" title="1">if tradingLog == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("trading log not found")
        }</span>

        <span class="cov1" title="1">return s.convertToTradingLogResponse(tradingLog), nil</span>
}

// convertToTradingLogResponse converts a trading log model to response format
func (s *TradingLogService) convertToTradingLogResponse(tradingLog *models.TradingLog) *TradingLogResponse <span class="cov8" title="12">{
        var info map[string]interface{}
        if err := json.Unmarshal(tradingLog.Info, &amp;info); err != nil </span><span class="cov0" title="0">{
                info = make(map[string]interface{})
        }</span>

        <span class="cov8" title="12">return &amp;TradingLogResponse{
                ID:            tradingLog.ID,
                UserID:        tradingLog.UserID,
                ExchangeID:    tradingLog.ExchangeID,
                SubAccountID:  tradingLog.SubAccountID,
                TransactionID: tradingLog.TransactionID,
                Timestamp:     tradingLog.Timestamp.Format("2006-01-02T15:04:05Z07:00"),
                Type:          tradingLog.Type,
                Source:        tradingLog.Source,
                Message:       tradingLog.Message,
                Info:          info,
        }</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "tiris-backend/internal/models"
        "tiris-backend/internal/repositories"

        "github.com/google/uuid"
)

// TransactionService handles transaction query business logic
type TransactionService struct {
        repos *repositories.Repositories
}

// NewTransactionService creates a new transaction service
func NewTransactionService(repos *repositories.Repositories) *TransactionService <span class="cov10" title="15">{
        return &amp;TransactionService{
                repos: repos,
        }
}</span>

// TransactionResponse represents transaction information in responses
type TransactionResponse struct {
        ID             uuid.UUID              `json:"id"`
        UserID         uuid.UUID              `json:"user_id"`
        ExchangeID     uuid.UUID              `json:"exchange_id"`
        SubAccountID   uuid.UUID              `json:"sub_account_id"`
        Timestamp      string                 `json:"timestamp"`
        Direction      string                 `json:"direction"`
        Reason         string                 `json:"reason"`
        Amount         float64                `json:"amount"`
        ClosingBalance float64                `json:"closing_balance"`
        Price          *float64               `json:"price,omitempty"`
        QuoteSymbol    *string                `json:"quote_symbol,omitempty"`
        Info           map[string]interface{} `json:"info"`
}

// TransactionQueryRequest represents transaction query parameters
type TransactionQueryRequest struct {
        Direction *string    `form:"direction" binding:"omitempty,oneof=debit credit"`
        Reason    *string    `form:"reason"`
        StartDate *time.Time `form:"start_date" time_format:"2006-01-02T15:04:05Z07:00"`
        EndDate   *time.Time `form:"end_date" time_format:"2006-01-02T15:04:05Z07:00"`
        MinAmount *float64   `form:"min_amount" binding:"omitempty,min=0"`
        MaxAmount *float64   `form:"max_amount" binding:"omitempty,min=0"`
        Limit     int        `form:"limit" binding:"omitempty,min=1,max=1000"`
        Offset    int        `form:"offset" binding:"omitempty,min=0"`
}

// TransactionQueryResponse represents paginated transaction results
type TransactionQueryResponse struct {
        Transactions []*TransactionResponse `json:"transactions"`
        Total        int64                  `json:"total"`
        Limit        int                    `json:"limit"`
        Offset       int                    `json:"offset"`
        HasMore      bool                   `json:"has_more"`
}

// GetUserTransactions retrieves transactions for a user with filtering
func (s *TransactionService) GetUserTransactions(ctx context.Context, userID uuid.UUID, req *TransactionQueryRequest) (*TransactionQueryResponse, error) <span class="cov6" title="5">{
        // Set default pagination
        if req.Limit == 0 </span><span class="cov4" title="3">{
                req.Limit = 100
        }</span>

        // Validate date range
        <span class="cov6" title="5">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>

        // Validate amount range
        <span class="cov5" title="4">if req.MinAmount != nil &amp;&amp; req.MaxAmount != nil &amp;&amp; *req.MinAmount &gt; *req.MaxAmount </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("min amount cannot be greater than max amount")
        }</span>

        // Create filters
        <span class="cov4" title="3">filters := repositories.TransactionFilters{
                Direction: req.Direction,
                Reason:    req.Reason,
                StartDate: req.StartDate,
                EndDate:   req.EndDate,
                MinAmount: req.MinAmount,
                MaxAmount: req.MaxAmount,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query transactions
        transactions, total, err := s.repos.Transaction.GetByUserID(ctx, userID, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user transactions: %w", err)
        }</span>

        // Convert to response format
        <span class="cov4" title="3">var responses []*TransactionResponse
        for _, transaction := range transactions </span><span class="cov4" title="3">{
                responses = append(responses, s.convertToTransactionResponse(transaction))
        }</span>

        <span class="cov4" title="3">return &amp;TransactionQueryResponse{
                Transactions: responses,
                Total:        total,
                Limit:        req.Limit,
                Offset:       req.Offset,
                HasMore:      int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetSubAccountTransactions retrieves transactions for a specific sub-account
func (s *TransactionService) GetSubAccountTransactions(ctx context.Context, userID, subAccountID uuid.UUID, req *TransactionQueryRequest) (*TransactionQueryResponse, error) <span class="cov3" title="2">{
        // Verify user owns the sub-account
        subAccount, err := s.repos.SubAccount.GetByID(ctx, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to verify sub-account: %w", err)
        }</span>
        <span class="cov3" title="2">if subAccount == nil || subAccount.UserID != userID </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("sub-account not found")
        }</span>

        // Set default pagination
        <span class="cov1" title="1">if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate filters (same as GetUserTransactions)
        <span class="cov1" title="1">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>
        <span class="cov1" title="1">if req.MinAmount != nil &amp;&amp; req.MaxAmount != nil &amp;&amp; *req.MinAmount &gt; *req.MaxAmount </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("min amount cannot be greater than max amount")
        }</span>

        // Create filters
        <span class="cov1" title="1">filters := repositories.TransactionFilters{
                Direction: req.Direction,
                Reason:    req.Reason,
                StartDate: req.StartDate,
                EndDate:   req.EndDate,
                MinAmount: req.MinAmount,
                MaxAmount: req.MaxAmount,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query transactions
        transactions, total, err := s.repos.Transaction.GetBySubAccountID(ctx, subAccountID, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sub-account transactions: %w", err)
        }</span>

        // Convert to response format
        <span class="cov1" title="1">var responses []*TransactionResponse
        for _, transaction := range transactions </span><span class="cov1" title="1">{
                responses = append(responses, s.convertToTransactionResponse(transaction))
        }</span>

        <span class="cov1" title="1">return &amp;TransactionQueryResponse{
                Transactions: responses,
                Total:        total,
                Limit:        req.Limit,
                Offset:       req.Offset,
                HasMore:      int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetExchangeTransactions retrieves transactions for a specific exchange
func (s *TransactionService) GetExchangeTransactions(ctx context.Context, userID, exchangeID uuid.UUID, req *TransactionQueryRequest) (*TransactionQueryResponse, error) <span class="cov1" title="1">{
        // Verify user owns the exchange
        exchange, err := s.repos.Exchange.GetByID(ctx, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to verify exchange: %w", err)
        }</span>
        <span class="cov1" title="1">if exchange == nil || exchange.UserID != userID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("exchange not found")
        }</span>

        // Set default pagination
        <span class="cov1" title="1">if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate filters (same as GetUserTransactions)
        <span class="cov1" title="1">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>
        <span class="cov1" title="1">if req.MinAmount != nil &amp;&amp; req.MaxAmount != nil &amp;&amp; *req.MinAmount &gt; *req.MaxAmount </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("min amount cannot be greater than max amount")
        }</span>

        // Create filters
        <span class="cov1" title="1">filters := repositories.TransactionFilters{
                Direction: req.Direction,
                Reason:    req.Reason,
                StartDate: req.StartDate,
                EndDate:   req.EndDate,
                MinAmount: req.MinAmount,
                MaxAmount: req.MaxAmount,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query transactions
        transactions, total, err := s.repos.Transaction.GetByExchangeID(ctx, exchangeID, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get exchange transactions: %w", err)
        }</span>

        // Convert to response format
        <span class="cov1" title="1">var responses []*TransactionResponse
        for _, transaction := range transactions </span><span class="cov1" title="1">{
                responses = append(responses, s.convertToTransactionResponse(transaction))
        }</span>

        <span class="cov1" title="1">return &amp;TransactionQueryResponse{
                Transactions: responses,
                Total:        total,
                Limit:        req.Limit,
                Offset:       req.Offset,
                HasMore:      int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetTransaction retrieves a specific transaction by ID
func (s *TransactionService) GetTransaction(ctx context.Context, userID, transactionID uuid.UUID) (*TransactionResponse, error) <span class="cov4" title="3">{
        transaction, err := s.repos.Transaction.GetByID(ctx, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get transaction: %w", err)
        }</span>
        <span class="cov4" title="3">if transaction == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("transaction not found")
        }</span>

        // Check if transaction belongs to the user
        <span class="cov3" title="2">if transaction.UserID != userID </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("transaction not found")
        }</span>

        <span class="cov1" title="1">return s.convertToTransactionResponse(transaction), nil</span>
}

// GetTransactionsByTimeRange retrieves transactions within a specific time range
func (s *TransactionService) GetTransactionsByTimeRange(ctx context.Context, userID uuid.UUID, startTime, endTime time.Time, req *TransactionQueryRequest) (*TransactionQueryResponse, error) <span class="cov3" title="2">{
        // Validate time range
        if startTime.After(endTime) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("start time cannot be after end time")
        }</span>

        // Set default pagination
        <span class="cov1" title="1">if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate amount range
        <span class="cov1" title="1">if req.MinAmount != nil &amp;&amp; req.MaxAmount != nil &amp;&amp; *req.MinAmount &gt; *req.MaxAmount </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("min amount cannot be greater than max amount")
        }</span>

        // Create filters (override date filters with provided time range)
        <span class="cov1" title="1">filters := repositories.TransactionFilters{
                Direction: req.Direction,
                Reason:    req.Reason,
                StartDate: &amp;startTime,
                EndDate:   &amp;endTime,
                MinAmount: req.MinAmount,
                MaxAmount: req.MaxAmount,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query transactions by time range
        transactions, _, err := s.repos.Transaction.GetByTimeRange(ctx, startTime, endTime, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get transactions by time range: %w", err)
        }</span>

        // Filter to only include user's transactions
        <span class="cov1" title="1">var userTransactions []*models.Transaction
        for _, transaction := range transactions </span><span class="cov3" title="2">{
                if transaction.UserID == userID </span><span class="cov1" title="1">{
                        userTransactions = append(userTransactions, transaction)
                }</span>
        }

        // Convert to response format
        <span class="cov1" title="1">var responses []*TransactionResponse
        for _, transaction := range userTransactions </span><span class="cov1" title="1">{
                responses = append(responses, s.convertToTransactionResponse(transaction))
        }</span>

        // Recalculate total for user's transactions only
        <span class="cov1" title="1">userTotal := int64(len(userTransactions))

        return &amp;TransactionQueryResponse{
                Transactions: responses,
                Total:        userTotal,
                Limit:        req.Limit,
                Offset:       req.Offset,
                HasMore:      int64(req.Offset+req.Limit) &lt; userTotal,
        }, nil</span>
}

// ListAllTransactions lists all transactions with pagination (admin only)
func (s *TransactionService) ListAllTransactions(ctx context.Context, req *TransactionQueryRequest) (*TransactionQueryResponse, error) <span class="cov1" title="1">{
        // Set default pagination
        if req.Limit == 0 </span><span class="cov0" title="0">{
                req.Limit = 100
        }</span>

        // Validate filters
        <span class="cov1" title="1">if req.StartDate != nil &amp;&amp; req.EndDate != nil &amp;&amp; req.StartDate.After(*req.EndDate) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>
        <span class="cov1" title="1">if req.MinAmount != nil &amp;&amp; req.MaxAmount != nil &amp;&amp; *req.MinAmount &gt; *req.MaxAmount </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("min amount cannot be greater than max amount")
        }</span>

        // For admin queries, we'll use a time range approach to get all transactions
        // Use a very broad time range if no specific dates provided
        <span class="cov1" title="1">startTime := time.Date(2020, 1, 1, 0, 0, 0, 0, time.UTC)
        endTime := time.Now().UTC()

        if req.StartDate != nil </span><span class="cov0" title="0">{
                startTime = *req.StartDate
        }</span>
        <span class="cov1" title="1">if req.EndDate != nil </span><span class="cov0" title="0">{
                endTime = *req.EndDate
        }</span>

        // Create filters
        <span class="cov1" title="1">filters := repositories.TransactionFilters{
                Direction: req.Direction,
                Reason:    req.Reason,
                StartDate: &amp;startTime,
                EndDate:   &amp;endTime,
                MinAmount: req.MinAmount,
                MaxAmount: req.MaxAmount,
                Limit:     req.Limit,
                Offset:    req.Offset,
        }

        // Query all transactions in time range
        transactions, total, err := s.repos.Transaction.GetByTimeRange(ctx, startTime, endTime, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list all transactions: %w", err)
        }</span>

        // Convert to response format
        <span class="cov1" title="1">var responses []*TransactionResponse
        for _, transaction := range transactions </span><span class="cov3" title="2">{
                responses = append(responses, s.convertToTransactionResponse(transaction))
        }</span>

        <span class="cov1" title="1">return &amp;TransactionQueryResponse{
                Transactions: responses,
                Total:        total,
                Limit:        req.Limit,
                Offset:       req.Offset,
                HasMore:      int64(req.Offset+req.Limit) &lt; total,
        }, nil</span>
}

// GetTransactionByID retrieves transaction by ID (admin only)
func (s *TransactionService) GetTransactionByID(ctx context.Context, transactionID uuid.UUID) (*TransactionResponse, error) <span class="cov1" title="1">{
        transaction, err := s.repos.Transaction.GetByID(ctx, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get transaction: %w", err)
        }</span>
        <span class="cov1" title="1">if transaction == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("transaction not found")
        }</span>

        <span class="cov1" title="1">return s.convertToTransactionResponse(transaction), nil</span>
}

// convertToTransactionResponse converts a transaction model to response format
func (s *TransactionService) convertToTransactionResponse(transaction *models.Transaction) *TransactionResponse <span class="cov8" title="10">{
        var info map[string]interface{}
        if err := json.Unmarshal(transaction.Info, &amp;info); err != nil </span><span class="cov0" title="0">{
                info = make(map[string]interface{})
        }</span>

        <span class="cov8" title="10">return &amp;TransactionResponse{
                ID:             transaction.ID,
                UserID:         transaction.UserID,
                ExchangeID:     transaction.ExchangeID,
                SubAccountID:   transaction.SubAccountID,
                Timestamp:      transaction.Timestamp.Format("2006-01-02T15:04:05Z07:00"),
                Direction:      transaction.Direction,
                Reason:         transaction.Reason,
                Amount:         transaction.Amount,
                ClosingBalance: transaction.ClosingBalance,
                Price:          transaction.Price,
                QuoteSymbol:    transaction.QuoteSymbol,
                Info:           info,
        }</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"

        "tiris-backend/internal/models"
        "tiris-backend/internal/repositories"

        "github.com/google/uuid"
        "gorm.io/datatypes"
)

// UserService handles user business logic
type UserService struct {
        repos *repositories.Repositories
}

// NewUserService creates a new user service
func NewUserService(repos *repositories.Repositories) *UserService <span class="cov10" title="10">{
        return &amp;UserService{
                repos: repos,
        }
}</span>

// UserResponse represents user information in responses
type UserResponse struct {
        ID        uuid.UUID              `json:"id"`
        Username  string                 `json:"username"`
        Email     string                 `json:"email"`
        Avatar    *string                `json:"avatar,omitempty"`
        Settings  map[string]interface{} `json:"settings"`
        Info      map[string]interface{} `json:"info"`
        CreatedAt string                 `json:"created_at"`
        UpdatedAt string                 `json:"updated_at"`
}

// UpdateUserRequest represents user update request
type UpdateUserRequest struct {
        Username *string                `json:"username,omitempty" binding:"omitempty,min=3,max=50"`
        Avatar   *string                `json:"avatar,omitempty" binding:"omitempty,url"`
        Settings map[string]interface{} `json:"settings,omitempty"`
}

// GetCurrentUser retrieves current user profile
func (s *UserService) GetCurrentUser(ctx context.Context, userID uuid.UUID) (*UserResponse, error) <span class="cov3" title="2">{
        user, err := s.repos.User.GetByID(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found")
        }</span>

        <span class="cov1" title="1">return s.convertToUserResponse(user), nil</span>
}

// UpdateCurrentUser updates current user profile
func (s *UserService) UpdateCurrentUser(ctx context.Context, userID uuid.UUID, req *UpdateUserRequest) (*UserResponse, error) <span class="cov5" title="3">{
        // Get existing user
        user, err := s.repos.User.GetByID(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>
        <span class="cov3" title="2">if user == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found")
        }</span>

        // Update fields if provided
        <span class="cov3" title="2">if req.Username != nil </span><span class="cov3" title="2">{
                // Check if username is already taken
                existingUser, err := s.repos.User.GetByUsername(ctx, *req.Username)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to check username availability: %w", err)
                }</span>
                <span class="cov3" title="2">if existingUser != nil &amp;&amp; existingUser.ID != userID </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("username already taken")
                }</span>
                <span class="cov1" title="1">user.Username = *req.Username</span>
        }

        <span class="cov1" title="1">if req.Avatar != nil </span><span class="cov1" title="1">{
                user.Avatar = req.Avatar
        }</span>

        <span class="cov1" title="1">if req.Settings != nil </span><span class="cov1" title="1">{
                // Merge with existing settings
                var existingSettings map[string]interface{}
                if err := json.Unmarshal(user.Settings, &amp;existingSettings); err != nil </span><span class="cov0" title="0">{
                        existingSettings = make(map[string]interface{})
                }</span>

                // Merge new settings
                <span class="cov1" title="1">for key, value := range req.Settings </span><span class="cov3" title="2">{
                        existingSettings[key] = value
                }</span>

                <span class="cov1" title="1">settingsJSON, err := json.Marshal(existingSettings)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to encode settings: %w", err)
                }</span>
                <span class="cov1" title="1">user.Settings = datatypes.JSON(settingsJSON)</span>
        }

        // Save updated user
        <span class="cov1" title="1">if err := s.repos.User.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov1" title="1">return s.convertToUserResponse(user), nil</span>
}

// DisableUser disables a user account (admin only)
func (s *UserService) DisableUser(ctx context.Context, userID uuid.UUID) error <span class="cov3" title="2">{
        user, err := s.repos.User.GetByID(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get user: %w", err)
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user not found")
        }</span>

        // Use soft delete to disable the user
        <span class="cov1" title="1">if err := s.repos.User.Delete(ctx, userID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to disable user: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ListUsers lists all users (admin only) with pagination
func (s *UserService) ListUsers(ctx context.Context, limit, offset int) ([]*UserResponse, int64, error) <span class="cov1" title="1">{
        users, total, err := s.repos.User.List(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to list users: %w", err)
        }</span>

        <span class="cov1" title="1">var responses []*UserResponse
        for _, user := range users </span><span class="cov3" title="2">{
                responses = append(responses, s.convertToUserResponse(user))
        }</span>

        <span class="cov1" title="1">return responses, total, nil</span>
}

// GetUserByID retrieves user by ID (admin only)
func (s *UserService) GetUserByID(ctx context.Context, userID uuid.UUID) (*UserResponse, error) <span class="cov1" title="1">{
        user, err := s.repos.User.GetByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found")
        }</span>

        <span class="cov1" title="1">return s.convertToUserResponse(user), nil</span>
}

// GetUserStats retrieves user statistics
func (s *UserService) GetUserStats(ctx context.Context, userID uuid.UUID) (map[string]interface{}, error) <span class="cov1" title="1">{
        // Get user's exchanges count
        exchanges, err := s.repos.Exchange.GetByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user exchanges: %w", err)
        }</span>

        // Get user's sub-accounts count
        <span class="cov1" title="1">subAccounts, err := s.repos.SubAccount.GetByUserID(ctx, userID, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user sub-accounts: %w", err)
        }</span>

        // Calculate total balance across all sub-accounts
        <span class="cov1" title="1">var totalBalance float64
        for _, subAccount := range subAccounts </span><span class="cov5" title="3">{
                totalBalance += subAccount.Balance
        }</span>

        // Get recent transaction count (last 30 days)
        // For simplicity, we'll skip complex date filtering here
        // In a real implementation, you'd add a method to get transaction count by date range

        <span class="cov1" title="1">stats := map[string]interface{}{
                "exchanges_count":    len(exchanges),
                "sub_accounts_count": len(subAccounts),
                "total_balance":      totalBalance,
                "active_exchanges":   len(exchanges), // Assuming all are active for now
        }

        return stats, nil</span>
}

// convertToUserResponse converts a user model to response format
func (s *UserService) convertToUserResponse(user *models.User) *UserResponse <span class="cov7" title="5">{
        var settings map[string]interface{}
        if err := json.Unmarshal(user.Settings, &amp;settings); err != nil </span><span class="cov0" title="0">{
                settings = make(map[string]interface{})
        }</span>

        <span class="cov7" title="5">var info map[string]interface{}
        if err := json.Unmarshal(user.Info, &amp;info); err != nil </span><span class="cov0" title="0">{
                info = make(map[string]interface{})
        }</span>

        <span class="cov7" title="5">return &amp;UserResponse{
                ID:        user.ID,
                Username:  user.Username,
                Email:     user.Email,
                Avatar:    user.Avatar,
                Settings:  settings,
                Info:      info,
                CreatedAt: user.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt: user.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
