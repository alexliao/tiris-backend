
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">tiris-backend/internal/api/auth_handler.go (4.3%)</option>
				
				<option value="file1">tiris-backend/internal/api/exchange_handler.go (0.0%)</option>
				
				<option value="file2">tiris-backend/internal/api/health_handler.go (68.8%)</option>
				
				<option value="file3">tiris-backend/internal/api/router.go (0.0%)</option>
				
				<option value="file4">tiris-backend/internal/api/subaccount_handler.go (0.0%)</option>
				
				<option value="file5">tiris-backend/internal/api/trading_log_handler.go (0.0%)</option>
				
				<option value="file6">tiris-backend/internal/api/transaction_handler.go (0.0%)</option>
				
				<option value="file7">tiris-backend/internal/api/types.go (0.0%)</option>
				
				<option value="file8">tiris-backend/internal/api/user_handler.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "net/http"
        "time"

        "tiris-backend/internal/middleware"
        "tiris-backend/internal/services"

        "github.com/gin-gonic/gin"
)

// AuthHandler handles authentication endpoints
type AuthHandler struct {
        authService *services.AuthService
}

// NewAuthHandler creates a new authentication handler
func NewAuthHandler(authService *services.AuthService) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                authService: authService,
        }
}</span>

// Login initiates OAuth login flow
// @Summary Initiate OAuth login
// @Description Initiates OAuth login flow and returns authorization URL
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body services.LoginRequest true "Login request"
// @Success 200 {object} services.LoginResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/login [post]
func (h *AuthHandler) Login(c *gin.Context) <span class="cov0" title="0">{
        var req services.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "INVALID_REQUEST",
                                Message: "Invalid request format",
                                Details: err.Error(),
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">response, err := h.authService.InitiateLogin(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "LOGIN_FAILED",
                                Message: "Failed to initiate login",
                                Details: err.Error(),
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        // Store state in session/cookie for validation (in production, use secure session storage)
        <span class="cov0" title="0">c.SetCookie("oauth_state", response.State, 600, "/", "", false, true) // 10 minutes

        c.JSON(http.StatusOK, SuccessResponse{
                Success: true,
                Data:    response,
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   getTraceID(c),
                },
        })</span>
}

// Callback handles OAuth callback
// @Summary Handle OAuth callback
// @Description Handles OAuth callback and returns JWT tokens
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body services.CallbackRequest true "Callback request"
// @Success 200 {object} services.AuthResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/callback [post]
func (h *AuthHandler) Callback(c *gin.Context) <span class="cov0" title="0">{
        var req services.CallbackRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "INVALID_REQUEST",
                                Message: "Invalid request format",
                                Details: err.Error(),
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        // Get expected state from cookie
        <span class="cov0" title="0">expectedState, err := c.Cookie("oauth_state")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "INVALID_STATE",
                                Message: "Missing or invalid state parameter",
                                Details: "OAuth state not found in session",
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        // Clear the state cookie
        <span class="cov0" title="0">c.SetCookie("oauth_state", "", -1, "/", "", false, true)

        response, err := h.authService.HandleCallback(c.Request.Context(), &amp;req, expectedState)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "OAUTH_CALLBACK_FAILED",
                                Message: "OAuth callback failed",
                                Details: err.Error(),
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, SuccessResponse{
                Success: true,
                Data:    response,
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   getTraceID(c),
                },
        })</span>
}

// Refresh refreshes access token using refresh token
// @Summary Refresh access token
// @Description Refreshes access token using refresh token
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body services.RefreshRequest true "Refresh request"
// @Success 200 {object} services.AuthResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/refresh [post]
func (h *AuthHandler) Refresh(c *gin.Context) <span class="cov0" title="0">{
        var req services.RefreshRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "INVALID_REQUEST",
                                Message: "Invalid request format",
                                Details: err.Error(),
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">response, err := h.authService.RefreshToken(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "TOKEN_REFRESH_FAILED",
                                Message: "Failed to refresh token",
                                Details: err.Error(),
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, SuccessResponse{
                Success: true,
                Data:    response,
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   getTraceID(c),
                },
        })</span>
}

// Logout logs out the current user
// @Summary Logout user
// @Description Logs out the current user and invalidates session
// @Tags Authentication
// @Produce json
// @Security BearerAuth
// @Success 200 {object} SuccessResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/logout [post]
func (h *AuthHandler) Logout(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "AUTH_REQUIRED",
                                Message: "Authentication required",
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">err := h.authService.Logout(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "LOGOUT_FAILED",
                                Message: "Failed to logout",
                                Details: err.Error(),
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, SuccessResponse{
                Success: true,
                Data: gin.H{
                        "message": "Logged out successfully",
                },
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   getTraceID(c),
                },
        })</span>
}

// getTraceID extracts trace ID from context
func getTraceID(c *gin.Context) string <span class="cov8" title="1">{
        if traceID, exists := c.Get("request_id"); exists </span><span class="cov0" title="0">{
                if id, ok := traceID.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "net/http"
        "strconv"

        "tiris-backend/internal/middleware"
        "tiris-backend/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// ExchangeHandler handles exchange management endpoints
type ExchangeHandler struct {
        exchangeService *services.ExchangeService
}

// NewExchangeHandler creates a new exchange handler
func NewExchangeHandler(exchangeService *services.ExchangeService) *ExchangeHandler <span class="cov0" title="0">{
        return &amp;ExchangeHandler{
                exchangeService: exchangeService,
        }
}</span>

// CreateExchange creates a new exchange configuration
// @Summary Create new exchange
// @Description Creates a new exchange configuration for the authenticated user
// @Tags Exchanges
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body services.CreateExchangeRequest true "Create exchange request"
// @Success 201 {object} services.ExchangeResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /exchanges [post]
func (h *ExchangeHandler) CreateExchange(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.CreateExchangeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_REQUEST",
                        "Invalid request format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchange, err := h.exchangeService.CreateExchange(c.Request.Context(), userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange name already exists" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "EXCHANGE_NAME_EXISTS",
                                "Exchange name already exists",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "maximum number of exchanges reached (10)" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "EXCHANGE_LIMIT_REACHED",
                                "Maximum number of exchanges reached",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "EXCHANGE_CREATE_FAILED",
                        "Failed to create exchange",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, CreateSuccessResponse(exchange, getTraceID(c)))</span>
}

// GetUserExchanges retrieves all exchanges for the current user
// @Summary Get user exchanges
// @Description Retrieves all exchange configurations for the authenticated user
// @Tags Exchanges
// @Produce json
// @Security BearerAuth
// @Success 200 {array} services.ExchangeResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /exchanges [get]
func (h *ExchangeHandler) GetUserExchanges(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchanges, err := h.exchangeService.GetUserExchanges(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "EXCHANGES_GET_FAILED",
                        "Failed to get exchanges",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "exchanges": exchanges,
        }

        c.JSON(http.StatusOK, CreateSuccessResponse(response, getTraceID(c)))</span>
}

// GetExchange retrieves a specific exchange by ID
// @Summary Get exchange by ID
// @Description Retrieves a specific exchange configuration by ID (must belong to authenticated user)
// @Tags Exchanges
// @Produce json
// @Security BearerAuth
// @Param id path string true "Exchange ID"
// @Success 200 {object} services.ExchangeResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /exchanges/{id} [get]
func (h *ExchangeHandler) GetExchange(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchangeIDStr := c.Param("id")
        exchangeID, err := uuid.Parse(exchangeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_EXCHANGE_ID",
                        "Invalid exchange ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchange, err := h.exchangeService.GetExchange(c.Request.Context(), userID, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "EXCHANGE_GET_FAILED",
                        "Failed to get exchange",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(exchange, getTraceID(c)))</span>
}

// UpdateExchange updates an existing exchange
// @Summary Update exchange
// @Description Updates an existing exchange configuration (must belong to authenticated user)
// @Tags Exchanges
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Exchange ID"
// @Param request body services.UpdateExchangeRequest true "Update exchange request"
// @Success 200 {object} services.ExchangeResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /exchanges/{id} [put]
func (h *ExchangeHandler) UpdateExchange(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchangeIDStr := c.Param("id")
        exchangeID, err := uuid.Parse(exchangeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_EXCHANGE_ID",
                        "Invalid exchange ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.UpdateExchangeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_REQUEST",
                        "Invalid request format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchange, err := h.exchangeService.UpdateExchange(c.Request.Context(), userID, exchangeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "exchange name already exists" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "EXCHANGE_NAME_EXISTS",
                                "Exchange name already exists",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "EXCHANGE_UPDATE_FAILED",
                        "Failed to update exchange",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(exchange, getTraceID(c)))</span>
}

// DeleteExchange deletes an exchange
// @Summary Delete exchange
// @Description Deletes an exchange configuration (must belong to authenticated user)
// @Tags Exchanges
// @Produce json
// @Security BearerAuth
// @Param id path string true "Exchange ID"
// @Success 200 {object} SuccessResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /exchanges/{id} [delete]
func (h *ExchangeHandler) DeleteExchange(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchangeIDStr := c.Param("id")
        exchangeID, err := uuid.Parse(exchangeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_EXCHANGE_ID",
                        "Invalid exchange ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">err = h.exchangeService.DeleteExchange(c.Request.Context(), userID, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "cannot delete exchange with existing sub-accounts" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "EXCHANGE_HAS_SUBACCOUNTS",
                                "Cannot delete exchange with existing sub-accounts",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "EXCHANGE_DELETE_FAILED",
                        "Failed to delete exchange",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "message": "Exchange deleted successfully",
        }

        c.JSON(http.StatusOK, CreateSuccessResponse(response, getTraceID(c)))</span>
}

// ListExchanges lists all exchanges (admin only)
// @Summary List all exchanges
// @Description Lists all exchange configurations with pagination (admin only)
// @Tags Exchanges
// @Produce json
// @Security BearerAuth
// @Param limit query int false "Number of exchanges to return" default(100)
// @Param offset query int false "Number of exchanges to skip" default(0)
// @Success 200 {object} PaginatedResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /admin/exchanges [get]
func (h *ExchangeHandler) ListExchanges(c *gin.Context) <span class="cov0" title="0">{
        // Parse pagination parameters
        limit := 100
        if l := c.Query("limit"); l != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(l); err == nil &amp;&amp; parsed &gt; 0 &amp;&amp; parsed &lt;= 1000 </span><span class="cov0" title="0">{
                        limit = parsed
                }</span>
        }

        <span class="cov0" title="0">offset := 0
        if o := c.Query("offset"); o != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(o); err == nil &amp;&amp; parsed &gt;= 0 </span><span class="cov0" title="0">{
                        offset = parsed
                }</span>
        }

        <span class="cov0" title="0">exchanges, total, err := h.exchangeService.ListExchanges(c.Request.Context(), limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "EXCHANGES_LIST_FAILED",
                        "Failed to list exchanges",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        // Create pagination metadata
        <span class="cov0" title="0">hasMore := int64(offset+limit) &lt; total
        var nextOffset *int
        if hasMore </span><span class="cov0" title="0">{
                next := offset + limit
                nextOffset = &amp;next
        }</span>

        <span class="cov0" title="0">pagination := &amp;PaginationMetadata{
                Total:      total,
                Limit:      limit,
                Offset:     offset,
                HasMore:    hasMore,
                NextOffset: nextOffset,
        }

        response := map[string]interface{}{
                "exchanges": exchanges,
        }

        c.JSON(http.StatusOK, CreatePaginatedResponse(response, pagination, getTraceID(c)))</span>
}

// GetExchangeByID retrieves exchange by ID (admin only)
// @Summary Get exchange by ID
// @Description Retrieves an exchange by ID (admin only)
// @Tags Exchanges
// @Produce json
// @Security BearerAuth
// @Param id path string true "Exchange ID"
// @Success 200 {object} services.ExchangeResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /admin/exchanges/{id} [get]
func (h *ExchangeHandler) GetExchangeByID(c *gin.Context) <span class="cov0" title="0">{
        exchangeIDStr := c.Param("id")
        exchangeID, err := uuid.Parse(exchangeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_EXCHANGE_ID",
                        "Invalid exchange ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchange, err := h.exchangeService.GetExchangeByID(c.Request.Context(), exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "EXCHANGE_GET_FAILED",
                        "Failed to get exchange",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(exchange, getTraceID(c)))</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "context"
        "net/http"
        "time"

        "tiris-backend/internal/database"
        "tiris-backend/internal/nats"

        "github.com/gin-gonic/gin"
)

// HealthHandler handles health check endpoints
type HealthHandler struct {
        db          *database.DB
        natsManager *nats.Manager
}

// NewHealthHandler creates a new health handler
func NewHealthHandler(db *database.DB, natsManager *nats.Manager) *HealthHandler <span class="cov8" title="1">{
        return &amp;HealthHandler{
                db:          db,
                natsManager: natsManager,
        }
}</span>

// HealthStatus represents the health status of a component
type HealthStatus struct {
        Status  string                 `json:"status"`
        Message string                 `json:"message,omitempty"`
        Details map[string]interface{} `json:"details,omitempty"`
}

// HealthResponse represents the overall health response
type HealthResponse struct {
        Status       string                  `json:"status"`
        Timestamp    string                  `json:"timestamp"`
        Version      string                  `json:"version"`
        Dependencies map[string]HealthStatus `json:"dependencies"`
}

// LivenessProbe handles Kubernetes liveness probe
// @Summary Liveness probe
// @Description Kubernetes liveness probe - checks if the application is running
// @Tags Health
// @Produce json
// @Success 200 {object} SuccessResponse
// @Router /health/live [get]
func (h *HealthHandler) LivenessProbe(c *gin.Context) <span class="cov8" title="1">{
        response := SuccessResponse{
                Success: true,
                Data: gin.H{
                        "status":    "healthy",
                        "timestamp": time.Now().UTC().Format(time.RFC3339),
                        "message":   "Service is alive",
                },
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   getTraceID(c),
                },
        }

        c.JSON(http.StatusOK, response)
}</span>

// ReadinessProbe handles Kubernetes readiness probe
// @Summary Readiness probe
// @Description Kubernetes readiness probe - checks if the application is ready to serve traffic
// @Tags Health
// @Produce json
// @Success 200 {object} HealthResponse
// @Failure 503 {object} ErrorResponse
// @Router /health/ready [get]
func (h *HealthHandler) ReadinessProbe(c *gin.Context) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c.Request.Context(), 5*time.Second)
        defer cancel()

        dependencies := make(map[string]HealthStatus)
        overallHealthy := true

        // Check database connectivity
        dbStatus := h.checkDatabase(ctx)
        dependencies["database"] = dbStatus
        if dbStatus.Status != "healthy" </span><span class="cov8" title="1">{
                overallHealthy = false
        }</span>

        // Check NATS connectivity
        <span class="cov8" title="1">natsStatus := h.checkNATS(ctx)
        dependencies["nats"] = natsStatus
        if natsStatus.Status != "healthy" </span><span class="cov8" title="1">{
                overallHealthy = false
        }</span>

        // Determine overall status
        <span class="cov8" title="1">status := "healthy"
        httpStatus := http.StatusOK
        if !overallHealthy </span><span class="cov8" title="1">{
                status = "unhealthy"
                httpStatus = http.StatusServiceUnavailable
        }</span>

        <span class="cov8" title="1">healthResponse := HealthResponse{
                Status:       status,
                Timestamp:    time.Now().UTC().Format(time.RFC3339),
                Version:      "1.0.0", // This could be injected from build info
                Dependencies: dependencies,
        }

        if overallHealthy </span><span class="cov0" title="0">{
                c.JSON(httpStatus, SuccessResponse{
                        Success: true,
                        Data:    healthResponse,
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
        }</span> else<span class="cov8" title="1"> {
                c.JSON(httpStatus, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "SERVICE_UNAVAILABLE",
                                Message: "One or more dependencies are unhealthy",
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
        }</span>
}

// HealthCheck provides detailed health information
// @Summary Detailed health check
// @Description Provides detailed health information about the service and its dependencies
// @Tags Health
// @Produce json
// @Success 200 {object} HealthResponse
// @Failure 503 {object} ErrorResponse
// @Router /health [get]
func (h *HealthHandler) HealthCheck(c *gin.Context) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c.Request.Context(), 10*time.Second)
        defer cancel()

        dependencies := make(map[string]HealthStatus)
        overallHealthy := true

        // Check database with detailed info
        dbStatus := h.checkDatabaseDetailed(ctx)
        dependencies["database"] = dbStatus
        if dbStatus.Status != "healthy" </span><span class="cov8" title="1">{
                overallHealthy = false
        }</span>

        // Check NATS with detailed info
        <span class="cov8" title="1">natsStatus := h.checkNATSDetailed(ctx)
        dependencies["nats"] = natsStatus
        if natsStatus.Status != "healthy" </span><span class="cov8" title="1">{
                overallHealthy = false
        }</span>

        // Add system info
        <span class="cov8" title="1">systemStatus := h.getSystemInfo()
        dependencies["system"] = systemStatus

        // Determine overall status
        status := "healthy"
        httpStatus := http.StatusOK
        if !overallHealthy </span><span class="cov8" title="1">{
                status = "degraded"
                httpStatus = http.StatusServiceUnavailable
        }</span>

        <span class="cov8" title="1">healthResponse := HealthResponse{
                Status:       status,
                Timestamp:    time.Now().UTC().Format(time.RFC3339),
                Version:      "1.0.0",
                Dependencies: dependencies,
        }

        if overallHealthy </span><span class="cov0" title="0">{
                c.JSON(httpStatus, SuccessResponse{
                        Success: true,
                        Data:    healthResponse,
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
        }</span> else<span class="cov8" title="1"> {
                c.JSON(httpStatus, ErrorResponse{
                        Success: false,
                        Error: ErrorDetail{
                                Code:    "SERVICE_DEGRADED",
                                Message: "Service is running but some dependencies are unhealthy",
                        },
                        Metadata: ResponseMetadata{
                                Timestamp: time.Now().UTC().Format(time.RFC3339),
                                TraceID:   getTraceID(c),
                        },
                })
        }</span>
}

// checkDatabase performs a basic database connectivity check
func (h *HealthHandler) checkDatabase(ctx context.Context) HealthStatus <span class="cov8" title="1">{
        if h.db == nil </span><span class="cov8" title="1">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "Database not initialized",
                }
        }</span>

        // Simple ping to check connectivity
        <span class="cov0" title="0">sqlDB, err := h.db.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "Failed to get database connection",
                }
        }</span>

        <span class="cov0" title="0">if err := sqlDB.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "Database ping failed: " + err.Error(),
                }
        }</span>

        <span class="cov0" title="0">return HealthStatus{
                Status:  "healthy",
                Message: "Database is accessible",
        }</span>
}

// checkDatabaseDetailed performs a detailed database health check
func (h *HealthHandler) checkDatabaseDetailed(ctx context.Context) HealthStatus <span class="cov8" title="1">{
        if h.db == nil </span><span class="cov8" title="1">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "Database not initialized",
                }
        }</span>

        <span class="cov0" title="0">sqlDB, err := h.db.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "Failed to get database connection",
                }
        }</span>

        // Check connectivity
        <span class="cov0" title="0">if err := sqlDB.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "Database ping failed: " + err.Error(),
                }
        }</span>

        // Get connection pool stats
        <span class="cov0" title="0">stats := sqlDB.Stats()
        details := map[string]interface{}{
                "open_connections":     stats.OpenConnections,
                "in_use":              stats.InUse,
                "idle":                stats.Idle,
                "max_open_connections": stats.MaxOpenConnections,
                "max_idle_closed":     stats.MaxIdleClosed,
                "max_lifetime_closed":  stats.MaxLifetimeClosed,
                "wait_count":          stats.WaitCount,
                "wait_duration":       stats.WaitDuration.String(),
        }

        return HealthStatus{
                Status:  "healthy",
                Message: "Database is accessible with connection pool statistics",
                Details: details,
        }</span>
}

// checkNATS performs a basic NATS connectivity check
func (h *HealthHandler) checkNATS(ctx context.Context) HealthStatus <span class="cov8" title="1">{
        if h.natsManager == nil </span><span class="cov8" title="1">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "NATS manager not initialized",
                }
        }</span>

        <span class="cov0" title="0">if !h.natsManager.IsConnected() </span><span class="cov0" title="0">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "NATS connection is not established",
                }
        }</span>

        <span class="cov0" title="0">return HealthStatus{
                Status:  "healthy",
                Message: "NATS is connected",
        }</span>
}

// checkNATSDetailed performs a detailed NATS health check
func (h *HealthHandler) checkNATSDetailed(ctx context.Context) HealthStatus <span class="cov8" title="1">{
        if h.natsManager == nil </span><span class="cov8" title="1">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "NATS manager not initialized",
                }
        }</span>

        <span class="cov0" title="0">if !h.natsManager.IsConnected() </span><span class="cov0" title="0">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "NATS connection is not established",
                }
        }</span>

        // Get detailed connection info
        <span class="cov0" title="0">details := h.natsManager.GetConnectionStats()
        if details == nil </span><span class="cov0" title="0">{
                return HealthStatus{
                        Status:  "unhealthy",
                        Message: "Unable to retrieve connection statistics",
                }
        }</span>

        <span class="cov0" title="0">return HealthStatus{
                Status:  "healthy",
                Message: "NATS is connected with detailed statistics",
                Details: details,
        }</span>
}

// getSystemInfo provides basic system information
func (h *HealthHandler) getSystemInfo() HealthStatus <span class="cov8" title="1">{
        details := map[string]interface{}{
                "uptime":      time.Since(startTime).String(),
                "start_time":  startTime.Format(time.RFC3339),
                "go_version":  "1.23",  // This could be injected from build info
                "environment": "development", // This should come from config
        }

        return HealthStatus{
                Status:  "healthy",
                Message: "System information",
                Details: details,
        }
}</span>

// startTime tracks when the service started
var startTime = time.Now()</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "time"

        "tiris-backend/internal/config"
        "tiris-backend/internal/database"
        "tiris-backend/internal/metrics"
        "tiris-backend/internal/middleware"
        "tiris-backend/internal/nats"
        "tiris-backend/internal/repositories"
        "tiris-backend/internal/services"
        "tiris-backend/pkg/auth"

        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Server represents the API server
type Server struct {
        router             *gin.Engine
        config             *config.Config
        db                 *database.DB
        natsManager        *nats.Manager
        repos              *repositories.Repositories
        jwtManager         *auth.JWTManager
        authService        *services.AuthService
        userService        *services.UserService
        exchangeService    *services.ExchangeService
        subAccountService  *services.SubAccountService
        transactionService *services.TransactionService
        tradingLogService  *services.TradingLogService
        metrics            *metrics.Metrics
}

// NewServer creates a new API server
func NewServer(cfg *config.Config, repos *repositories.Repositories) *Server <span class="cov0" title="0">{
        // Initialize JWT manager
        jwtManager := auth.NewJWTManager(
                cfg.Auth.JWTSecret,
                cfg.Auth.RefreshSecret,
                time.Duration(cfg.Auth.JWTExpiration)*time.Second,
                time.Duration(cfg.Auth.RefreshExpiration)*time.Second,
        )

        // Initialize OAuth manager
        oauthConfig := auth.OAuthConfig{
                Google: auth.GoogleOAuthConfig{
                        ClientID:     cfg.OAuth.Google.ClientID,
                        ClientSecret: cfg.OAuth.Google.ClientSecret,
                        RedirectURL:  cfg.OAuth.Google.RedirectURL,
                },
                WeChat: auth.WeChatOAuthConfig{
                        AppID:       cfg.OAuth.WeChat.AppID,
                        AppSecret:   cfg.OAuth.WeChat.AppSecret,
                        RedirectURL: cfg.OAuth.WeChat.RedirectURL,
                },
        }
        oauthManager := auth.NewOAuthManager(oauthConfig)

        // Initialize metrics
        metricsInstance := metrics.NewMetrics()

        // Initialize services
        authService := services.NewAuthService(repos, jwtManager, oauthManager)
        userService := services.NewUserService(repos)
        exchangeService := services.NewExchangeService(repos)
        subAccountService := services.NewSubAccountService(repos)
        transactionService := services.NewTransactionService(repos)
        tradingLogService := services.NewTradingLogService(repos)

        return &amp;Server{
                config:             cfg,
                repos:              repos,
                jwtManager:         jwtManager,
                authService:        authService,
                userService:        userService,
                exchangeService:    exchangeService,
                subAccountService:  subAccountService,
                transactionService: transactionService,
                tradingLogService:  tradingLogService,
                metrics:            metricsInstance,
        }
}</span>

// SetupRoutes sets up all API routes
func (s *Server) SetupRoutes() *gin.Engine <span class="cov0" title="0">{
        router := gin.New()

        // Determine CORS origins based on environment
        var allowedOrigins []string
        if s.config.Environment == "production" </span><span class="cov0" title="0">{
                allowedOrigins = []string{"https://tiris.ai"}
        }</span> else<span class="cov0" title="0"> {
                allowedOrigins = []string{"https://dev.tiris.ai", "http://localhost:3000"}
        }</span>

        // Global middleware
        <span class="cov0" title="0">router.Use(middleware.ErrorLoggingMiddleware())
        router.Use(middleware.SecurityHeadersMiddleware())
        router.Use(middleware.CORSMiddleware(allowedOrigins))
        router.Use(middleware.RequestIDMiddleware())
        router.Use(middleware.HealthCheckLoggingMiddleware())
        router.Use(s.metrics.HTTPMetricsMiddleware())

        // Health check endpoints (no authentication required)
        s.setupHealthRoutes(router)

        // Metrics endpoint (no authentication required)
        s.setupMetricsRoutes(router)

        // API routes with rate limiting
        api := router.Group("/v1")
        api.Use(middleware.APIRateLimitMiddleware())

        // Authentication routes
        s.setupAuthRoutes(api)

        // Protected routes (require authentication)
        protected := api.Group("")
        protected.Use(middleware.AuthMiddleware(s.jwtManager))

        // User management routes
        s.setupUserRoutes(protected)

        // Exchange management routes
        s.setupExchangeRoutes(protected)

        // Sub-account management routes
        s.setupSubAccountRoutes(protected)

        // Transaction query routes
        s.setupTransactionRoutes(protected)

        // Trading log management routes
        s.setupTradingLogRoutes(protected)

        s.router = router
        return router</span>
}

// setupHealthRoutes sets up health check routes
func (s *Server) setupHealthRoutes(router *gin.Engine) <span class="cov0" title="0">{
        healthHandler := NewHealthHandler(s.db, s.natsManager)

        // Kubernetes liveness probe - simple check that the app is running
        router.GET("/health/live", healthHandler.LivenessProbe)
        
        // Kubernetes readiness probe - check if app can serve traffic
        router.GET("/health/ready", healthHandler.ReadinessProbe)
        
        // Detailed health check with dependency information
        router.GET("/health", healthHandler.HealthCheck)
}</span>

// setupAuthRoutes sets up authentication routes
func (s *Server) setupAuthRoutes(api *gin.RouterGroup) <span class="cov0" title="0">{
        authHandler := NewAuthHandler(s.authService)

        auth := api.Group("/auth")
        auth.Use(middleware.AuthRateLimitMiddleware()) // Stricter rate limiting for auth

        auth.POST("/login", authHandler.Login)
        auth.POST("/callback", authHandler.Callback)
        auth.POST("/refresh", authHandler.Refresh)
        auth.POST("/logout", middleware.AuthMiddleware(s.jwtManager), authHandler.Logout)
}</span>

// setupUserRoutes sets up user management routes
func (s *Server) setupUserRoutes(protected *gin.RouterGroup) <span class="cov0" title="0">{
        userHandler := NewUserHandler(s.userService)

        users := protected.Group("/users")

        // Current user routes
        users.GET("/me", userHandler.GetCurrentUser)
        users.PUT("/me", userHandler.UpdateCurrentUser)
        users.GET("/me/stats", userHandler.GetUserStats)

        // Admin only routes
        adminUsers := users.Group("")
        adminUsers.Use(middleware.AdminMiddleware())

        adminUsers.GET("", userHandler.ListUsers)
        adminUsers.GET("/:id", userHandler.GetUserByID)
        adminUsers.PUT("/:id/disable", userHandler.DisableUser)
}</span>

// setupExchangeRoutes sets up exchange management routes
func (s *Server) setupExchangeRoutes(protected *gin.RouterGroup) <span class="cov0" title="0">{
        exchangeHandler := NewExchangeHandler(s.exchangeService)

        exchanges := protected.Group("/exchanges")

        // User exchange routes
        exchanges.POST("", exchangeHandler.CreateExchange)
        exchanges.GET("", exchangeHandler.GetUserExchanges)
        exchanges.GET("/:id", exchangeHandler.GetExchange)
        exchanges.PUT("/:id", exchangeHandler.UpdateExchange)
        exchanges.DELETE("/:id", exchangeHandler.DeleteExchange)

        // Admin exchange routes
        adminExchanges := protected.Group("/admin/exchanges")
        adminExchanges.Use(middleware.AdminMiddleware())

        adminExchanges.GET("", exchangeHandler.ListExchanges)
        adminExchanges.GET("/:id", exchangeHandler.GetExchangeByID)
}</span>

// setupSubAccountRoutes sets up sub-account management routes
func (s *Server) setupSubAccountRoutes(protected *gin.RouterGroup) <span class="cov0" title="0">{
        subAccountHandler := NewSubAccountHandler(s.subAccountService)

        subAccounts := protected.Group("/sub-accounts")

        // User sub-account routes
        subAccounts.POST("", subAccountHandler.CreateSubAccount)
        subAccounts.GET("", subAccountHandler.GetUserSubAccounts)
        subAccounts.GET("/:id", subAccountHandler.GetSubAccount)
        subAccounts.PUT("/:id", subAccountHandler.UpdateSubAccount)
        subAccounts.PUT("/:id/balance", subAccountHandler.UpdateBalance)
        subAccounts.DELETE("/:id", subAccountHandler.DeleteSubAccount)

        // Symbol-based queries
        subAccounts.GET("/symbol/:symbol", subAccountHandler.GetSubAccountsBySymbol)
}</span>

// setupTransactionRoutes sets up transaction query routes
func (s *Server) setupTransactionRoutes(protected *gin.RouterGroup) <span class="cov0" title="0">{
        transactionHandler := NewTransactionHandler(s.transactionService)

        transactions := protected.Group("/transactions")

        // User transaction routes
        transactions.GET("", transactionHandler.GetUserTransactions)
        transactions.GET("/:id", transactionHandler.GetTransaction)
        transactions.GET("/sub-account/:sub_account_id", transactionHandler.GetSubAccountTransactions)
        transactions.GET("/exchange/:exchange_id", transactionHandler.GetExchangeTransactions)
        transactions.GET("/time-range", transactionHandler.GetTransactionsByTimeRange)

        // Admin transaction routes
        adminTransactions := protected.Group("/admin/transactions")
        adminTransactions.Use(middleware.AdminMiddleware())

        adminTransactions.GET("", transactionHandler.ListAllTransactions)
        adminTransactions.GET("/:id", transactionHandler.GetTransactionByID)
}</span>

// setupTradingLogRoutes sets up trading log management routes
func (s *Server) setupTradingLogRoutes(protected *gin.RouterGroup) <span class="cov0" title="0">{
        tradingLogHandler := NewTradingLogHandler(s.tradingLogService)

        tradingLogs := protected.Group("/trading-logs")

        // User trading log routes
        tradingLogs.POST("", tradingLogHandler.CreateTradingLog)
        tradingLogs.GET("", tradingLogHandler.GetUserTradingLogs)
        tradingLogs.GET("/:id", tradingLogHandler.GetTradingLog)
        tradingLogs.DELETE("/:id", tradingLogHandler.DeleteTradingLog)
        tradingLogs.GET("/sub-account/:sub_account_id", tradingLogHandler.GetSubAccountTradingLogs)
        tradingLogs.GET("/exchange/:exchange_id", tradingLogHandler.GetExchangeTradingLogs)
        tradingLogs.GET("/time-range", tradingLogHandler.GetTradingLogsByTimeRange)

        // Admin trading log routes
        adminTradingLogs := protected.Group("/admin/trading-logs")
        adminTradingLogs.Use(middleware.AdminMiddleware())

        adminTradingLogs.GET("", tradingLogHandler.ListAllTradingLogs)
        adminTradingLogs.GET("/:id", tradingLogHandler.GetTradingLogByID)
}</span>

// setupMetricsRoutes sets up Prometheus metrics endpoints
func (s *Server) setupMetricsRoutes(router *gin.Engine) <span class="cov0" title="0">{
        router.GET("/metrics", gin.WrapH(promhttp.Handler()))
}</span>

// GetRouter returns the configured router
func (s *Server) GetRouter() *gin.Engine <span class="cov0" title="0">{
        if s.router == nil </span><span class="cov0" title="0">{
                return s.SetupRoutes()
        }</span>
        <span class="cov0" title="0">return s.router</span>
}

// GetMetrics returns the metrics instance
func (s *Server) GetMetrics() *metrics.Metrics <span class="cov0" title="0">{
        return s.metrics
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "net/http"

        "tiris-backend/internal/middleware"
        "tiris-backend/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// SubAccountHandler handles sub-account management endpoints
type SubAccountHandler struct {
        subAccountService *services.SubAccountService
}

// NewSubAccountHandler creates a new sub-account handler
func NewSubAccountHandler(subAccountService *services.SubAccountService) *SubAccountHandler <span class="cov0" title="0">{
        return &amp;SubAccountHandler{
                subAccountService: subAccountService,
        }
}</span>

// CreateSubAccount creates a new sub-account
// @Summary Create new sub-account
// @Description Creates a new sub-account for the authenticated user
// @Tags SubAccounts
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body services.CreateSubAccountRequest true "Create sub-account request"
// @Success 201 {object} services.SubAccountResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /sub-accounts [post]
func (h *SubAccountHandler) CreateSubAccount(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.CreateSubAccountRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_REQUEST",
                        "Invalid request format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccount, err := h.subAccountService.CreateSubAccount(c.Request.Context(), userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "sub-account name already exists for this exchange" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "SUBACCOUNT_NAME_EXISTS",
                                "Sub-account name already exists for this exchange",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "SUBACCOUNT_CREATE_FAILED",
                        "Failed to create sub-account",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, CreateSuccessResponse(subAccount, getTraceID(c)))</span>
}

// GetUserSubAccounts retrieves all sub-accounts for the current user
// @Summary Get user sub-accounts
// @Description Retrieves all sub-account configurations for the authenticated user, optionally filtered by exchange
// @Tags SubAccounts
// @Produce json
// @Security BearerAuth
// @Param exchange_id query string false "Filter by exchange ID"
// @Success 200 {array} services.SubAccountResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /sub-accounts [get]
func (h *SubAccountHandler) GetUserSubAccounts(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        // Parse optional exchange_id filter
        <span class="cov0" title="0">var exchangeID *uuid.UUID
        if exchangeIDStr := c.Query("exchange_id"); exchangeIDStr != "" </span><span class="cov0" title="0">{
                if parsed, err := uuid.Parse(exchangeIDStr); err == nil </span><span class="cov0" title="0">{
                        exchangeID = &amp;parsed
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_EXCHANGE_ID",
                                "Invalid exchange ID format",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
        }

        <span class="cov0" title="0">subAccounts, err := h.subAccountService.GetUserSubAccounts(c.Request.Context(), userID, exchangeID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "SUBACCOUNTS_GET_FAILED",
                        "Failed to get sub-accounts",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "sub_accounts": subAccounts,
        }

        c.JSON(http.StatusOK, CreateSuccessResponse(response, getTraceID(c)))</span>
}

// GetSubAccount retrieves a specific sub-account by ID
// @Summary Get sub-account by ID
// @Description Retrieves a specific sub-account configuration by ID (must belong to authenticated user)
// @Tags SubAccounts
// @Produce json
// @Security BearerAuth
// @Param id path string true "Sub-account ID"
// @Success 200 {object} services.SubAccountResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /sub-accounts/{id} [get]
func (h *SubAccountHandler) GetSubAccount(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccountIDStr := c.Param("id")
        subAccountID, err := uuid.Parse(subAccountIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_SUBACCOUNT_ID",
                        "Invalid sub-account ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccount, err := h.subAccountService.GetSubAccount(c.Request.Context(), userID, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "sub-account not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "SUBACCOUNT_NOT_FOUND",
                                "Sub-account not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "SUBACCOUNT_GET_FAILED",
                        "Failed to get sub-account",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(subAccount, getTraceID(c)))</span>
}

// UpdateSubAccount updates an existing sub-account
// @Summary Update sub-account
// @Description Updates an existing sub-account configuration (must belong to authenticated user)
// @Tags SubAccounts
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Sub-account ID"
// @Param request body services.UpdateSubAccountRequest true "Update sub-account request"
// @Success 200 {object} services.SubAccountResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /sub-accounts/{id} [put]
func (h *SubAccountHandler) UpdateSubAccount(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccountIDStr := c.Param("id")
        subAccountID, err := uuid.Parse(subAccountIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_SUBACCOUNT_ID",
                        "Invalid sub-account ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.UpdateSubAccountRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_REQUEST",
                        "Invalid request format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccount, err := h.subAccountService.UpdateSubAccount(c.Request.Context(), userID, subAccountID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "sub-account not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "SUBACCOUNT_NOT_FOUND",
                                "Sub-account not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "sub-account name already exists for this exchange" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "SUBACCOUNT_NAME_EXISTS",
                                "Sub-account name already exists for this exchange",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "SUBACCOUNT_UPDATE_FAILED",
                        "Failed to update sub-account",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(subAccount, getTraceID(c)))</span>
}

// UpdateBalance updates sub-account balance
// @Summary Update sub-account balance
// @Description Updates sub-account balance with proper logging (must belong to authenticated user)
// @Tags SubAccounts
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Sub-account ID"
// @Param request body services.UpdateBalanceRequest true "Update balance request"
// @Success 200 {object} services.SubAccountResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /sub-accounts/{id}/balance [put]
func (h *SubAccountHandler) UpdateBalance(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccountIDStr := c.Param("id")
        subAccountID, err := uuid.Parse(subAccountIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_SUBACCOUNT_ID",
                        "Invalid sub-account ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.UpdateBalanceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_REQUEST",
                        "Invalid request format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccount, err := h.subAccountService.UpdateBalance(c.Request.Context(), userID, subAccountID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "sub-account not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "SUBACCOUNT_NOT_FOUND",
                                "Sub-account not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "insufficient balance" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INSUFFICIENT_BALANCE",
                                "Insufficient balance",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "BALANCE_UPDATE_FAILED",
                        "Failed to update balance",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(subAccount, getTraceID(c)))</span>
}

// DeleteSubAccount deletes a sub-account
// @Summary Delete sub-account
// @Description Deletes a sub-account configuration (must belong to authenticated user)
// @Tags SubAccounts
// @Produce json
// @Security BearerAuth
// @Param id path string true "Sub-account ID"
// @Success 200 {object} SuccessResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /sub-accounts/{id} [delete]
func (h *SubAccountHandler) DeleteSubAccount(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccountIDStr := c.Param("id")
        subAccountID, err := uuid.Parse(subAccountIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_SUBACCOUNT_ID",
                        "Invalid sub-account ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">err = h.subAccountService.DeleteSubAccount(c.Request.Context(), userID, subAccountID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "sub-account not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "SUBACCOUNT_NOT_FOUND",
                                "Sub-account not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "cannot delete sub-account with positive balance" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "SUBACCOUNT_HAS_BALANCE",
                                "Cannot delete sub-account with positive balance",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "SUBACCOUNT_DELETE_FAILED",
                        "Failed to delete sub-account",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "message": "Sub-account deleted successfully",
        }

        c.JSON(http.StatusOK, CreateSuccessResponse(response, getTraceID(c)))</span>
}

// GetSubAccountsBySymbol retrieves sub-accounts by symbol
// @Summary Get sub-accounts by symbol
// @Description Retrieves all sub-accounts for a specific trading symbol (must belong to authenticated user)
// @Tags SubAccounts
// @Produce json
// @Security BearerAuth
// @Param symbol path string true "Trading symbol"
// @Success 200 {array} services.SubAccountResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /sub-accounts/symbol/{symbol} [get]
func (h *SubAccountHandler) GetSubAccountsBySymbol(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">symbol := c.Param("symbol")
        if symbol == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_SYMBOL",
                        "Symbol is required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccounts, err := h.subAccountService.GetSubAccountsBySymbol(c.Request.Context(), userID, symbol)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "SUBACCOUNTS_GET_FAILED",
                        "Failed to get sub-accounts by symbol",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "sub_accounts": subAccounts,
                "symbol":       symbol,
        }

        c.JSON(http.StatusOK, CreateSuccessResponse(response, getTraceID(c)))</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "net/http"
        "time"

        "tiris-backend/internal/middleware"
        "tiris-backend/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// TradingLogHandler handles trading log management endpoints
type TradingLogHandler struct {
        tradingLogService *services.TradingLogService
}

// NewTradingLogHandler creates a new trading log handler
func NewTradingLogHandler(tradingLogService *services.TradingLogService) *TradingLogHandler <span class="cov0" title="0">{
        return &amp;TradingLogHandler{
                tradingLogService: tradingLogService,
        }
}</span>

// CreateTradingLog creates a new trading log entry
// @Summary Create trading log
// @Description Creates a new trading log entry for the authenticated user
// @Tags TradingLogs
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body services.CreateTradingLogRequest true "Create trading log request"
// @Success 201 {object} services.TradingLogResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /trading-logs [post]
func (h *TradingLogHandler) CreateTradingLog(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.CreateTradingLogRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_REQUEST",
                        "Invalid request format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLog, err := h.tradingLogService.CreateTradingLog(c.Request.Context(), userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "sub-account not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "SUBACCOUNT_NOT_FOUND",
                                "Sub-account not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "transaction not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "TRANSACTION_NOT_FOUND",
                                "Transaction not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOG_CREATE_FAILED",
                        "Failed to create trading log",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, CreateSuccessResponse(tradingLog, getTraceID(c)))</span>
}

// GetUserTradingLogs retrieves all trading logs for the current user
// @Summary Get user trading logs
// @Description Retrieves trading log history for the authenticated user with filtering and pagination
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param type query string false "Filter by log type"
// @Param source query string false "Filter by source" Enums(manual, bot)
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param limit query int false "Number of logs to return" default(100)
// @Param offset query int false "Number of logs to skip" default(0)
// @Success 200 {object} services.TradingLogQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /trading-logs [get]
func (h *TradingLogHandler) GetUserTradingLogs(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TradingLogQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLogs, err := h.tradingLogService.GetUserTradingLogs(c.Request.Context(), userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "start date cannot be after end date" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_DATE_RANGE",
                                "Invalid date range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOGS_QUERY_FAILED",
                        "Failed to query trading logs",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(tradingLogs, getTraceID(c)))</span>
}

// GetSubAccountTradingLogs retrieves trading logs for a specific sub-account
// @Summary Get sub-account trading logs
// @Description Retrieves trading log history for a specific sub-account (must belong to authenticated user)
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param sub_account_id path string true "Sub-account ID"
// @Param type query string false "Filter by log type"
// @Param source query string false "Filter by source" Enums(manual, bot)
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param limit query int false "Number of logs to return" default(100)
// @Param offset query int false "Number of logs to skip" default(0)
// @Success 200 {object} services.TradingLogQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /trading-logs/sub-account/{sub_account_id} [get]
func (h *TradingLogHandler) GetSubAccountTradingLogs(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccountIDStr := c.Param("sub_account_id")
        subAccountID, err := uuid.Parse(subAccountIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_SUBACCOUNT_ID",
                        "Invalid sub-account ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TradingLogQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLogs, err := h.tradingLogService.GetSubAccountTradingLogs(c.Request.Context(), userID, subAccountID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "sub-account not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "SUBACCOUNT_NOT_FOUND",
                                "Sub-account not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "start date cannot be after end date" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_DATE_RANGE",
                                "Invalid date range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOGS_QUERY_FAILED",
                        "Failed to query sub-account trading logs",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(tradingLogs, getTraceID(c)))</span>
}

// GetExchangeTradingLogs retrieves trading logs for a specific exchange
// @Summary Get exchange trading logs
// @Description Retrieves trading log history for a specific exchange (must belong to authenticated user)
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param exchange_id path string true "Exchange ID"
// @Param type query string false "Filter by log type"
// @Param source query string false "Filter by source" Enums(manual, bot)
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param limit query int false "Number of logs to return" default(100)
// @Param offset query int false "Number of logs to skip" default(0)
// @Success 200 {object} services.TradingLogQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /trading-logs/exchange/{exchange_id} [get]
func (h *TradingLogHandler) GetExchangeTradingLogs(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchangeIDStr := c.Param("exchange_id")
        exchangeID, err := uuid.Parse(exchangeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_EXCHANGE_ID",
                        "Invalid exchange ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TradingLogQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLogs, err := h.tradingLogService.GetExchangeTradingLogs(c.Request.Context(), userID, exchangeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "start date cannot be after end date" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_DATE_RANGE",
                                "Invalid date range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOGS_QUERY_FAILED",
                        "Failed to query exchange trading logs",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(tradingLogs, getTraceID(c)))</span>
}

// GetTradingLog retrieves a specific trading log by ID
// @Summary Get trading log by ID
// @Description Retrieves a specific trading log by ID (must belong to authenticated user)
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param id path string true "Trading Log ID"
// @Success 200 {object} services.TradingLogResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /trading-logs/{id} [get]
func (h *TradingLogHandler) GetTradingLog(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLogIDStr := c.Param("id")
        tradingLogID, err := uuid.Parse(tradingLogIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_TRADING_LOG_ID",
                        "Invalid trading log ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLog, err := h.tradingLogService.GetTradingLog(c.Request.Context(), userID, tradingLogID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "trading log not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "TRADING_LOG_NOT_FOUND",
                                "Trading log not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOG_GET_FAILED",
                        "Failed to get trading log",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(tradingLog, getTraceID(c)))</span>
}

// GetTradingLogsByTimeRange retrieves trading logs within a specific time range
// @Summary Get trading logs by time range
// @Description Retrieves trading logs within a specific time range for the authenticated user
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param start_time query string true "Start time (RFC3339 format)"
// @Param end_time query string true "End time (RFC3339 format)"
// @Param type query string false "Filter by log type"
// @Param source query string false "Filter by source" Enums(manual, bot)
// @Param limit query int false "Number of logs to return" default(100)
// @Param offset query int false "Number of logs to skip" default(0)
// @Success 200 {object} services.TradingLogQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /trading-logs/time-range [get]
func (h *TradingLogHandler) GetTradingLogsByTimeRange(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        // Parse required time range parameters
        <span class="cov0" title="0">startTimeStr := c.Query("start_time")
        endTimeStr := c.Query("end_time")

        if startTimeStr == "" || endTimeStr == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "MISSING_TIME_RANGE",
                        "Start time and end time are required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">startTime, err := time.Parse(time.RFC3339, startTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_START_TIME",
                        "Invalid start time format (use RFC3339)",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">endTime, err := time.Parse(time.RFC3339, endTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_END_TIME",
                        "Invalid end time format (use RFC3339)",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TradingLogQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLogs, err := h.tradingLogService.GetTradingLogsByTimeRange(c.Request.Context(), userID, startTime, endTime, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "start time cannot be after end time" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_TIME_RANGE",
                                "Invalid time range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOGS_QUERY_FAILED",
                        "Failed to query trading logs by time range",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(tradingLogs, getTraceID(c)))</span>
}

// DeleteTradingLog deletes a trading log
// @Summary Delete trading log
// @Description Deletes a trading log entry (must belong to authenticated user and be manual)
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param id path string true "Trading Log ID"
// @Success 200 {object} SuccessResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /trading-logs/{id} [delete]
func (h *TradingLogHandler) DeleteTradingLog(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLogIDStr := c.Param("id")
        tradingLogID, err := uuid.Parse(tradingLogIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_TRADING_LOG_ID",
                        "Invalid trading log ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">err = h.tradingLogService.DeleteTradingLog(c.Request.Context(), userID, tradingLogID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "trading log not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "TRADING_LOG_NOT_FOUND",
                                "Trading log not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "cannot delete bot-generated trading logs" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "CANNOT_DELETE_BOT_LOG",
                                "Cannot delete bot-generated trading logs",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOG_DELETE_FAILED",
                        "Failed to delete trading log",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "message": "Trading log deleted successfully",
        }

        c.JSON(http.StatusOK, CreateSuccessResponse(response, getTraceID(c)))</span>
}

// ListAllTradingLogs lists all trading logs with filtering (admin only)
// @Summary List all trading logs
// @Description Lists all trading logs with filtering and pagination (admin only)
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param type query string false "Filter by log type"
// @Param source query string false "Filter by source" Enums(manual, bot)
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param limit query int false "Number of logs to return" default(100)
// @Param offset query int false "Number of logs to skip" default(0)
// @Success 200 {object} services.TradingLogQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /admin/trading-logs [get]
func (h *TradingLogHandler) ListAllTradingLogs(c *gin.Context) <span class="cov0" title="0">{
        var req services.TradingLogQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLogs, err := h.tradingLogService.ListAllTradingLogs(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "start date cannot be after end date" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_DATE_RANGE",
                                "Invalid date range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOGS_LIST_FAILED",
                        "Failed to list trading logs",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(tradingLogs, getTraceID(c)))</span>
}

// GetTradingLogByID retrieves trading log by ID (admin only)
// @Summary Get trading log by ID
// @Description Retrieves a trading log by ID (admin only)
// @Tags TradingLogs
// @Produce json
// @Security BearerAuth
// @Param id path string true "Trading Log ID"
// @Success 200 {object} services.TradingLogResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /admin/trading-logs/{id} [get]
func (h *TradingLogHandler) GetTradingLogByID(c *gin.Context) <span class="cov0" title="0">{
        tradingLogIDStr := c.Param("id")
        tradingLogID, err := uuid.Parse(tradingLogIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_TRADING_LOG_ID",
                        "Invalid trading log ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">tradingLog, err := h.tradingLogService.GetTradingLogByID(c.Request.Context(), tradingLogID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "trading log not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "TRADING_LOG_NOT_FOUND",
                                "Trading log not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRADING_LOG_GET_FAILED",
                        "Failed to get trading log",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(tradingLog, getTraceID(c)))</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "net/http"
        "time"

        "tiris-backend/internal/middleware"
        "tiris-backend/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// TransactionHandler handles transaction query endpoints
type TransactionHandler struct {
        transactionService *services.TransactionService
}

// NewTransactionHandler creates a new transaction handler
func NewTransactionHandler(transactionService *services.TransactionService) *TransactionHandler <span class="cov0" title="0">{
        return &amp;TransactionHandler{
                transactionService: transactionService,
        }
}</span>

// GetUserTransactions retrieves all transactions for the current user
// @Summary Get user transactions
// @Description Retrieves transaction history for the authenticated user with filtering and pagination
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Param direction query string false "Filter by direction" Enums(debit, credit)
// @Param reason query string false "Filter by reason"
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param min_amount query number false "Minimum amount filter"
// @Param max_amount query number false "Maximum amount filter"
// @Param limit query int false "Number of transactions to return" default(100)
// @Param offset query int false "Number of transactions to skip" default(0)
// @Success 200 {object} services.TransactionQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /transactions [get]
func (h *TransactionHandler) GetUserTransactions(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TransactionQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transactions, err := h.transactionService.GetUserTransactions(c.Request.Context(), userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "start date cannot be after end date" ||
                        err.Error() == "min amount cannot be greater than max amount" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_FILTER_RANGE",
                                "Invalid filter range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRANSACTIONS_QUERY_FAILED",
                        "Failed to query transactions",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(transactions, getTraceID(c)))</span>
}

// GetSubAccountTransactions retrieves transactions for a specific sub-account
// @Summary Get sub-account transactions
// @Description Retrieves transaction history for a specific sub-account (must belong to authenticated user)
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Param sub_account_id path string true "Sub-account ID"
// @Param direction query string false "Filter by direction" Enums(debit, credit)
// @Param reason query string false "Filter by reason"
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param min_amount query number false "Minimum amount filter"
// @Param max_amount query number false "Maximum amount filter"
// @Param limit query int false "Number of transactions to return" default(100)
// @Param offset query int false "Number of transactions to skip" default(0)
// @Success 200 {object} services.TransactionQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /transactions/sub-account/{sub_account_id} [get]
func (h *TransactionHandler) GetSubAccountTransactions(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">subAccountIDStr := c.Param("sub_account_id")
        subAccountID, err := uuid.Parse(subAccountIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_SUBACCOUNT_ID",
                        "Invalid sub-account ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TransactionQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transactions, err := h.transactionService.GetSubAccountTransactions(c.Request.Context(), userID, subAccountID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "sub-account not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "SUBACCOUNT_NOT_FOUND",
                                "Sub-account not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "start date cannot be after end date" ||
                        err.Error() == "min amount cannot be greater than max amount" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_FILTER_RANGE",
                                "Invalid filter range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRANSACTIONS_QUERY_FAILED",
                        "Failed to query sub-account transactions",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(transactions, getTraceID(c)))</span>
}

// GetExchangeTransactions retrieves transactions for a specific exchange
// @Summary Get exchange transactions
// @Description Retrieves transaction history for a specific exchange (must belong to authenticated user)
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Param exchange_id path string true "Exchange ID"
// @Param direction query string false "Filter by direction" Enums(debit, credit)
// @Param reason query string false "Filter by reason"
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param min_amount query number false "Minimum amount filter"
// @Param max_amount query number false "Maximum amount filter"
// @Param limit query int false "Number of transactions to return" default(100)
// @Param offset query int false "Number of transactions to skip" default(0)
// @Success 200 {object} services.TransactionQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /transactions/exchange/{exchange_id} [get]
func (h *TransactionHandler) GetExchangeTransactions(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">exchangeIDStr := c.Param("exchange_id")
        exchangeID, err := uuid.Parse(exchangeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_EXCHANGE_ID",
                        "Invalid exchange ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TransactionQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transactions, err := h.transactionService.GetExchangeTransactions(c.Request.Context(), userID, exchangeID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "exchange not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "EXCHANGE_NOT_FOUND",
                                "Exchange not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "start date cannot be after end date" ||
                        err.Error() == "min amount cannot be greater than max amount" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_FILTER_RANGE",
                                "Invalid filter range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRANSACTIONS_QUERY_FAILED",
                        "Failed to query exchange transactions",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(transactions, getTraceID(c)))</span>
}

// GetTransaction retrieves a specific transaction by ID
// @Summary Get transaction by ID
// @Description Retrieves a specific transaction by ID (must belong to authenticated user)
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Param id path string true "Transaction ID"
// @Success 200 {object} services.TransactionResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /transactions/{id} [get]
func (h *TransactionHandler) GetTransaction(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transactionIDStr := c.Param("id")
        transactionID, err := uuid.Parse(transactionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_TRANSACTION_ID",
                        "Invalid transaction ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transaction, err := h.transactionService.GetTransaction(c.Request.Context(), userID, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "transaction not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "TRANSACTION_NOT_FOUND",
                                "Transaction not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRANSACTION_GET_FAILED",
                        "Failed to get transaction",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(transaction, getTraceID(c)))</span>
}

// GetTransactionsByTimeRange retrieves transactions within a specific time range
// @Summary Get transactions by time range
// @Description Retrieves transactions within a specific time range for the authenticated user
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Param start_time query string true "Start time (RFC3339 format)"
// @Param end_time query string true "End time (RFC3339 format)"
// @Param direction query string false "Filter by direction" Enums(debit, credit)
// @Param reason query string false "Filter by reason"
// @Param min_amount query number false "Minimum amount filter"
// @Param max_amount query number false "Maximum amount filter"
// @Param limit query int false "Number of transactions to return" default(100)
// @Param offset query int false "Number of transactions to skip" default(0)
// @Success 200 {object} services.TransactionQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /transactions/time-range [get]
func (h *TransactionHandler) GetTransactionsByTimeRange(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        // Parse required time range parameters
        <span class="cov0" title="0">startTimeStr := c.Query("start_time")
        endTimeStr := c.Query("end_time")

        if startTimeStr == "" || endTimeStr == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "MISSING_TIME_RANGE",
                        "Start time and end time are required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">startTime, err := time.Parse(time.RFC3339, startTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_START_TIME",
                        "Invalid start time format (use RFC3339)",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">endTime, err := time.Parse(time.RFC3339, endTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_END_TIME",
                        "Invalid end time format (use RFC3339)",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.TransactionQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transactions, err := h.transactionService.GetTransactionsByTimeRange(c.Request.Context(), userID, startTime, endTime, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "start time cannot be after end time" ||
                        err.Error() == "min amount cannot be greater than max amount" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_FILTER_RANGE",
                                "Invalid filter range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRANSACTIONS_QUERY_FAILED",
                        "Failed to query transactions by time range",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(transactions, getTraceID(c)))</span>
}

// ListAllTransactions lists all transactions with filtering (admin only)
// @Summary List all transactions
// @Description Lists all transactions with filtering and pagination (admin only)
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Param direction query string false "Filter by direction" Enums(debit, credit)
// @Param reason query string false "Filter by reason"
// @Param start_date query string false "Start date (RFC3339 format)"
// @Param end_date query string false "End date (RFC3339 format)"
// @Param min_amount query number false "Minimum amount filter"
// @Param max_amount query number false "Maximum amount filter"
// @Param limit query int false "Number of transactions to return" default(100)
// @Param offset query int false "Number of transactions to skip" default(0)
// @Success 200 {object} services.TransactionQueryResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /admin/transactions [get]
func (h *TransactionHandler) ListAllTransactions(c *gin.Context) <span class="cov0" title="0">{
        var req services.TransactionQueryRequest
        if err := c.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_QUERY_PARAMS",
                        "Invalid query parameters",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transactions, err := h.transactionService.ListAllTransactions(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "start date cannot be after end date" ||
                        err.Error() == "min amount cannot be greater than max amount" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, CreateErrorResponse(
                                "INVALID_FILTER_RANGE",
                                "Invalid filter range",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRANSACTIONS_LIST_FAILED",
                        "Failed to list transactions",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(transactions, getTraceID(c)))</span>
}

// GetTransactionByID retrieves transaction by ID (admin only)
// @Summary Get transaction by ID
// @Description Retrieves a transaction by ID (admin only)
// @Tags Transactions
// @Produce json
// @Security BearerAuth
// @Param id path string true "Transaction ID"
// @Success 200 {object} services.TransactionResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /admin/transactions/{id} [get]
func (h *TransactionHandler) GetTransactionByID(c *gin.Context) <span class="cov0" title="0">{
        transactionIDStr := c.Param("id")
        transactionID, err := uuid.Parse(transactionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_TRANSACTION_ID",
                        "Invalid transaction ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">transaction, err := h.transactionService.GetTransactionByID(c.Request.Context(), transactionID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "transaction not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "TRANSACTION_NOT_FOUND",
                                "Transaction not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "TRANSACTION_GET_FAILED",
                        "Failed to get transaction",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(transaction, getTraceID(c)))</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import "time"

// SuccessResponse represents a successful API response
type SuccessResponse struct {
        Success  bool             `json:"success"`
        Data     interface{}      `json:"data"`
        Metadata ResponseMetadata `json:"metadata"`
}

// ErrorResponse represents an error API response
type ErrorResponse struct {
        Success  bool             `json:"success"`
        Error    ErrorDetail      `json:"error"`
        Metadata ResponseMetadata `json:"metadata"`
}

// ErrorDetail represents error details
type ErrorDetail struct {
        Code    string `json:"code"`
        Message string `json:"message"`
        Details string `json:"details,omitempty"`
}

// ResponseMetadata represents response metadata
type ResponseMetadata struct {
        Timestamp string `json:"timestamp"`
        TraceID   string `json:"trace_id,omitempty"`
}

// PaginationMetadata represents pagination information
type PaginationMetadata struct {
        Total      int64 `json:"total"`
        Limit      int   `json:"limit"`
        Offset     int   `json:"offset"`
        HasMore    bool  `json:"has_more"`
        NextOffset *int  `json:"next_offset,omitempty"`
}

// PaginatedResponse represents a paginated API response
type PaginatedResponse struct {
        Success    bool                `json:"success"`
        Data       interface{}         `json:"data"`
        Pagination *PaginationMetadata `json:"pagination,omitempty"`
        Metadata   ResponseMetadata    `json:"metadata"`
}

// CreateSuccessResponse creates a success response
func CreateSuccessResponse(data interface{}, traceID string) SuccessResponse <span class="cov0" title="0">{
        return SuccessResponse{
                Success: true,
                Data:    data,
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   traceID,
                },
        }
}</span>

// CreateErrorResponse creates an error response
func CreateErrorResponse(code, message, details, traceID string) ErrorResponse <span class="cov0" title="0">{
        return ErrorResponse{
                Success: false,
                Error: ErrorDetail{
                        Code:    code,
                        Message: message,
                        Details: details,
                },
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   traceID,
                },
        }
}</span>

// CreatePaginatedResponse creates a paginated response
func CreatePaginatedResponse(data interface{}, pagination *PaginationMetadata, traceID string) PaginatedResponse <span class="cov0" title="0">{
        return PaginatedResponse{
                Success:    true,
                Data:       data,
                Pagination: pagination,
                Metadata: ResponseMetadata{
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                        TraceID:   traceID,
                },
        }
}</span>

// HealthCheckResponse represents health check response
type HealthCheckResponse struct {
        Status    string                 `json:"status"`
        Checks    map[string]string      `json:"checks,omitempty"`
        Timestamp string                 `json:"timestamp"`
        Metadata  map[string]interface{} `json:"metadata,omitempty"`
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "net/http"
        "strconv"

        "tiris-backend/internal/middleware"
        "tiris-backend/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// UserHandler handles user management endpoints
type UserHandler struct {
        userService *services.UserService
}

// NewUserHandler creates a new user handler
func NewUserHandler(userService *services.UserService) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                userService: userService,
        }
}</span>

// GetCurrentUser retrieves current user profile
// @Summary Get current user profile
// @Description Retrieves the profile of the currently authenticated user
// @Tags Users
// @Produce json
// @Security BearerAuth
// @Success 200 {object} services.UserResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users/me [get]
func (h *UserHandler) GetCurrentUser(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.GetCurrentUser(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "USER_GET_FAILED",
                        "Failed to get user profile",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(user, getTraceID(c)))</span>
}

// UpdateCurrentUser updates current user profile
// @Summary Update current user profile
// @Description Updates the profile of the currently authenticated user
// @Tags Users
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body services.UpdateUserRequest true "Update user request"
// @Success 200 {object} services.UserResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users/me [put]
func (h *UserHandler) UpdateCurrentUser(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">var req services.UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_REQUEST",
                        "Invalid request format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.UpdateCurrentUser(c.Request.Context(), userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "username already taken" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, CreateErrorResponse(
                                "USERNAME_TAKEN",
                                "Username is already taken",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "USER_UPDATE_FAILED",
                        "Failed to update user profile",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(user, getTraceID(c)))</span>
}

// GetUserStats retrieves current user statistics
// @Summary Get current user statistics
// @Description Retrieves statistics for the currently authenticated user
// @Tags Users
// @Produce json
// @Security BearerAuth
// @Success 200 {object} map[string]interface{}
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users/me/stats [get]
func (h *UserHandler) GetUserStats(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, CreateErrorResponse(
                        "AUTH_REQUIRED",
                        "Authentication required",
                        "",
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.userService.GetUserStats(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "STATS_GET_FAILED",
                        "Failed to get user statistics",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(stats, getTraceID(c)))</span>
}

// ListUsers lists all users (admin only)
// @Summary List all users
// @Description Lists all users with pagination (admin only)
// @Tags Users
// @Produce json
// @Security BearerAuth
// @Param limit query int false "Number of users to return" default(100)
// @Param offset query int false "Number of users to skip" default(0)
// @Success 200 {object} PaginatedResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users [get]
func (h *UserHandler) ListUsers(c *gin.Context) <span class="cov0" title="0">{
        // Parse pagination parameters
        limit := 100
        if l := c.Query("limit"); l != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(l); err == nil &amp;&amp; parsed &gt; 0 &amp;&amp; parsed &lt;= 1000 </span><span class="cov0" title="0">{
                        limit = parsed
                }</span>
        }

        <span class="cov0" title="0">offset := 0
        if o := c.Query("offset"); o != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(o); err == nil &amp;&amp; parsed &gt;= 0 </span><span class="cov0" title="0">{
                        offset = parsed
                }</span>
        }

        <span class="cov0" title="0">users, total, err := h.userService.ListUsers(c.Request.Context(), limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "USERS_LIST_FAILED",
                        "Failed to list users",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        // Create pagination metadata
        <span class="cov0" title="0">hasMore := int64(offset+limit) &lt; total
        var nextOffset *int
        if hasMore </span><span class="cov0" title="0">{
                next := offset + limit
                nextOffset = &amp;next
        }</span>

        <span class="cov0" title="0">pagination := &amp;PaginationMetadata{
                Total:      total,
                Limit:      limit,
                Offset:     offset,
                HasMore:    hasMore,
                NextOffset: nextOffset,
        }

        response := map[string]interface{}{
                "users": users,
        }

        c.JSON(http.StatusOK, CreatePaginatedResponse(response, pagination, getTraceID(c)))</span>
}

// GetUserByID retrieves user by ID (admin only)
// @Summary Get user by ID
// @Description Retrieves a user by their ID (admin only)
// @Tags Users
// @Produce json
// @Security BearerAuth
// @Param id path string true "User ID"
// @Success 200 {object} services.UserResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users/{id} [get]
func (h *UserHandler) GetUserByID(c *gin.Context) <span class="cov0" title="0">{
        userIDStr := c.Param("id")
        userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_USER_ID",
                        "Invalid user ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.GetUserByID(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "user not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "USER_NOT_FOUND",
                                "User not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "USER_GET_FAILED",
                        "Failed to get user",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateSuccessResponse(user, getTraceID(c)))</span>
}

// DisableUser disables a user account (admin only)
// @Summary Disable user account
// @Description Disables a user account by ID (admin only)
// @Tags Users
// @Produce json
// @Security BearerAuth
// @Param id path string true "User ID"
// @Success 200 {object} SuccessResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 403 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users/{id}/disable [put]
func (h *UserHandler) DisableUser(c *gin.Context) <span class="cov0" title="0">{
        userIDStr := c.Param("id")
        userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateErrorResponse(
                        "INVALID_USER_ID",
                        "Invalid user ID format",
                        err.Error(),
                        getTraceID(c),
                ))
                return
        }</span>

        <span class="cov0" title="0">err = h.userService.DisableUser(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "user not found" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, CreateErrorResponse(
                                "USER_NOT_FOUND",
                                "User not found",
                                err.Error(),
                                getTraceID(c),
                        ))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, CreateErrorResponse(
                        "USER_DISABLE_FAILED",
                        "Failed to disable user",
                        err.Error(),
                        getTraceID(c),
                ))
                return</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "message": "User account disabled successfully",
        }

        c.JSON(http.StatusOK, CreateSuccessResponse(response, getTraceID(c)))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
